<!--nn: link to original content:  -->
# R Markdownで作るダッシュボード { flexdashboard }

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_output.png"))
```

このページでは、 **flexdashboard** パッケージの基本的な使い方を解説します。このパッケージは、R Markdown の出力をパネルやページを持つダッシュボードとして簡単に整えることができます。ダッシュボードの内容は、文章、図/表、インタラクティブな内容などとすることができます。

**flexdashboard** のメリット：

* 標準的でない R のコードは最小限の記載で済ませることができます。わずかな練習ですぐにダッシュボードを作成することができます。
* ダッシュボードは、自己完結型のHTMLファイルとして同僚に電子メールで送信することができます。サーバーは不要です。
* **flexdashboard** は、**shiny** や **ggplotly** などの <u>"html widgets"</u> と組み合わせて、インタラクティブなダッシュボードとすることができます。

**flexdashboard**のデメリット： 

* **shiny** 単独でダッシュボードを作成するのに比べて、カスタマイズ性に劣ります。

このページで紹介されている **flexdashboard** の使い方に関する包括的なチュートリアルは、「リソース」セクションにあります。以下では、パッケージの主要な機能を説明した上で、`linelist` データを使ってアウトブレイクを調査するダッシュボードの構築例を紹介します。  

## 準備

### パッケージの読み込み {.unnumbered}

このハンドブックでは、**pacman** の `p_load()` の利用を推奨しています。`p_load()`は、必要に応じてパッケージをインストールして <u>かつ</u> 利用するために読み込んでくれます。あるいは、 **base** パッケージの `library()` を用いてインストールされたパッケージを読み込むことが可能です。R のパッケージの詳細については、[R Basics] のページを参照してください。  

```{r}
pacman::p_load(
  rio,             # データのインポート/エクスポート
  here,            # ローカルファイル
  tidyverse,       # データの加工と可視化
  flexdashboard,   # R Markdown レポートのダッシュボード版
  shiny,           # インタラクティブな図表
  plotly           # インタラクティブな図
)
```

### データのインポート {.unnumbered}  

コードを追いたい人は、 <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>ここをクリックして「キレイな」 linelist データを取得</a>してください（`.rds` ファイルとして取得できます）。データを **rio** パッケージの `import()`を利用して読み込んでください。（これは、 .xlsx、.csv、.rds などのたくさんの種類のファイルを扱うことができます。詳しくは、[Imprort and export] のページをみてください。）

```{r, echo=F}
# linelist を R に取り込む
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# linelist を取り込む
linelist <- import("linelist_cleaned.rds")
```

linelist の最初の50行を以下に表示します。

```{r, message=FALSE, echo=F}
# linelist データを表形式で表示する
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

## 新しい R Markdown を作成する

パッケージをインストールをした後、<u>File > New file > R Markdown</u> と選択して新しい R Markdown ファイルを作成してください。

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_new1.png"))
```

開いたウィンドウから "From Template" を選択して、次に、 "Flex Dashboard" テンプレートを選んでください。その後、ドキュメントの名前をつけるように促されます。このページの例では、R Markdown に "outbreak_dashboard.Rmd" と命名しましょう。

```{r out.width = "100%", out.height="75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_new2.png"))
```

## スクリプト  

記載するスクリプトは、R Markdown そのものです。そのため、[Reports with R Markdown] のページで解説されたものと同じように記載されています。ここで、簡単に再度これらの記載を紹介して、他のR Markdownの出力結果との違いを示しておきます。

### YAML {.unnumbered}  

スクリプトの一番上には、"YAML" ヘッダがあります。これは、`---`のように3本のダッシュで始まる必要があり、`---`のように3本のダッシュで終わる必要があります。YAML のパラメーターは `key:values` の組み合わせで記載されます。**YAMLでは、インデントとコロンの記載が大切です** - `key:value` の組み合わせはイコール記号ではなく、コロンで分けられることに注意が必要です。

YAMLは文書のメタデータで始まる必要があります。YAMLに記載される（インデントされていない）パラメーターの順番は重要ではありません。例えば次のような形です。

```{r, eval=F}
title: "My document"
author: "Me"
date: "`r Sys.Date()`"
```
インラインコードを書く（`r`に続いてバックティックの中に記載する）ように、YAML の中で R のコードを使うことができます。また、上のYAML内の date にあるように、クオーテーションの中に入れて書くこともできます。  

必須とされる YAML パラメーターは `output: `です。これは、どのような種類のファイルが生成されるかを指定します。（例： `html_document`、`pdf_document`、`word_document` や `powerpoint_presentation` など。）**flexdashboard** では、このパラメーターの指定は少し混乱するかもしれません。必ず `output:flexdashboard::flex_dashboard` と指定する必要があります。コロンの個数とアンダースコアに注意してください。YAMLの出力のためのパラメーターは、<u>追加のコロン</u>が入力されて、インデントされた追加の設定が続くことが多いです。（具体的には、以下のチャンクにある `orientation: ` と `vertical_layout: ` のパラメーターを参照してください。）

```{r, eval=F}
title: "My dashboard"
author: "Me"
date: "`r Sys.Date()`"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
```

上に示したように、 二つのスペースで作られたインデントがサブパラメーターに利用されています。このケースでは、`key:values:`のように、親となるパラメーターの後にコロンを追加で入力するのを忘れないようにしましょう。 

ロジカル値をパラメーターに与える必要がある場合は、YAML内では小文字で記載される必要があります（ `true`、`false`、`null` ）。もしコロンが（タイトルなどで）値の一部である場合はクオーテーションの中に値を入れてください。詳しくは次のセクションの中の例を参照してください。

### コードチャンク {.unnumbered}  

R Markdown は複数の「チャンク」を含むことができます。複数行の R のコードをチャンク内に書くことができて、これらは R のスクリプトとして動作します。

コードチャンクは、三つのバックティックと、小文字の「r」が入った中括弧で作成され、三つのバックティックで閉じられます。 キーボードショートカット、「Ctrl + Alt + i」（Mac では Cmd + Shift + r）、を入力するか、スクリプトエディタの上にある 「insert a new code chunk」と表示されている緑のボタンをクリックすることで新しいチャンクを自身で作成してみてください。コードチャンクの例は多数、以下に例示してあります。

### ナラティブテキスト {.unnumbered}  

R コード「チャンク」の外には、ナラティブテキストを書くことができます。[Reports with R Markdown]()ページで解説されているように、アスタリスク（ \* ）一つでテキストを囲むことでイタリックにすることができます。あるいは、アスタリスク二つ（\*\*）でテキストを囲むことで太字にすることもできます。箇条書きや数値による箇条書きは新しい列、インデント、行の最後にスペースの入力が二つ必要となることに注意してください。


You can also insert in-line R code into text as described in the [Reports with R Markdown] page, by surrounding the code with backticks and starting the command with "r": `` ` 1+1` ``(see example with date above).  

[Reports with R Markdown]() のページに記載されているように、インライン R コードはバックティック（`）で囲まれたコード（`` `1+1` ``）の先頭に "r" をつけることで入力することができます（上の date にある例を参照してください）。


### 見出し {.unnumbered}  

[Reports with R Markdown]() のページで説明されたように、見出しのレベルはハッシュ記号の入力の個数で表現されます。

**flexdashboard** では、見出し１（#）はダッシュボードの「ページ」を作成します。見出し２（##）は `orientation:`パラメーターに応じて列や行を作ります（詳細は下記を参照ください）。見出し３（###）は図、表、テキストなどのためのパネルを作成します。

```md
# 見出し１ （ページ）

## 見出し２ （行か列）

### 見出し３ （図、表などのペーン）
```

## セクションの属性

通常の R マークダウンと同様に、ダッシュボードの一部に適用する属性を指定するには、見出しの後、中括弧 `{ }` の中に `key=value` オプションを入れます。例えば、典型的な HTML の R マークダウンレポートでは、`## My heading {.tabset}` とすることで、小見出しをタブにまとめることができます。  

ここの例では、 <u>見出し</u>のテキスト部分の後に属性が記載されていることに注意してください。これらは、R コードチャンクの上部に入力される **knitr** のオプション（例えば、 `out.height = `）とは違います。

**flexdashboard** に特異的なセクションの属性には次のようなものがあります：

* `{data-orientation=}`：`rows` または `columns` のいずれかに設定します。ダッシュボードに複数のページがある場合は、各ページにこの属性を追加して、方向性を示してください (詳細は [レイアウトセクション](#layout) で説明しています)。  

* `{data-width=}` と `{data-height=}` は、同じ次元（水平または垂直）にレイアウトされたグラフ、列、行の相対的なサイズを設定します。絶対的なサイズは、[flexbox](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes) エンジンのおかげで、どのようなディスプレイデバイスでも表示されるスペースが最適になるように調整されます。
     * グラフの高さは、YAML パラメータの `vertical_layout: fill` と `vertical_layout: scroll` のどちらを設定するかにも依存します。scrollに設定した場合、図の高さは R コードチャンクの一般的な `fig.height = ` オプションを反映します。  
     * 完全なドキュメントは [flexdashboard website](https://rmarkdown.rstudio.com/flexdashboard/using.html#sizing) を参照してください。
* `{.hidden}` ナビゲーションバーから特定のページを除外するために利用します。
* `{data-navbar=}` ページレベルの見出しに使用して、ナビゲーションバーのドロップダウンメニュー内に入れ子にします。 ドロップダウンメニューの名前（引用符で囲んだ）を入力してください。 例は以下のようなものです。


## レイアウト {#layout}  

ダッシュボードのレイアウトを以下の方法で調整します。  

* R Markdown の見出し（#、##、##など）を使ったページ、列/行、チャートを追加します
* YAML パラメータの `orientation:` を `rows` または` columns` のいずれかに調整します
* ブラウザの領域いっぱいにレイアウトを表示するか、スクロールさせるかを指定します
* 特定のセクションの見出しにタブを追加します


### ページ {.unnumbered}  

R Markdown で、一番大きな見出しレベル（#）はダッシュボードの「ページ」を意味します。デフォルトの設定では、ページは、一番上に表示されるナビゲーションバーメニューに順番並んで表示されます。

```{r, out.height = c('100%'), out.width = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_pages_top_script.png"))
```


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_pages_top_view.png"))
```



ページの見出しに`{data-navmenu=}`という属性を付けることで、トップナビゲーションバー内の「メニュー」としてページをまとめることができます。等号の周りにスペースを入れると、うまくいきませんので、気を付けてください！

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_navmenu_script.png"))
```


次がスクリプトの実行結果です：


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_navmenu_view.png"))
```

また、`{.sidebar}`属性を追加することで、ページやカラムをダッシュボードの左側にある「サイドバー」として表示することができます。サイドバーには（どのページからも表示可能な）テキストを表示したり、**shiny** のインタラクティブ機能を組み込んでいる場合は、スライダーやドロップダウンメニューなどのユーザー入力用コントロールを表示するのに便利です。  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_sidebar_script.png"))
```

次がスクリプトの実行結果です：

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_sidebar_view.png"))
```




### オリエンテーション {.unnumbered}  

yaml パラメータに `orientation:` を設定して、第 2 レベル （##） の R Markdown の見出しがどのような順番で並べるかを指定します - `orientation: columns` または `orientation: rows` のどちらかを入力しましょう。

第 2 レベルの見出し （##） は、この `orientation` の設定に基づいて、新しい列または行として解釈されます。  

orientation: columns` と設定すると、第 2 レベルの見出しがダッシュボードに新しい列を作成します。次のダッシュボードには、2 つのカラムを含む 1 つのページがあり、合計で 3 つのパネルがあります。カラムの相対的な幅は、以下のように `{data-width=}` で調整することができます。  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_columns_script.png"))
```

次がスクリプトの実行結果です：

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_columns_view.png"))
```

orientation: rows` を設定すると、セカンドレベルヘッダーは列の代わりに新しい行を作成します。以下は上記と同じスクリプトですが、`orientation: rows`が設定されており、第 2 レベルの見出しが列ではなく行を生成するようになります。以下のように、 `{data-height=}` で行の相対的な <u>高さ</u> を調整することもできます。 

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_rows_script.png"))
```

次がスクリプトの実行結果です：

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_rows_view.png"))
```

ダッシュボードが複数のページを持つ場合、各ページのヘッダーに `{data-orientation=}` 属性を追加することで、特定のページごとに方向を指定できます（引用符なしで `rows` または `columns` のどちらかを指定できます）。  

### タブ {.unnumbered} 

他の HTML R Markdown の出力と同様に、`{.tabset}` 属性でコンテンツをタブに分割することができます。

単純に、この属性を必要な見出しの後に追加するだけです。その見出しの下にある小見出しは、タブとして表示されるようになります。例えば、下記のスクリプトでは、右の列その 2（##）が変更されており、流行曲線と表ペイン（###）の内容がタブで表示されるようになりました。

オリエンテーションの設定が行であれば、行でも同じことができます。  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_tabs_script.png"))
```

次がスクリプトの実行結果です：

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_tabs_view.png"))
```


## コンテンツを追加する

それでは、ダッシュボードを作り始めましょう。ここで作成するシンプルなダッシュボードは、1 ページ、2 カラム、4 パネルで構成されます。パネルをひとつひとつ組み立てながら解説します。

テキスト、ggplot、テーブルなど、R の標準的な出力を簡単に含めることができます（詳しくは、[プレゼンテーション用テーブル]()のページを参照してください）。他の R Markdown スクリプトのように、R コードチャンク内でそれらをコード化するだけです。

注：完成した Rmd スクリプトと HTML ダッシュボードの出力はダウンロードすることができます - [ハンドブックとデータのダウンロード]()のページをご覧ください。  


### テキスト {.unnumbered}  
 
Markdown テキストを入力し、他の R Markdown 出力のように<u>インライン</u>コードを含めることができます。詳細については[R Markdownを使用したレポート]()ページを参照してください。

このダッシュボードには、最新の入院日とアウトブレイクで報告された症例数が自動的に変わるテキストを含む、集計した結果を表示するテキストパネルが用意されています。

### 表 {.unnumbered}  

表などの出力を出力する R コードチャンクを含めることができます。この場合、テーブルを表示するために **knitr** の `kable()` 関数を使用すると、出力が最も見栄えよく見え、かつ、表示されるウィンドウサイズに対応します。**flextable** パッケージの関数を利用すると、短い表や、一部分を切り落とした表を作成することができます。

例えば、以下では `linelist` を `count()` コマンドを利用して、病院ごとの症例のサマリーテーブルを作成しています。最終的に、この表は `knitr::kable()` に渡され、結果には右側にスクロールバーが表示されます。kable()` と **kableExtra** を使った表のカスタマイズについては、[こちら](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html) を参照してください。  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_tables_script.png"))
```

次がスクリプトの実行結果です：

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_tables_view.png"))
```


もし、ユーザーにデータフレームの表示される「ページ」を抽出、並び変え、操作できるような動的な表を表示したい場合は、以下のコードのように、パッケージ **DT** とその関数 `datatable()` を使用します。  

以下のサンプルコードでは、データフレーム `linelist` が表示されます。rownames = FALSE` を設定すると水平方向のスペースを節約でき、 `filter = "top"` を設定すると、すべての列の一番上にフィルタを配置することができます。その他の指定項目のリストは `options = ` に与えることができる。以下では、5つの行が表示されるように `pageLength = ` を設定し、ユーザが下部のスクロールバーを使って水平方向にスクロールできるように `scrollX = ` を設定しています。引数 `class = 'white-space: nowrap'` は、各行が 1 行だけの表示となることを保証します（複数行ではありません）。その他の引数や値については、 [こちら](https://rstudio.github.io/DT/?_ga=2.2810736.1321860763.1619286819-369061888.1601594705)を参照するか、 `?datatable` と入力してみてください。

```{r, eval=F}
DT::datatable(linelist, 
              rownames = FALSE, 
              options = list(pageLength = 5, scrollX = TRUE), 
              class = 'white-space: nowrap' )
```

### プロット {.unnumbered}  

R スクリプトと同じようにダッシュボードペインにプロットを表示することができます。この例では、**incidence2** パッケージを使用して、2つの簡単なコマンドで年齢層別の「エピカーブ」を作成しています（[Epidemic curves]() のページを参照してください）。他にも、`ggplot()` を使用して、同じようにプロットを表示することができます。  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_plots_script.png"))
```

次がスクリプトの実行結果です：

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_plots_view.png"))
```


### 動的なプロット {.unnumbered}  

また、標準的な ggplot や他のプロットオブジェクトを **plotly** パッケージの `ggplotly()` に渡すこともできます ([Interactive plots]() ページを参照してください)。これはプロットを動的にし、ユーザーが「ズームイン」できるようにし、すべてのデータポイントの値（この例では、曲線の中の週あたりの症例数と年齢層）をカーソルを点の上にもってくるとで表示させます。  

```{r, eval=F}
age_outbreak <- incidence(linelist, date_onset, "week", groups = age_cat)
plot(age_outbreak, fill = age_cat, col_pal = muted, title = "") %>% 
  plotly::ggplotly()
```

これをダッシュボードで見るとこんな感じです（gif）。このインタラクティブ機能は、ダッシュボードを静的ファイルとして（サーバー上でオンラインでない）電子メールで送信した場合でも機能します。  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_ggplotly.gif"))
```

### HTML ウイジェット {.unnumbered}

[HTML widgets for R](http://www.htmlwidgets.org/)は、JavaScript のライブラリを利用してインタラクティブ性を高める R パッケージの特殊なクラスです。R Markdown 出力（flexdashboard など）や Shiny ダッシュボードに埋め込むことができます。  

これらのウィジェットの一般的に使われる例としては、以下のようなものがあります。  

* Plotly（このページと、本ハンドブックの[Interative plots]()のページで使用されています。）
* visNetwork（本ハンドブックの[Transmission Chains]]()のページで使用されています。）
* リーフレット（本ハンドブックの[GIS Basics]()のページで使用されています。
* dygraphs （時系列データをインタラクティブに表示するのに便利です）
* DT (`datatable()`) (フィルタ、ソートなどの機能を持つ動的なテーブルを表示するのに便利です。)  

以下は、visNetwork を使用した伝染病伝播チェーンをダッシュボードに追加するでもです。このスクリプトは、R Markdownスクリプトの「Column 2」セクションに追加された新しいコードのみを示しています。このコードは、このハンドブックの[Transmission chains]()のページで見ることができます。  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_chain_script.png"))
```

次がスクリプトの実行結果です：

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_chain.gif"))
```



## コード構成

すべてのコードを R Markdown の **flexdashboard**スクリプト内に記述することもできます。また、よりクリーンで簡潔なダッシュボード・スクリプトを作成するために、外部の R スクリプトでホストまたは作成されたコード/図を呼び出すことができます。これについては、[Reports with R Markdown]()ページでより詳細に説明されています。


## Shiny  

R パッケージの **shiny** を統合すると、ユーザーの入力に対してより反応性の高いダッシュボードを作成することができます。例えば、ユーザーに管轄地域や日付範囲を選択させ、その選択にパネルが反応するようにすることができます（例えば、表示されるデータにフィルターをかけるなど）。**flexdashboard** に **shiny** の反応性を組み込むには、**flexdashboard** の R Markdown スクリプトに少し変更を加えるだけでよいです。

フレックスダッシュボードを使わなくても、**shiny** を使ってアプリ/ダッシュボードを作成することができます。ハンドブックの[Dashboards with Shiny]()のページではこのアプローチについて、**shiny** の構文、アプリのファイル構造、共有/公開のオプション（無料のサーバーオプションを含む）についての概要を説明してあります。これらの構文と一般的なヒントは、**flexdashboard** のコンテキストにも当てはまります。  

**flexdashboard** に **shiny** を埋め込むことは、**flexdashboard** を根本的に変えることになります。電子メールで送信し、誰でも開いて見ることができるような HTML 出力はもう生成されません。その代わり、「アプリ」になります。スクリプトの上部にある「Knit」ボタンは「Run document」アイコンに置き換えられ、あなたのコンピュータにインタラクティブなダッシュボードのインスタンスをローカルに開くことになります。  

ダッシュボードを共有するには、以下のいずれかが必要となります  

* Rmd スクリプトをユーザーに送り、ユーザーが自分の PC で R でスクリプトを開き、アプリを実行する、または
* アプリ/ダッシュボードを、ユーザーがアクセス可能なサーバーにホストする

このように、**shiny** を統合することにはメリットもありますが、複雑さもあります。もし、電子メールで簡単に共有することを優先し、**shiny** のインタラクティブな機能を必要としないのであれば、上で示したように `ggplotly()` のよる限定的なインタラクティブな機能の利用を考慮してみてください。    

 
以下では、上記と同じ "outbreak_dashboard.Rmd" を使った簡単な例を紹介します。Shiny を **flexdashboard** に統合するための詳細なドキュメントは、[オンライン](https://rmarkdown.rstudio.com/flexdashboard/shiny.html)で入手可能です。 



### 設定 {.unnumbered}  

次のように、YAML パラメータ `runtime: shiny` を `output.XXX` と同じインデントレベルで追加することで、**flexdashboard** で **shiny** を有効にすることができます  

```md
---
title: "Outbreak dashboard (Shiny demo)"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```

ユーザーから情報を収集するための入力用ウィジェットを配置するための「サイドバー」を有効にすると便利です。上記で説明したように、カラムを作成し、`{.sidebar}` オプションを指示すると、左側にサイドバーが作成されます。このカラム内に **shiny** `input` コマンドを含むテキストと R チャンクを追加することができます。

アプリやダッシュボードがサーバーでホストされていて、複数のユーザーが同時に使用する可能性がある場合、最初のRコードのチャンクに`global`という名前を付けます。このチャンクにデータをインポート/ロードするためのコマンドを含めましょう。この特別な名前のチャンクは別に扱われ、その中でインポートされたデータは一度だけ（繰り返されることなく）インポートされ、すべてのユーザーで利用できます。これにより、アプリの起動速度が向上します。  

### 実際の例 {.unnumbered}  

ここでは、flexdashboard のスクリプト "outbreak_dashboard.Rmd" に **shiny** を追加しています。ユーザがドロップダウンメニューから病院を選択し、その病院からの症例のみを反映した流行曲線を、動的なプロットタイトルとともに表示する機能を追加します。これは、以下のようにして作成しました：  

* YAML に `runtime: shiny` を追加する。  
* セットアップチャンクの名前を `global` に変更する。
* サイドバーを次の内容を含んで作成する：
  * 個々の病院名を含むベクトルを作成するコード
  * 病院名を選択する `selectInput()` コマンド (**shiny** ドロップダウンメニュー)。選択内容は `hospital_choice` として保存され、後のコードで `input$hospital_choice` として参照することができます。 
* 流行曲線のコード（列 2）は `renderPlot({ })` の中に記載されており、以下を含みます。  
  * `hospital` カラムを `input$hospital_choice` の現在の値に制限するデータセットのフィルタ
  * input$hospital_choice` を組み込んだ動的なプロットタイトル
  
input$` 値を参照するコードは、(リアクティブであるために) `render({})` 関数の中になければならないことに注意してください。  

以下は、YAML、グローバルチャンク、サイドバーを含むスクリプトの最初の部分です：

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_script1.png"))
```
  
こちらは列 2、動的なエピカーブのプロットです。

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_script2.png"))
```

そして、こちらがダッシュボードです。  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_view.gif"))
```




### 他の例 {.unnumbered}  

**Shiny** のインタラクティブ機能と **leaflet** の地図を表示するためのウィジェットを使った Shiny-**flexdashboard** の健康関連の例については、オンラインブック[Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny](https://www.paulamoraga.com/book-geospatial/sec-dashboardswithshiny.html) のこの章をご覧ください。  




## 共有  
  
Shiny 要素を含まないダッシュボードは、HTML ファイル（.html）を出力し、（サイズが許せば）メールで送信することができます。これは、「ダッシュボード」レポートを送ることができ、ウェブサイトとしてホストするためのサーバーをセットアップする必要がないため、便利です。  

**shiny** を埋め込んだ場合、出力をメールで送ることはできませんが、スクリプト自体を R ユーザーに送ったり、上で説明したようにダッシュボードをサーバーでホストすることは可能です。  


## 参考資料

このページに掲載された優れたチュートリアルは、以下のとおりです。これらを見れば、おそらく 1 時間以内にあなた自身のダッシュボードを持つことができます。

https://bookdown.org/yihui/rmarkdown/dashboards.html

https://rmarkdown.rstudio.com/flexdashboard/

https://rmarkdown.rstudio.com/flexdashboard/using.html

https://rmarkdown.rstudio.com/flexdashboard/examples.html

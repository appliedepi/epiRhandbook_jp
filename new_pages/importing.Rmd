# インポートとエクスポート

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Import_Export_1500x500.png"))
```

このページでは、ファイルを検索、インポート、およびエクスポートする方法について説明します。

-   **rio** パッケージを使用して、さまざまな種類のファイルを柔軟に `import()` および `export()` します。\

-   **here** パッケージを使用して、R プロジェクトルートに関連するファイルを検索する - これにより1台のコンピューターに固有のファイルパスによる複雑化を防ぎます。\

-   以下のような具体的なインポートのシナリオがあります。

    -   特定の Excel シート\
    -   煩雑なヘッダーと行のスキップ\
    -   グーグルシートからのインポート\
    -   ウェブサイト上のデータから\
    -   API を用いて\
    -   [最新の]{.ul}ファイルの読み込み\

-   手動でのデータ入力\

-   RDS や RData などの R 特有のファイルタイプ\

-   ファイルやプロットのエクスポート/保存

<!-- ======================================================= -->

## **概要**

R に"データセット"をインポートする場合、一般的には、R 環境に新しい[データフレーム]{.ul}オブジェクトを作成し、フォルダディレクトリ内の特定のファイルパス/アドレスにあるインポートファイル（Excel、CSV、TSV、RDS など）として定義します。

他の統計プログラム（SAS、STATA、SPSS）で作成されたファイルを含め、多くの種類のファイルをインポート／エクスポートすることができます。また、関係データベースへの接続も可能です。

R には独自のデータフォーマットもあります。

-   RDS ファイル（.rds）は、データフレームなどの単一の R オブジェクトを保存します。これらは R 列クラスを維持するため、クリーンデータを保存するのに役立ちます。詳しくは[こちら](#import_rds)をご覧ください。\
-   RData ファイル（.Rdata）は、複数のオブジェクトや、R のワークスペース全体を保存するのに使用できます。詳しくは[こちら](#import_rdata)をご覧ください。

<!-- ======================================================= -->

## rio パッケージ

本書ではパッケージ **rio** を推奨しています。"rio" は"R I/O"（Input/Output）の略語です。

関数 `import()` および `export()` は、様々な種類のファイルを扱うことができます（例: .xlsx、.csv、.rds、.tsv）。これらの関数にファイルパス（ ".csv" のような拡張子を含む）を指定すると、**rio** は拡張子を読み取り、正しいツールを使用してファイルをインポートまたはエクスポートします。

**rio** を使う代わりに、他の多くのパッケージの関数を使うことができます。それぞれのパッケージは、ファイルの種類に特化しています。例えば、 `read.csv()` ( **base** R )、`read.xlsx()` ( **openxlsx** パッケージ)、`write_csv()` ( **readr** パッケージ)などです。これらの選択肢を覚えるのは大変ですが、**rio** の `import()` や `export()` を使うのは簡単です。

**rio** の関数 `import()` と `export()` は、ファイルの拡張子に基づいて、与えられたファイルに適切なパッケージと関数を使用します。**rio** がバックグラウンドで使用するパッケージや関数の表は、このページの最後をご覧ください。**rio** は、STATA、SAS、SPSSのファイルをはじめ、さまざまな種類のファイルのインポートにも使用することが可能です。

シェープファイルのインポート／エクスポートには、\[GIS basics\]　のページで紹介した他のパッケージが必要です。

## hereパッケージ {#here}

**here** パッケージとその関数 `here()` を用いて、ファイルの場所と保存場所をRに簡単に指示することができます。つまり、ファイルパスを作成します。

**here** パッケージは、 R プロジェクトと組み合わせて使用することで、 R プロジェクトのルートディレクトリ（トップレベルのフォルダ）に対する R プロジェクト内のファイルの場所を記述することができます。これは、 R プロジェクトを複数の人やコンピュータで共有したり、アクセスしたりする場合に便利です。これは、すべてのユーザーに共通の場所（ R プロジェクトのルート）からファイルパスを「開始」することで、異なるコンピュータ上のユニークなファイルパス（例*:* `"C:/Users/Laura/Documents..."` ）による煩雑さを避けることができます。

Rプロジェクトでの `here()` はこのように機能します。

-   **here** パッケージが R プロジェクト内で最初に読み込まれると、"ベンチマーク"または "アンカー"として、 R プロジェクトのルートフォルダに".here "という小さなファイルが配置されます。

-   *スクリプトでは、* R プロジェクトのサブフォルダ内のファイルを参照するために、関数 `here()` を使用し、[そのアンカーに基づいた]{.ul}ファイルパスを作成します。

-   ファイルパスを作成するには、以下のように、ルート以降のフォルダ名を引用符で囲み、カンマで区切り、最後にファイル名とファイル拡張子を記述します。

-   `here()` のファイルパスは、インポートとエクスポートの両方に使用できます。

例えば、以下では、関数 `import()` に、 `here()` で構築されたファイルパスが提供されています。

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

コマンド `here("data", "linelists", "ebola_linelist.xlsx")` は、実際には[ユーザーのコンピューターに固有の]{.ul}完全なファイルパスを示しています。

    "C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx"

`here()` を用いた R コマンドは、 R プロジェクトにアクセスするすべてのコンピューターで正常に実行できるのが魅力です。

[**ヒント*:*** ".here" ルートがどこに設定されているかわからない場合は、空の括弧を使用して関数 `here()` を実行してください。　]{style="color: darkgreen;"}

[このリンク](https://here.r-lib.org/)に **here** パッケージの詳細が記載されています。

<!-- ======================================================= -->

## ファイルパス

データをインポートまたはエクスポートする際、ファイルパスを指定する必要があります。 次の3つの方法のいずれかを実行できます。

1)  [推奨]{.ul}: **here** パッケージで"相対"ファイルパスを指定する\
2)  "完全な"/"絶対的な"ファイルパスを指定する\
3)  手動でのファイル選択

### "相対"ファイルパス {.unnumbered}

R では、"相対"ファイルパスは、R プロジェクトのルートを[基準にした]{.ul}ファイルパスで構成されます。これにより、さまざまなコンピューターで機能する、より単純なファイルパスが可能になります（例えば、R プロジェクトが共有ドライブ上にある場合や、電子メールで送信される場合）。[上記](#here)のように、相対ファイルパスは **here** パッケージを使用することで容易になります。

`here()` で作成された相対ファイルパスの例を以下に示します。目的のファイルパスは、サブフォルダー "data" を含む R プロジェクト内にあり、その中にサブフォルダー "linelists" があり、そこに対象の .xlsx ファイルがあると想定します。

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

### "絶対"ファイルパス {.unnumbered}

絶対または"完全な"ファイルパスを `import()` などの関数に指定できますが、ユーザーの特定のコンピューターに固有であるため"壊れやすい"ため、[推奨されません]{.ul}。

以下は絶対ファイルパスの例です。Laura のコンピューターには、フォルダー "analysis" 、サブフォルダー "data" があり、その中にサブフォルダー "linelists" があり、そこに対象の .xlsx ファイルがあります。 。

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx")
```

絶対ファイルパスについて注意すべき点がいくつかあります。

-   スクリプトを別のコンピューターで実行すると機能しないため、**絶対ファイルパスの使用は避けてください**。
-   上記の例のように、スラッシュ（`/`）を使用してください（注: これは Windows ファイルパスのデフォルトとは異なります）\
-   二重スラッシュで始まるファイルパス（"//..."など）は、R によって**認識されない**可能性が高く、エラーが発生します。文字で始まる「名前付き」または「文字付き」のドライブ（"J:"や"C:"など）にファイルを移動することを検討してください。この問題の詳細については、\[Directory interactions\] のページを参照ください。

絶対ファイルパスが適切なシナリオの1つは、すべてのユーザーに対して同じフルファイルパスを持つ共有ドライブからファイルをインポートする場合です。

[[**ヒント:**]{.ul}すべての\\を/にすばやく変換するには、目的のコードを選択し、Ctrl + f（ Windows の場合）を使用し、"選択中"のオプションボックスをオンにしてから、置換機能を使用して変換します。]{style="color: darkgreen;"}

<!-- ======================================================= -->

### 手動でのファイル選択 {.unnumbered}

次のいずれかの方法でデータを手動でインポートできます。

1)  RStudio の Environment Pane にて、"データセットのインポート"をクリックし、データの種類を選択します。
2)  ファイル / データセットのインポート /（データの種類を選択）をクリックします\
3)  手動選択をハードコーディングするには、ベースRコマンドの `file.choose()`（括弧を空のまま）を使用して、ユーザーがコンピューターからファイルを手動で選択できる**ポップアップウィンドウ**を表示します。以下に例を示します。

```{r import_choose, eval=F}
# ファイルの手動選択。このコマンドを実行すると、ポップアップウィンドウが表示される。
# 選択したファイルパスがimport（）コマンドに提供される。

my_data <- import(file.choose())
```

[[**ヒント**]{.ul}：**ポップアップウィンドウ**が RStudio ウィンドウの後ろに表示される場合があります。]{style="color: darkgreen;"}

## データのインポート

`import()` を使用してデータセットをインポートするのは非常に簡単です。 ファイルパス（ファイル名とファイル拡張子を含む）を引用符で囲んで指定するだけです。 `here()` を使用してファイルパスを作成する場合は、上記の手順に従ってください。 以下にいくつかの例を示します。

"作業ディレクトリ"または R プロジェクトのルートフォルダにあるcsvファイルをインポートします。

```{r, eval=F}
linelist <- import("linelist_cleaned.csv")
```

R プロジェクトの "data" および "linelists" サブフォルダー（`here()` を使用して作成されたファイルパス）にある Excel ワークブックの最初のシートをインポートします。

```{r, eval=F}
linelist <- import(here("data", "linelists", "linelist_cleaned.xlsx"))
```

絶対ファイルパスを使用してデータフレーム（.rds ファイル）をインポートする。

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds")
```

### 特定の Excel シート {.unnumbered}

特定の**シート**をインポートする場合は、シート名を `which =` 引数に含めます。 以下に例を示します。

```{r eval=F}
my_data <- import("my_excel_file.xlsx", which = "Sheetname")
```

`here()` を使用して `import()` への相対パスを提供する場合でも、`here()` 関数の閉じ括弧の後に `which =` 引数を追加することで、特定のシートを指定することができます。

```{r import_sheet_here, eval=F}
#デモ: 'here'パッケージで相対パスを使用し特定の Excel シートをインポートする
linelist_raw <- import(here("data", "linelist.xlsx"), which = "Sheet1")`  
```

データフレームを R から特定の Excel シートに[エクスポート]{.ul}し、 Excel ワークブックの残りの部分を変更しないようにするには、**openxlsx** など、この目的に対応した代替パッケージを使用してインポート、編集、およびエクスポートする必要があります。詳細については、\[ディレクトリの操作\] のページまたは[この github ページ](https://ycphs.github.io/openxlsx/)を参照してください。

Excel ワークブックが .xlsb（バイナリ形式の Excel ワークブック）の場合、rio を使用してインポートできない場合があります。 .xlsx として再保存するか、[こういった目的](https://cran.r-project.org/web/packages/readxlsb/vignettes/read-xlsb-workbook.html)のために作成された **readxlsb** のようなパッケージを使用することを検討してください。

<!-- ======================================================= -->

### 欠損値 {#import_missing .unnumbered}

データセット内のどういった値が欠損していると見なされるかをまず指定することが大切です。\[データの欠損\] のページで説明されているように、R では欠損値は `NA` と表示されますが、インポートするデータセットは、代わりに99、 "Missing"、または単に空の文字スペース ""を使用します。

`import()` に`na =` 引数を使用し、値を引用符で囲んで指定します（数値の場合でも同様に）。 `c()` as shown below.以下に示すように、 `c()` を使用して、ベクトル内に複数の値を含めることで複数の値を指定できます。

インポートされたデータセットの値 "99" は欠落していると見なされ、Rで `NA` に変換されます。

```{r, eval=F}
linelist <- import(here("data", "my_linelist.xlsx"), na = "99")
```

インポートされたデータセットの "Missing"、""（空のセル）、または " "（単一スペース）の値はすべて、Rで `NA` に変換されます。

```{r, eval=F}
linelist <- import(here("data", "my_linelist.csv"), na = c("Missing", "", " "))
```

<!-- ======================================================= -->

### 行をスキップする {.unnumbered}

.xlsx または .csv ファイル上で一部の行のインポートを避けたい場合は、 **rio** の `import()` 内で引数 `skip =` を使用します。 インポートをスキップする行数を指定します。

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # ヘッダー行をインポートしない
```

残念ながら、範囲[ではなく]{.ul}、整数値のみが`skip =` により実行されます（たとえば、"2:10" は機能しません）。上から連続していない特定の行のインポートをスキップするには、複数回インポートし、**dplyr** パッケージのから `bind_rows()` を使用することを検討してください。 以下に二行目のみをスキップする例を示します。

### 2番目のヘッダー行を管理する {.unnumbered}

以下に示すように、データが、データに[2番目]{.ul}の行がある場合があります（例えば "データディクショナリ" 行である場合など）。この場合、すべての列がクラス "文字" としてインポートされる可能性があるため、問題になる可能性があります。

```{r, echo=F}
# HIDDEN FROM READER
####################
# Create second header row of "data dictionary" and insert into row 2. Save as new dataframe.
linelist_2headers <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```

以下は、この種のデータセットの例です（最初の行はデータディクショナリです）。

```{r message=FALSE, echo=F}
# ラインリストデータをテーブルとして表示する
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### 2番目のヘッダー行の削除 {.unnumbered}

2番目のヘッダー行を削除するには、データを2回インポートする必要があります。

1)  正しい列名を保存するためにデータをインポートします。\
2)  最初の2行（ヘッダーと2行目）をスキップして、データを再度インポートします\
3)  縮小されたデータフレームに正しい名前を指定します

正しい列名を指定するために使用される正確な引数は、データファイルのタイプ（.csv、.tsv、.xlsx など ）によって異なります。これは、**rio** がファイルタイプごとに異なる関数を使用しているためです（上記の表を参照）。

**エクセルファイルの場合:** (`col_names =`)

```{r, eval=F}
# 1回目のインポートでは列名を保存
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # 本来の列名を保存

# 2回目のインポートでは、二行目をスキップし、列名を引数col_names = に割り当てる
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**CSVファイルの場合:** (`col.names =`)

```{r, eval=F}
# 1回目のインポートでは列名を保存
linelist_raw_names <- import("linelist_raw.csv") %>% names() # 本来の列名を保存

# csvファイルの引数は 'col.names='であることに注意
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**バックアップオプションとして** - 列名を別のコマンドとして変更する

```{r, eval=F}
# ベースの関数の colnames() 関数を使用してヘッダーを割り当てる/上書きする
colnames(linelist_raw) <- linelist_raw_names
```

#### データディクショナリの作成 {.unnumbered}

ボーナス！データディクショナリである2行目がある場合は、そこから適切なデータディクショナリを簡単に作成できます。このヒントは、この[投稿](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/)を基にしています。

```{r}
dict <- linelist_2headers %>%             # はじめに、一行目としてディクショナリを含むラインリスト
  head(1) %>%                             # 列名とディクショナリの一行目のみを保持する           
  pivot_longer(cols = everything(),       # すべての列を長い形式に変更
               names_to = "Column",       # 新しい列名を割り当てる
               values_to = "Description")
```

```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### 2つのヘッダー行を組み合わせる {.unnumbered}

元のデータセットにヘッダーが[二行]{.ul}がある場合（特に、データの2行目がセカンダリヘッダーである場合）、それらを "結合" するか、2番目のヘッダー行の値を最初のヘッダー行に追加することができます。

以下のコマンドは、データフレームの列名を、最初の（本来の）ヘッダーとそのすぐ下（最初の行）の値の組み合わせ（一緒に貼り付ける）として定義します。

```{r, eval=F}
names(my_data) <- paste(names(my_data), my_data[1, ], sep = "_")
```

<!-- ======================================================= -->

### グーグルシート {.unnumbered}

**googlesheet4** パッケージを使用し、スプレッドシートへのアクセスを認証することにより、オンラインの Google スプレッドシートからデータをインポートすることができます。

```{r, eval=F}
pacman::p_load("googlesheets4")
```

以下のように、デモの Google シートをインポートして保存します。このコマンドは、 Google アカウントの認証の確認を求める場合があります。インターネットブラウザのプロンプトとポップアップに従って、Tidyverse API パッケージに、 Google ドライブでスプレッドシートを編集、作成、および削除する権限を付与します。

以下のシートは "リンクを持っている人は誰でも閲覧可能" と設定されているので、インポートすることができます。

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

シートは、URLの短い部分であるシート ID のみを使用してインポートすることもできます。

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```

別のパッケージである**googledrive** は、 Google スプレッドシートの作成、編集、削除に役立つ機能を提供します。たとえば、このパッケージにある `gs4_create()` 関数と `sheet_write()` 関数を使用します。

その他のオンライン資料:\
[basic Google sheets importing tutorial](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)\
[more detailed tutorial](https://googlesheets4.tidyverse.org/articles/googlesheets4.html)\
[interaction between the googlesheets4 and tidyverse](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)

## 複数のファイルをインポート、エクスポート、分割、結合する

See the page on \[Iteration, loops, and lists\] for examples of how to import and combine multiple files, or multiple Excel workbook files. 複数のファイルまたは複数のExcelブックファイルをインポートして結合する方法の例については、 \[Iteration, loops, and lists\] のページを参照してください。このページでは、データフレームをパーツに分割し、それぞれを個別にエクスポートする方法、または Excel ワークブックの名前付きシートとしてエクスポートする方法の例もカバーしています。

<!-- ======================================================= -->

## Githubからのインポート {#import_github}

ファイルの種類により、GithubからRにデータを直接インポートするのは非常に簡単な場合もあれば、いくつかの手順が必要な場合もあります。 以下にいくつかのアプローチを示します。

### CSV ファイル {.unnumbered}

R コマンドを使用して、.csv ファイルを Github から R に容易に直接インポートすることができます。

1)  Github リポジトリに移動し、目的のファイルを見つけてクリックします\

2)  "Raw" ボタンをクリックします（次に示すように、 "Raw" の csv データが表示されます）

3)  URL（ウェブアドレス）をコピーする\

4)  `import()` Rコマンド内でURLを引用符で囲みます

```{r, out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_csv_raw.png"))
```

### XLSX ファイル {.unnumbered}

一部のファイル（.xlsx、.rds、.nwk、.shp など）の "Raw" データを表示できない場合があります

1)  Githubリポジトリに移動し、目的のファイルを見つけてクリックします\
2)  以下に示すように、"Download" ボタンをクリックします\
3)  ファイルをコンピューターに保存し、 R にインポートします

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_xlsx.png"))
```

### シェイプファイル {.unnumbered}

シェイプファイルには多くのサブコンポーネントファイルがあり、それぞれファイル拡張子が異なります。ファイル拡張子が ".shp"であるものもあれば、".dbf"、".prj" などのものもあります。Github からシェイプファイルをダウンロードするには、各サブコンポーネントファイルを個別にダウンロードし、コンピューターの[同じ]{.ul}フォルダーに保存する必要があります。Github で、各ファイルを個別にクリックし、"ダウンロード" ボタンをクリックしてダウンロードします。

コンピュータに保存したら、**sf** パッケージの `st_read()` を使用して、\[GIS basics\] ページに示されているようにシェープファイルをインポートできます。他の関連ファイルがコンピューターの同じフォルダー内にある場合に限り、".shp" ファイルのファイルパスと名前を指定するだけで済みます。

以下に、シェープファイル "sle_adm3" が多くのファイルで構成されていることを示します。各ファイルはGithubからダウンロードする必要があります。

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```

<!-- ======================================================= -->

## 手動でのデータ入力

### Entry by rows {.unnumbered}

Use the `tribble` function from the **tibble** package from the tidyverse ([online tibble reference](https://tibble.tidyverse.org/reference/tribble.html)).

Note how column headers start with a *tilde* (`~`). Also note that each column must contain only one class of data (character, numeric, etc.). You can use tabs, spacing, and new rows to make the data entry more intuitive and readable. Spaces do not matter between values, but each row is represented by a new line of code. For example:

```{r import_manual_row}
# create the dataset manually by row
manual_entry_rows <- tibble::tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
  "c",   3
  )
```

And now we display the new dataset:

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_rows)
```

### Entry by columns {.unnumbered}

Since a data frame consists of vectors (vertical columns), the **base** approach to manual dataframe creation in R expects you to define each column and then bind them together. This can be counter-intuitive in epidemiology, as we usually think about our data in rows (as above).

```{r import_manual_col}
# define each vector (vertical column) separately, each with its own name
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```

[***CAUTION:*** All vectors must be the same length (same number of values).]{style="color: orange;"}

The vectors can then be bound together using the function `data.frame()`:

```{r}
# combine the columns into a data frame, by referencing the vector names
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

And now we display the new dataset:

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_cols)
```

### クリップボードをインポート {.unnumbered}

他の場所からデータをコピーしてクリップボードに保存する場合は、次の2つの方法のいずれかを試すことができます。

From the **clipr** package, you can use `read_clip_tbl()` to import as a data frame, or just just `read_clip()` to import as a character vector. In both cases, leave the parentheses empty.

```{r, eval=F}
linelist <- clipr::read_clip_tbl()  # imports current clipboard as data frame
linelist <- clipr::read_clip()      # imports as character vector
```

また、 パッケージ **clipr** を使用してシステムのクリップボードに簡単にエクスポートすることもできます。 エクスポートについては、以下のセクションを参照してください。

Alternatively, you can use the the `read.table()` function from **base** R with `file = "clipboard")` to import as a data frame:

```{r, eval=F}
df_from_clipboard <- read.table(
  file = "clipboard",  # specify this as "clipboard"
  sep = "t",           # separator could be tab, or commas, etc.
  header=TRUE)         # if there is a header row
```

## 最新のファイルをインポート

多くの場合、データセットの更新を毎日受け取ることがあります。 この場合、最新のファイルをインポートするコードを記述します。 以下に、これにアプローチする2つの方法を示します。

-   Selecting the file based on the date in the file name\
-   Selecting the file based on file metadata (last modification)

### Dates in file name {.unnumbered}

This approach depends on three premises:

1)  You trust the dates in the file names\
2)  The dates are numeric and appear in *generally* the same format (e.g. year then month then day)\
3)  There are no other numbers in the file name

We will explain each step, and then show you them combined at the end.

First, use `dir()` from **base** R to extract just the file names for each file in the folder of interest. See the page on \[Directory interactions\] for more details about `dir()`. In this example, the folder of interest is the folder "linelists" within the folder "example" within "data" within the R project.

```{r}
linelist_filenames <- dir(here("data", "example", "linelists")) # get file names from folder
linelist_filenames                                              # print
```

Once you have this vector of names, you can extract the dates from them by applying `str_extract()` from **stringr** using this regular expression. It extracts any numbers in the file name (including any other characters in the middle such as dashes or slashes). You can read more about **stringr** in the \[Strings and characters\] page.

```{r}
linelist_dates_raw <- stringr::str_extract(linelist_filenames, "[0-9].*[0-9]") # extract numbers and any characters in between
linelist_dates_raw  # print
```

Assuming the dates are written in generally the same date format (e.g. Year then Month then Day) and the years are 4-digits, you can use **lubridate**'s flexible conversion functions (`ymd()`, `dmy()`, or `mdy()`) to convert them to dates. For these functions, the dashes, spaces, or slashes do not matter, only the order of the numbers. Read more in the \[Working with dates\] page.

```{r}
linelist_dates_clean <- lubridate::ymd(linelist_dates_raw)
linelist_dates_clean
```

The **base** R function `which.max()` can then be used to return the index position (e.g. 1st, 2nd, 3rd, ...) of the maximum date value. The latest file is correctly identified as the 6th file - "case_linelist_2020-10-08.xlsx".

```{r}
index_latest_file <- which.max(linelist_dates_clean)
index_latest_file
```

If we condense all these commands, the complete code could look like below. Note that the `.` in the last line is a placeholder for the piped object at that point in the pipe sequence. At that point the value is simply the number 6. This is placed in double brackets to extract the 6th element of the vector of file names produced by `dir()`.

```{r}
# load packages
pacman::p_load(
  tidyverse,         # data management
  stringr,           # work with strings/characters
  lubridate,         # work with dates
  rio,               # import / export
  here,              # relative file paths
  fs)                # directory interactions

# extract the file name of latest file
latest_file <- dir(here("data", "example", "linelists")) %>%  # file names from "linelists" sub-folder          
  str_extract("[0-9].*[0-9]") %>%                  # pull out dates (numbers)
  ymd() %>%                                        # convert numbers to dates (assuming year-month-day format)
  which.max() %>%                                  # get index of max date (latest file)
  dir(here("data", "example", "linelists"))[[.]]              # return the filename of latest linelist

latest_file  # print name of latest file
```

You can now use this name to finish the relative file path, with `here()`:

```{r, eval=F}
here("data", "example", "linelists", latest_file) 
```

And you can now import the latest file:

```{r, eval=F}
# import
import(here("data", "example", "linelists", latest_file)) # import 
```

### Use the file info {.unnumbered}

If your files do not have dates in their names (or you do not trust those dates), you can try to extract the last modification date from the file metadata. Use functions from the package **fs** to examine the metadata information for each file, which includes the last modification time and the file path.

Below, we provide the folder of interest to **fs**'s `dir_info()`. In this case, the folder of interest is in the R project in the folder "data", the sub-folder "example", and its sub-folder "linelists". The result is a data frame with one line per file and columns for `modification_time`, `path`, etc. You can see a visual example of this in the page on \[Directory interactions\].

We can sort this data frame of files by the column `modification_time`, and then keep only the top/latest row (file) with **base** R's `head()`. Then we can extract the file path of this latest file only with the **dplyr** function `pull()` on the column `path`. Finally we can pass this file path to `import()`. The imported file is saved as `latest_file`.

```{r, eval=F}
latest_file <- dir_info(here("data", "example", "linelists")) %>%  # collect file info on all files in directory
  arrange(desc(modification_time)) %>%      # sort by modification time
  head(1) %>%                               # keep only the top (latest) file
  pull(path) %>%                            # extract only the file path
  import()                                  # import the file

```

<!-- ======================================================= -->

## APIs {#import_api}

An "Automated Programming Interface" (API) can be used to directly request data from a website. APIs are a set of rules that allow one software application to interact with another. The client (you) sends a "request" and receives a "response" containing content. The R packages **httr** and **jsonlite** can facilitate this process.

Each API-enabled website will have its own documentation and specifics to become familiar with. Some sites are publicly available and can be accessed by anyone. Others, such as platforms with user IDs and credentials, require authentication to access their data.

Needless to say, it is necessary to have an internet connection to import data via API. We will briefly give examples of use of APIs to import data, and link you to further resources.

*Note: recall that data may be* posted\* on a website without an API, which may be easier to retrieve. For example a posted CSV file may be accessible simply by providing the site URL to `import()` as described in the section on [importing from Github](#import_github).\*

### HTTP request {.unnumbered}

The API exchange is most commonly done through an HTTP request. HTTP is Hypertext Transfer Protocol, and is the underlying format of a request/response between a client and a server. The exact input and output may vary depending on the type of API but the process is the same - a "Request" (often HTTP Request) from the user, often containing a query, followed by a "Response", containing status information about the request and possibly the requested content.

Here are a few components of an *HTTP request*:

-   The URL of the API endpoint\
-   The "Method" (or "Verb")\
-   Headers\
-   Body

The HTTP request "method" is the action your want to perform. The two most common HTTP methods are `GET` and `POST` but others could include `PUT`, `DELETE`, `PATCH`, etc. When importing data into R it is most likely that you will use `GET`.

After your request, your computer will receive a "response" in a format similar to what you sent, including URL, HTTP status (Status 200 is what you want!), file type, size, and the desired content. You will then need to parse this response and turn it into a workable data frame within your R environment.

### Packages {.unnumbered}

The **httr** package works well for handling HTTP requests in R. It requires little prior knowledge of Web APIs and can be used by people less familiar with software development terminology. In addition, if the HTTP response is .json, you can use **jsonlite** to parse the response.

```{r, eval=F}
# load packages
pacman::p_load(httr, jsonlite, tidyverse)
```

### Publicly-available data {.unnumbered}

Below is an example of an HTTP request, borrowed from a tutorial from [the Trafford Data Lab](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs). This site has several other resources to learn and API exercises.

Scenario: We want to import a list of fast food outlets in the city of Trafford, UK. The data can be accessed from the API of the Food Standards Agency, which provides food hygiene rating data for the United Kingdom.

Here are the parameters for our request:

-   HTTP verb: GET\
-   API endpoint URL: <http://api.ratings.food.gov.uk/Establishments>\
-   Selected parameters: name, address, longitude, latitude, businessTypeId, ratingKey, localAuthorityId\
-   Headers: "x-api-version", 2\
-   Data format(s): JSON, XML\
-   Documentation: <http://api.ratings.food.gov.uk/help>

The R code would be as follows:

```{r, eval=F, warning=F, message=F}
# prepare the request
path <- "http://api.ratings.food.gov.uk/Establishments"
request <- GET(url = path,
             query = list(
               localAuthorityId = 188,
               BusinessTypeId = 7844,
               pageNumber = 1,
               pageSize = 5000),
             add_headers("x-api-version" = "2"))

# check for any server error ("200" is good!)
request$status_code

# submit the request, parse the response, and convert to a data frame
response <- content(request, as = "text", encoding = "UTF-8") %>%
  fromJSON(flatten = TRUE) %>%
  pluck("establishments") %>%
  as_tibble()
```

You can now clean and use the `response` data frame, which contains one row per fast food facility.

### Authentication required {.unnumbered}

Some APIs require authentication - for you to prove who you are, so you can access restricted data. To import these data, you may need to first use a POST method to provide a username, password, or code. This will return an access token, that can be used for subsequent GET method requests to retrieve the desired data.

Below is an example of querying data from *Go.Data*, which is an outbreak investigation tool. *Go.Data* uses an API for all interactions between the web front-end and smartphone applications used for data collection. *Go.Data* is used throughout the world. Because outbreak data are sensitive and you should only be able to access data for *your* outbreak, authentication is required.

Below is some sample R code using **httr** and **jsonlite** for connecting to the *Go.Data* API to import data on contact follow-up from your outbreak.

```{r, eval=F}
# set credentials for authorization
url <- "https://godatasampleURL.int/"           # valid Go.Data instance url
username <- "username"                          # valid Go.Data username 
password <- "password"                          # valid Go,Data password 
outbreak_id <- "xxxxxx-xxxx-xxxx-xxxx-xxxxxxx"  # valid Go.Data outbreak ID

# get access token
url_request <- paste0(url,"api/oauth/token?access_token=123") # define base URL request

# prepare request
response <- POST(
  url = url_request,  
  body = list(
    username = username,    # use saved username/password from above to authorize                               
    password = password),                                       
    encode = "json")

# execute request and parse response
content <-
  content(response, as = "text") %>%
  fromJSON(flatten = TRUE) %>%          # flatten nested JSON
  glimpse()

# Save access token from response
access_token <- content$access_token    # save access token to allow subsequent API calls below

# import outbreak contacts
# Use the access token 
response_contacts <- GET(
  paste0(url,"api/outbreaks/",outbreak_id,"/contacts"),          # GET request
  add_headers(
    Authorization = paste("Bearer", access_token, sep = " ")))

json_contacts <- content(response_contacts, as = "text")         # convert to text JSON

contacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # flatten JSON to tibble
```

[***CAUTION:*** If you are importing large amounts of data from an API requiring authentication, it may time-out. To avoid this, retrieve access_token again before each API GET request and try using filters or limits in the query.]{style="color: orange;"}

[***TIP:*** The `fromJSON()` function in the **jsonlite** package does not fully un-nest the first time it's executed, so you will likely still have list items in your resulting tibble. You will need to further un-nest for certain variables; depending on how nested your .json is. To view more info on this, view the documentation for the **jsonlite** package, such as the [`flatten()` function](https://rdrr.io/cran/jsonlite/man/flatten.html).]{style="color: darkgreen;"}

For more details, View documentation on [LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html), the \[Contact Tracing\] page or API tips on [Go.Data Github repository](https://worldhealthorganization.github.io/godata/api-docs)

You can read more about the *httr* package [here](https://httr.r-lib.org/articles/quickstart.html)

This section was also informed by [this tutorial](https://www.dataquest.io/blog/r-api-tutorial/) and [this tutorial](https://medium.com/@traffordDataLab/querying-apis-in-r-39029b73d5f1).

<!-- ======================================================= -->

## エクスポート

### rio パッケージを使って {.unnumbered}

With **rio**, you can use the `export()` function in a very similar way to `import()`. First give the name of the R object you want to save (e.g. `linelist`) and then in quotes put the file path where you want to save the file, including the desired file name and file extension. For example:

This saves the data frame `linelist` as an Excel workbook to the working directory/R project root folder:

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # will save to working directory
```

You could save the same data frame as a csv file by changing the extension. For example, we also save it to a file path constructed with `here()`:

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.csv"))
```

### To clipboard {.unnumbered}

To export a data frame to your computer's "clipboard" (to then paste into another software like Excel, Google Spreadsheets, etc.) you can use `write_clip()` from the **clipr** package.

```{r, eval=F}
# export the linelist data frame to your system's clipboard
clipr::write_clip(linelist)
```

## RDS ファイル {#import_rds}

Along with .csv, .xlsx, etc, you can also export/save R data frames as .rds files. This is a file format specific to R, and is very useful if you know you will work with the exported data again in R.

The classes of columns are stored, so you don't have do to cleaning again when it is imported (with an Excel or even a CSV file this can be a headache!). It is also a smaller file, which is useful for export and import if your dataset is large.

For example, if you work in an Epidemiology team and need to send files to a GIS team for mapping, and they use R as well, just send them the .rds file! Then all the column classes are retained and they have less work to do.

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.rds"))
```

<!-- ======================================================= -->

## Rdata ファイルとリスト {#import_rdata}

`.Rdata` files can store multiple R objects - for example multiple data frames, model results, lists, etc. This can be very useful to consolidate or share a lot of your data for a given project.

In the below example, multiple R objects are stored within the exported file "my_objects.Rdata":

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

Note: if you are trying to *import* a list, use `import_list()` from **rio** to import it with the complete original structure and contents.

```{r, eval=F}
rio::import_list("my_list.Rdata")
```

<!-- ======================================================= -->

## プロットの保存

Instructions on how to save plots, such as those created by `ggplot()`, are discussed in depth in the \[ggplot basics\] page.

In brief, run `ggsave("my_plot_filepath_and_name.png")` after printing your plot. You can either provide a saved plot object to the `plot =` argument, or only specify the destination file path (with file extension) to save the most recently-displayed plot. You can also control the `width =`, `height =`, `units =`, and `dpi =`.

How to save a network graph, such as a transmission tree, is addressed in the page on \[Transmission chains\].

<!-- ======================================================= -->

## 資料

The [R Data Import/Export Manual](https://cran.r-project.org/doc/manuals/r-release/R-data.html)\
[R 4 Data Science chapter on data import](https://r4ds.had.co.nz/data-import.html#data-import)\
[ggsave() documentation](https://ggplot2.tidyverse.org/reference/ggsave.html)

Below is a table, taken from the **rio** online [vignette](https://cran.r-project.org/web/packages/rio/vignettes/rio.html). For each type of data it shows: the expected file extension, the package **rio** uses to import or export the data, and whether this functionality is included in the default installed version of **rio**.

| Format                              | Typical Extension       | Import Package       | Export Package | Installed by Default |
|-------------------------------------|-------------------------|----------------------|----------------|----------------------|
| Comma-separated data                | .csv                    | data.table `fread()` | data.table     | Yes                  |
| Pipe-separated data                 | .psv                    | data.table `fread()` | data.table     | Yes                  |
| Tab-separated data                  | .tsv                    | data.table `fread()` | data.table     | Yes                  |
| SAS                                 | .sas7bdat               | haven                | haven          | Yes                  |
| SPSS                                | .sav                    | haven                | haven          | Yes                  |
| Stata                               | .dta                    | haven                | haven          | Yes                  |
| SAS                                 | XPORT                   | .xpt                 | haven          | haven                |
| SPSS Portable                       | .por                    | haven                |                | Yes                  |
| Excel                               | .xls                    | readxl               |                | Yes                  |
| Excel                               | .xlsx                   | readxl               | openxlsx       | Yes                  |
| R syntax                            | .R                      | base                 | base           | Yes                  |
| Saved R objects                     | .RData, .rda            | base                 | base           | Yes                  |
| Serialized R objects                | .rds                    | base                 | base           | Yes                  |
| Epiinfo                             | .rec                    | foreign              |                | Yes                  |
| Minitab                             | .mtp                    | foreign              |                | Yes                  |
| Systat                              | .syd                    | foreign              |                | Yes                  |
| "XBASE"                             | database files          | .dbf                 | foreign        | foreign              |
| Weka Attribute-Relation File Format | .arff                   | foreign              | foreign        | Yes                  |
| Data Interchange Format             | .dif                    | utils                |                | Yes                  |
| Fortran data                        | no recognized extension | utils                |                | Yes                  |
| Fixed-width format data             | .fwf                    | utils                | utils          | Yes                  |
| gzip comma-separated data           | .csv.gz                 | utils                | utils          | Yes                  |
| CSVY (CSV + YAML metadata header)   | .csvy                   | csvy                 | csvy           | No                   |
| EViews                              | .wf1                    | hexView              |                | No                   |
| Feather R/Python interchange format | .feather                | feather              | feather        | No                   |
| Fast Storage                        | .fst                    | fst                  | fst            | No                   |
| JSON                                | .json                   | jsonlite             | jsonlite       | No                   |
| Matlab                              | .mat                    | rmatio               | rmatio         | No                   |
| OpenDocument Spreadsheet            | .ods                    | readODS              | readODS        | No                   |
| HTML Tables                         | .html                   | xml2                 | xml2           | No                   |
| Shallow XML documents               | .xml                    | xml2                 | xml2           | No                   |
| YAML                                | .yml                    | yaml                 | yaml           | No                   |
| Clipboard default is tsv            |                         | clipr                | clipr          | No                   |

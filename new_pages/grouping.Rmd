# データをグループ化する

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Grouping_1500x500.png"))
```

このページでは、記述的分析のためにデータをグループ化および集約する方法について説明します。 **tidyverse** ファミリーのパッケージが一般的で機能が使いやすいため、これを使用します。

データのグループ化は、データ管理と分析のコアとなる要素です。グループ化されたデータは、グループごとに統計的に要約され、グループごとにプロットできます。**dplyr** パッケージ（**tidyverse** の一部）の関数を使用すると、グループ化とその後の操作が非常に簡単になります。

このページでは、次のトピックについて説明します：

-   `group_by()` 関数によるデータのグループ化\
-   データのグループ化を解除する\
-   グループ化されたデータを `summarise()` で統計的に要約\
-   `count()` と `tally()` の違い\
-   `arrange()` をグループ化されたデータに使う\
-   `filter()` をグループ化されたデータに使う\
-   `mutate()` をグループ化されたデータに使う\
-   `select()` をグループ化されたデータに使う\
-   **base** R の `aggregate()` コマンドを、代替として使う

<!-- ======================================================= -->

## 準備

### パッケージの読み込み {.unnumbered}

以下のコードは分析に必要なパッケージの読み込みを示しています。このハンドブックでは、pacman パッケージの`p_load()`を強調しています。これは、必要があればパッケージをインストールし、使用するためにロードします。 インストールされたパッケージを **base** R から `library()`でロードすることもできます。 R パッケージの詳細については、 [R の基礎](#R%20basics) を参照してください。

```{r}
pacman::p_load(
  rio,       # データ読み込み
  here,      # to locate files ファイルを見つける
  tidyverse, # データをクリーニングして、処理して、プロットする (dplyr を含む)
  janitor)   # 列と行の合計を追加する
```

### データのインポート {.unnumbered}

エボラ出血熱の流行をシミュレートした症例のデータセットをインポートします。 もし同じようにやってみたければ、 [こちらをクリックしてクリーニングされたラインリストをダウンロードしてください](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds) （.rds ファイルです）。 このデータセットは **rio** パッケージの `import()` 関数を使用してインポートされています。データをインポートするさまざまな方法については、 [データのインポート・エクスポート](#Import%20and%20export) のページを参照してください。

```{r, echo=F}
linelist <- rio::import(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```

`linelist` の最初の50 行：

```{r message=FALSE, echo=F}
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## グループ化

**dplyr** の関数 `group_by()` は、指定された列の値によって、行をグループ化します。複数の列が指定されている場合は、列の値の組み合わせによって、行がグループ化されます。それぞれの一意の値（または値の組み合わせ）でグループが構成されます。その後のデータセットまたは計算への変更は、各グループ内で実行されます。

たとえば、次のコマンドは `linelist` を取得し、 `outcome`列の値で行をグループ化し、出力を新しいデータフレーム `ll_by_outcome` として保存します。グループ化する列は `group_by()` 関数の括弧内に書きます。

```{r}
ll_by_outcome <- linelist %>% 
  group_by(outcome)
```

`group_by()`を実行した後も**データセットに目に見える変化はないことに注意してください。** `mutate()`、 `summarise()`、 `arrange()` などの別のdplyr関数を「グループ化された」データフレームに適用するまで目に見える変化はありません。

ただし、データフレームを印刷することで、グループ化を「見る」ことができます。グループ化されたデータフレームを表示すると、それが [`tibble` クラス オブジェクト](https://tibble.tidyverse.org/) に変換されていることがわかります。このオブジェクトを表示すると、適用されているグループ化とグループの数がヘッダー行のすぐ上に表示されます。

```{r}
# 表示して、アクティブなグループを確認
ll_by_outcome
```

### 一意のグループ {.unnumbered}

**作成されたグループは、グループ化された列全体の値の一意の組み合わせを反映しています。**

グループと各グループの行数を確認するには、グループ化されたデータを `tally()` に渡します。カウントなしで一意のグループだけを表示するには `group_keys()` に渡します。

下の例ではグループ化列 `outcome` の結果には、「Death」、「Recover」、`NA` の 3 つの一意の値があります。 `nrow(linelist %>% filter(outcome == "Death"))` の deaths, `nrow(linelist %>% filter(outcome == "Recover"))` の recover, `nrow(linelist %>% filter(is.na(outcome)))` の outcome の記録なしがあります。

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally()
```

複数の列でグループ化することもできます。下の例では、データフレームが `outcome` と `gender` ごとにグループ化され、集計されています。 `outcome` と `gender` の一意の組み合わせが、いずれかの列の欠測値も含めて、独自のグループとして登録されていることに注意してください。

```{r}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally()
```

### 新しい列 {.unnumbered}

`group_by()` ステートメント内に新しいグループ化された列を作成することもできます。これは、 `group_by()` の前に `mutate()` を呼び出すのと同じです。簡単に集計するには、このスタイルが便利ですが、コードをわかりやすくするために、 `mutate()` ステップでこの列を作成してから、`group_by()` にパイプしてください。

```{r}
#  group_by() コマンド内で作成された2列にもとづくｃグループデータ
linelist %>% 
  group_by(
    age_class = ifelse(age >= 18, "adult", "child")) %>% 
  tally(sort = T)
```

### グループ化した列の追加／削除 {.unnumbered}

デフォルトでは、すでにグループ化されているデータに対して `group_by()` を実行すると、古いグループが削除され、新しいグループが適用されます。既存のグループに新しいグループを追加する場合は、引数に `.add = TRUE` を含めます。

```{r, eval=F}
# outcome毎にグループ化
by_outcome <- linelist %>% 
  group_by(outcome)

# さらに性別によるグループ化を追加
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```

\*\* すべてのグループをキープする \*\*

クラス因子の列でグループ化すると、現在データに存在しない因子のレベルが存在する可能性があります。この列でグループ化すると、デフォルトでは、存在しないレベルは削除され、グループとして含まれません。すべてのレベルが（データに存在しない場合でも）グループとして表示されるようにこれを変更するには、`group_by()` コマンドで `.drop = FALSE` を設定します。

## グループ化の解除 {.unnumbered}

グループ化されたデータは `ungroup()` でグループ化が解除されるまで、グループ化されたままになります。グループ化を解除するのを忘れると、計算が正しくなくなる可能性があります！\
以下は、すべてのグループを削除する例です。

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup()
```

`ungroup()` 内に列名を書くと、特定の列のみのグループ化を削除することもできます。

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # gender によるグループ化を削除し、outcome によるグループ化を残す
```

**注：** `count()` 関数はカウントした後にデータのグループ化を自動的に解除します。

## 要約する {#group_summarise}

`summarise()` を使用してサマリーテーブルを作成する方法の詳細については、 [記述統計表の作り方](#Descriptive%20tables) ページの **dplyr** セクションを参照してください。ここではグループ化されたデータに適用したときに、その動作がどのように変化するかについて簡単に説明します。

**dplyr** 関数 `summarise()` （または `summarize()`）はデータフレームを受け取り、あなたの定義したサマリー統計量を含む、新しい要約データフレームに変換します。グループ化されていないデータフレームでは、サマリー統計量はすべての行から計算されます。グループ化されたデータに `summarise()` を適用すると、各グループのサマリー統計量が生成されます。

`summarise()` の構文は、以下に示すように、新しい要約列の名前、等号、およびデータに適用する統計関数を指定します。例えば `min()`、 `max()`、 `median()`、 `sd()` などです。統計関数の中に、操作する列と関連する引数を書きます（例：na.rm = TRUE）。 `sum()` を使用して、論理条件を満たす行の数を数えることもできます（== を使用します）。

以下は、グループ化されたデータなしで適用された `summarise()` の例です。返される統計は、データセット全体から生成されます。

```{r}
# グループ化されていないラインリストの要約統計量
linelist %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males  = sum(gender == "m", na.rm=T))
```

対照的に、以下はグループ化されたデータに適用される同じ `summarise()` ステートメントです。統計は `outcome` グループごとに計算されます。グループ化された列が新しいデータフレームにどのように引き継がれるかに注意してください。

```{r}
# summary statistics on grouped linelist
linelist %>% 
  group_by(outcome) %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males    = sum(gender == "m", na.rm=T))
```

[**ヒント**： summary 関数は、英国と米国の両方のスペルで機能します。summarise`()`と summary`()`は同じ関数を呼び出します。]{style="color: darkgreen;"}

## カウントと集計

`count()` と `tally()` は同じような機能を提供しますが、異なるものです。 　`count()` と `tally()` の違いについて詳しくは、[こちら](https://dplyr.tidyverse.org/reference/tally.html) をご覧ください。

### `tally()` {.unnumbered}

`tally()` は `summarise(n = n())` の省略形であり、データをグループ化しません。グループ化された集計をするには、 `group_by()` コマンドの後に書かないといけません。 `sort = TRUE` を追加すると、最大のグループが一番上に表示されます。

```{r}
linelist %>% 
  tally()
```

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally(sort = TRUE)
```

### `count()` {.unnumbered}

対照的に `count()` は次のことを行います:

1)  指定された列に `group_by()` を適応\
2)  `summarise()` を適用し、グループごとの行数が表示される `n` 列を返します\
3)  `ungroup()` を適応

```{r}
linelist %>% 
  count(outcome)
```

`group_by()` と同様に `count()` コマンド内で新しい列を作成できます。

```{r}
linelist %>% 
  count(age_class = ifelse(age >= 18, "adult", "child"), sort = T)
```

`count()` は「ロールアップ」機能を使用して複数回呼び出すことができます。たとえば、性別ごとに存在する病院の数を要約するには、次のようにします。わかりやすくするために、最後の列の名前が（`name  =` を使って）デフォルトの「n」から変更されていることに注意してください。

```{r}
linelist %>% 
  # 一意なoutcome - genderグループをカウントします
  count(gender, hospital) %>% 
  # 性別ごとに行を集計し（3）、性別ごとに病院の数を数えます（6）
  count(gender, name = "hospitals per gender" ) 
```

### 総数を追加する {.unnumbered}

`count()` と `summarise()` とは対照的に、`add_count()` を使用すると、[データフレームの他のすべての列を保持しつつ]{.ul}、グループごとの行数を含む新しい列 `n` を[追加]{.ul}できます。

新しい列 `n` のグループのカウント番号が、グループの各行に出力されます。デモンストレーションのために、この列を追加してから、見やすくなるように列を並べ替えています。他の例については、[グループ化したデータをミューテートする](#group_filter_grp_size)のセクションを参照してください。

```{r}
linelist %>% 
  as_tibble() %>%                   # 出力が綺麗になるようにtibbleに変換
  add_count(hospital) %>%           # 病院ごとのカウント列n を追加
  select(hospital, n, everything()) # デモ目的に列を並び替え
```

### 合計を追加する {.unnumbered}

`tally()` か `count()` を使用した後、合計行または列の[合計]{.ul}を簡単に追加するには、[記述統計表の作り方](#Descriptive%20tables)ページの **janitor** セクションを参照してください。このパッケージは `adorn_totals()` や `adorn_percentages()` のような、合計を追加し、パーセンテージを表示するような関数を提供します。以下は簡単な例です。

```{r}
linelist %>%                                  # 症例のラインリスト
  tabyl(age_cat, gender) %>%                  # 2 つの列の数をクロス集計
  adorn_totals(where = "row") %>%             # 合計行を追加
  adorn_percentages(denominator = "col") %>%  # 列の分母を使用して比率に変換
  adorn_pct_formatting() %>%                  # 比率をパーセントに変換
  adorn_ns(position = "front") %>%            # 「数（パーセント）」と表示
  adorn_title(                                # タイトルを調整
    row_name = "Age Category",
    col_name = "Gender")
```

より複雑な合計行、たとえば合計以外の要約統計量を含むようなものを追加するには、 [記述統計表の作り方のページのこのセクション](#tbl_dplyr_totals) を参照。

## 日付によるグループ化

データを日付でグループ化する場合は、対象の日付単位（たとえば「日」、「疫学週」、「月」など）の列が必要です。（なければ作成する）。この列は [日付型データ](#Working%20with%20dates) ページの [疫学週セクション](#dates_epi_wks) セクションで説明されているように、**lubridate**の `floor_date()` を使用して作成することもできます。 この列があれば **dplyr**の `count()` を使用して、これらの一意の日付で行をグループ化し、カウントすることができます。

日付の処理に共通して、よく必要となる追加手順は、データに存在しない日付を追加して埋めることです。tidyr の `complete()` を使用すると、集計された日付系列の、範囲内のすべての日付単位に関して、日付が完全にそろいます。この手順がないと、ケースが報告されていない 一週間はデータに表示されないかもしれません！

`complete（）` 内で、日付列を最小から最大までの一連の日付 `seq.Date（）`として再定義します。したがって、日付が拡張されます。デフォルトでは、新しい「展開された」行のケースカウント値はNAになります。 `complete()` の引数 `fill =` と名前のリストを使用して、NA を 0 に設定できます。（counts列の名前が n であれば `fill = list(n = 0)` と書きます）\
詳細については `?complete` を、例については「日付の操作」 [疫学週セクション](#dates_epi_wks) ページを参照してください。

### ラインリストの症例を日でグループ化 {.unnumbered}

こちらは `complete()` を使用[せずに]{.ul}、症例を日数にグループ化する例です。最初の行で症例のない日をスキップすることに注意してください。

```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # date_onset の値がないものを削除します
  count(date_onset)              # 一意な日付ごとの行数をカウントします
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

下の例では `complete()` コマンドを追加して、範囲内のすべての日が確実に表示されるようにしました。

```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # date_onset 列の値がないものを削除します
  count(date_onset) %>%                   # 一意な日付ごとの行数をカウントします
  complete(                               # 症例がない日もすべて表示されるようにします
    date_onset = seq.Date(                # 列を日付シーケンスとして再定義します
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))  # 新しく行を追加して列 n に（デフォルトの NAの代わりに）0 を表示します
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### ラインリストの症例を週でグループ化 {.unnumbered}

同じ原則を週にも適応できます。最初に「症例が発症した週」という新しい列を `floor_date()` と `unit = "week"` を使って作成します。 次に前述のように `count()` を使って週毎の症例数を集計します。最後に `complete()` で症例がなくて週もすべて表示します。

```{r}
# 週毎の症例数のデータセットを作る
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # date_onset 列の値がないものを削除します
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # 発症した週という新しい列
  count(week) %>%                         # データを週毎にグループ化し、グループごとに行をカウントします。
  complete(                               # ケースがない場合でも、すべての日が表示されるようにします
    week = seq.Date(                      # 列を日付シーケンスとして再定義します
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # 新しく行を追加して列 n に（デフォルトの NA の代わりに）0 を表示します
```

データフレームの最初の 50 行は次のとおりです：

```{r message=FALSE, echo=F}
DT::datatable(weekly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### ラインリストの症例を月でグループ化 {.unnumbered}

症例を月毎に集約するには、**lubridate** パッケージの `floor_date()` をまた使用しますが、引数は `unit = "months"` です。 これにより、各日付はその月の 1 日に切り捨てられます。出力はDateクラスになります。 `complete()` ステップでも `by = "months"` を使用することに注意してください。

```{r}
# 月毎の症例数のデータセットを作る
monthly_counts <- linelist %>% 
  drop_na(date_onset) %>% 
  mutate(month = lubridate::floor_date(date_onset, unit = "months")) %>%  # 新しい列、発症月の 1 日
  count(month) %>%                          # 月ごとの症例数をカウント
  complete(
    month = seq.Date(
      min(month, na.rm=T),     # 症例が報告されていない月も含めてすべての月を組み込む
      max(month, na.rm=T),
      by="month"),
    fill = list(n = 0))
```

```{r message=FALSE, echo=F}
DT::datatable(monthly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### 日毎の集計数を週毎に {.unnumbered}

日毎の集計を週毎に集約するには、上記のように `floor_date()` を使用します。ただし、 `count()` の代わりに `group_by()` と `summarize()` を使用します。なぜなら週あたりの行数をカウントするだけでなく、日毎の症例数を `sum()` する必要があるからです。

#### 日毎の集計を月毎に　　\#ここは上とレベルを合わせたほうがよさそう {.unnumbered}

日毎の集計を月毎に集約するには、上記のように `floor_date()` と `unit = "month"` を使用します。ただし、 `count()` の代わりに `group_by()` と `summarize()` を使用します。なぜなら月毎の行数をカウントするだけでなく、日毎の症例数を `sum()` する必要があるからです。

## グループ化したデータの並び替え

**dplyr**動詞 `arrange()` を使用してデータフレーム内の行を並べ替えると、引数に `.by_group =TRUE` を設定しない限り、データがグループ化されたときに同じように動作します。この場合、行はまずグループ化された列、次に `arrange()` に指定した列の順番で並び替えられます。

## グループ化したデータのフィルター

### `filter()` {.unnumbered}

データフレームを評価する関数（ `max()`, `min()`, `mean()` など）と組み合わせて適用すると、これらの関数がグループに適用されます。たとえば、患者が年齢の中央値を超えている行をフィルタリングして保持する場合、これはグループごとに適用され、グループの年齢の中央値を超える行を保持するようにフィルターします。

### グループごとにスライスする {.unnumbered}

[データ内の位置に基づいて行をフィルタリングする](https://dplyr.tidyverse.org/reference/slice.html) **dplyr**関数 `slice()` も、グループごとに適用できます。良い「スライス」を取得するためには、各グループ内のデータを並べ替えることを忘れないでください。

たとえば、各病院から最新の 5 つの入院のみを取得するには、次のようにします：

1)  `hospital` 列ごとにラインリストをグループ化\
2)  [各病院グループ内で]{.ul} `date_hospitalisation` を最新から古いものへ並べ替え\
3)  スライスして各病院から最初の5行を取得

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            # 表示用
  select(case_id, hospital, date_hospitalisation)  # 表示用
```

`slice_head()` - 上からn行を選択\
`slice_tail()` - 最後からn行を選択\
`slice_sample()` - n行をランダムに選択\
`slice_min()` - `order_by =` 列で最も高い値を持つn行を選択, `with_ties = TRUE` を使用すると同点を保持\
`slice_max()` - `order_by =` 列で最も低い値を持つn行を選択, `with_ties = TRUE` を使用すると同点を保持

`slice()` のその他の例と詳細については [重複データの排除](#De-duplication) を参照。

### グループの大きさでのフィルター　 {#group_filter_grp_size .unnumbered}

関数 `add_count()` は元のデータに列nを追加して、その行のグループ内の行数を示します。

以下に示すように `add_count()` は `hospital` 列に適用されるため、新しい列nの値は、その行の病院グループの行数を反映します。列nの値がどのように繰り返されるかに注意してください。以下の例では、列名 `n` は、 `add_count()` 内の `name =` を使用して変更できます。デモンストレーションのため、 `select()` を使用して列を並べ替えています。

```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # 「この行と同じ病院に入院した行数」を追加します
  select(hospital, n, everything())
```

こうすれば「小さな」病院、たとえば 500 人未満の患者が入院した病院、に入院した症例列を簡単にフィルタリングできるようになります。

```{r, eval=F}
linelist %>% 
  add_count(hospital) %>% 
  filter(n < 500)
```

## グループ化したデータをミューテートする

すべての列と（要約ではない）行を保持したまま、グループ統計を含む新しい列を追加するには `summarise()` ではなく、 `group_by()` の後に `mutate()` を使用します。

これは、他のすべての列を残したままでグループ統計をするときに役立ちます。例えば、ある行をそのグループと比較する計算などです。

たとえば、以下のコードは、ある行の入院の遅れと、病院全体の遅れの中央値との差を計算します。 手順は次のとおりです：

1)  データを病院ごとにグループ化する\
2)  `days_onset_hosp`（入院までの遅れ）列を使って、病院全体の遅れの平均を含む新しい列を作成します\
3)  2 つの列の差を計算します

デモの目的で、表示する列のみを選択 `select()` しています。

```{r}
linelist %>% 
  # 病院ごとのグループデータ（ラインリストへの変更はまだありません）
  group_by(hospital) %>% 
  
  # 新しい列
  mutate(
    # 病院ごとの入院までの平均日数（小数点第1位を四捨五入）
    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    
    # 各行の遅延と病院の平均遅延の差（小数点以下第1位を四捨五入）
    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # 特定の行のみを選択 - 表示の目的で
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```

## グループ化されたデータの選択

動詞 `select()` はグループ化されたデータに対して機能しますが、グループ化された列は常に（ `select()` で指定されていない場合でも）含まれます。これらのグループ化された列が必要なければ、最初に `ungroup()` を使用してください。

<!-- ======================================================= -->

## リソース

詳細については、次に示すリソースが役立ちます。

グループ化されたデータに対しての要約機能を使うことができます。 [RStudio data transformation cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf) を参照。

dplyrのデータ大工(Data Carpentry)ページ\
**tidyverse** リファレンスページの [group_by()](https://dplyr.tidyverse.org/reference/group_by.html) と [grouping](https://dplyr.tidyverse.org/articles/grouping.html)

このサイトの [Data manipulation](https://itsalocke.com/files/DataManipulationinR.pdf)

[Summarize with conditions in dplyr](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)

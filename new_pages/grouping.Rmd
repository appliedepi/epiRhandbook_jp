# データをグループ化する

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Grouping_1500x500.png"))
```

このページでは、記述的分析のためにデータをグループ化および集約する方法について説明します。 **tidyverse** ファミリーのパッケージが一般的で機能が使いやすいため、これを使用します。

データのグループ化は、データ管理と分析のコアとなる要素です。グループ化されたデータは、グループごとに統計的に要約され、グループごとにプロットできます。**dplyr** パッケージ（**tidyverse** の一部）の関数を使用すると、グループ化とその後の操作が非常に簡単になります。

このページでは、次のトピックについて説明します：

-   `group_by()` 関数によるデータのグループ化\
-   データのグループ化を解除する\
-   グループ化されたデータを `summarise()` で統計的に要約\
-   `count()` と `tally()` の違い\
-   `arrange()` をグループ化されたデータに使う\
-   `filter()` をグループ化されたデータに使う\
-   `mutate()` をグループ化されたデータに使う\
-   `select()` をグループ化されたデータに使う\
-   **base** R の `aggregate()` コマンドを、代替として使う

<!-- ======================================================= -->

## 準備

### パッケージの読み込み {.unnumbered}

以下のコードは分析に必要なパッケージの読み込みを示しています。このハンドブックでは、pacman パッケージの`p_load()`を強調しています。これは、必要があればパッケージをインストールし、[さらに、]{.ul}使用するためにロードします。 インストールされたパッケージを**base** Rから`library()`でロードすることもできます。 Rパッケージの詳細については、 [R basics] を参照してください。

```{r}
pacman::p_load(
  rio,       # データ読み込み
  here,      # to locate files ファイルを見つける
  tidyverse, # データを綺麗にして、処理して、プロットする (dplyr を含む)
  janitor)   # 列と行の合計を追加する
```

### データのインポート {.unnumbered}

エボラ出血熱の流行をシミュレートした症例のデータセットをインポートします。 もし同じようにやってみたければ、 <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>こちらをクリックして「綺麗な」ラインリストをダウンロードしてくださいclick </a> (.rds ファイルです)。 このデータセットは **rio** パッケージの `import()` 関数を使用してインポートされています。データをインポートするさまざまな方法については、 [Import and export] のページを参照してください。

```{r, echo=F}
linelist <- rio::import(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```

`linelist` の最初の50行：

```{r message=FALSE, echo=F}
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## グループ化

**dplyr**の関数 `group_by()` は、指定された列の値によって、行をグループ化します。複数の列が指定されている場合は、列の値の組み合わせによって、行がグループ化されます。それぞれの一意の値（または値の組み合わせ）でグループが構成されます。その後のデータセットまたは計算への変更は、各グループ内で実行されます。

たとえば、次のコマンドは`linelist` を取得し、 `outcome`列の値で行をグループ化し、出力を新しいデータフレーム `ll_by_outcome` として保存します。グループ化する列は `group_by()` 関数の括弧内に書きます。

```{r}
ll_by_outcome <- linelist %>% 
  group_by(outcome)
```

`group_by()`を実行した後も**データセットに目に見える変化はないことに注意してください。** `mutate()`、 `summarise()`、 `arrange()` などの別のdplyr関数を「グループ化された」データフレームに適用するまで目に見える変化はありません。

ただし、データフレームを印刷することで、グループ化を「見る」ことができます。グループ化されたデータフレームを表示すると、それが [`tibble` class object](https://tibble.tidyverse.org/) に変換されていることがわかります。このオブジェクトを表示すると、適用されているグループ化とグループの数がヘッダー行のすぐ上に表示されます。

```{r}
# 表示して、アクティブなグループを確認
ll_by_outcome
```

### Unique groups {.unnumbered}

**The groups created reflect each unique combination of values across the grouping columns.　作成されたグループは、グループ化された列全体の値の一意の組み合わせを反映しています。**

グループと各グループの行数を確認するには、グループ化されたデータを `tally()` に渡します。カウントなしで一意のグループだけを表示するには `group_keys()` に渡します。

下の例ではグループ化列 `outcome` の結果には、「Death」、「Recover」、`NA` の3つの一意の値があります。 `nrow(linelist %>% filter(outcome == "Death"))` の deaths, `nrow(linelist %>% filter(outcome == "Recover"))` の recover, `nrow(linelist %>% filter(is.na(outcome)))` のoutcomeの記録なしがあります。

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally()
```

複数の列でグループ化することもできます。下の例では、データフレームが `outcome` と `gender` ごとにグループ化され、集計されています。 `outcome` と `gender` の一意の組み合わせが、いずれかの列の欠測値も含めて、独自のグループとして登録されていることに注意してください。

```{r}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally()
```

### 新しい列 {.unnumbered}

`group_by()` ステートメント内に新しいグループ化された列を作成することもできます。これは、 `group_by()` の前に `mutate()` を呼び出すのと同じです。簡単に集計するには、このスタイルが便利ですが、コードをわかりやすくするために、 `mutate()` ステップでこの列を作成してから、`group_by()`にパイプするようにしてください。

```{r}
#  group_by() コマンド内で作成された2列に基づくグループデータ
linelist %>% 
  group_by(
    age_class = ifelse(age >= 18, "adult", "child")) %>% 
  tally(sort = T)
```

### グループ化した列の追加/削除 {.unnumbered}

デフォルトでは、すでにグループ化されているデータに対して `group_by()` を実行すると、古いグループが削除され、新しいグループが適用されます。既存のグループに新しいグループを追加する場合は、引数に `.add = TRUE` を含めます。

```{r, eval=F}
# outcome毎にグループ化
by_outcome <- linelist %>% 
  group_by(outcome)

# さらに性別によるグループ化を追加
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```

\*\* すべてのグループをキープする \*\*

クラス因子の列でグループ化すると、現在データに存在しない因子のレベルが存在する可能性があります。この列でグループ化すると、デフォルトでは、存在しないレベルは削除され、グループとして含まれません。すべてのレベルが（データに存在しない場合でも）グループとして表示されるようにこれを変更するには、`group_by()`コマンドで `.drop = FALSE` を設定します。

## グループ化の解除 {.unnumbered}

グループ化されたデータは `ungroup()` でグループ化が解除されるまで、グループ化されたままになります。グループ化を解除するのを忘れると、計算が正しくなくなる可能性があります！\
以下は、すべてのグループを削除する例です。

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup()
```

`ungroup()` 内に列名を書くと、特定の列のみのグループ化を削除することもできます。

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # gender によるグループ化を削除し、outcome によるグループ化を残す
```

[***NOTE:*** The verb `count()` automatically ungroups the data after counting.]{style="color: black;"}

**注：** `count()` 関数はカウント後にデータのグループ化を自動的に解除します。

## Summarise {#group_summarise}

`summarise()` を使用してサマリーテーブルを作成する方法の詳細については、 [Descriptive tables] ページの **dplyr** セクションを参照してください。ここではグループ化されたデータに適用したときに、その動作がどのように変化するかについて簡単に説明します。

**dplyr** 関数`summarise()` (または `summarize()`) はデータフレームを受け取り、あなたの定義したサマリー統計量を含む、新しい要約データフレームに変換します。グループ化されていないデータフレームでは、サマリー統計量はすべての行から計算されます。グループ化されたデータに `summarise()` を適用すると、各グループのサマリー統計量が生成されます。

`summarise()` の構文は、以下に示すように、新しい要約列の名前、等号、およびデータに適用する統計関数を指定します。例えば `min()`、 `max()`、 `median()`、 `sd()` です。統計関数の中に、操作する列と関連する引数を書きます（例：na.rm = TRUE）。 `sum()` を使用して、論理条件を満たす行の数を数えることもできます（== を使用します）。You can use to count the number of rows that meet a logical criteria (with double equals `==`).

以下は、グループ化されたデータなしで適用された `summarise()` の例です。返される統計は、データセット全体から生成されます。

```{r}
# グループ化されていないラインリストの要約統計量
linelist %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males  = sum(gender == "m", na.rm=T))
```

対照的に、以下はグループ化されたデータに適用される同じ `summarise()` ステートメントです。統計は `outcome` グループごとに計算されます。グループ化された列が新しいデータフレームにどのように引き継がれるかに注意してください。

```{r}
# summary statistics on grouped linelist
linelist %>% 
  group_by(outcome) %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males    = sum(gender == "m", na.rm=T))
```

[**ヒント**： summary関数は、英国と米国の両方のスペルで機能します。summarise`()`とsummary`()`は同じ関数を呼び出します。]{style="color: darkgreen;"}

## Counts and tallies カウントと集計

`count()` と `tally()` は同じような機能を提供しますが、異なるものです。 　`count()` と `tally()` の違いについて詳しくは、[こちら](https://dplyr.tidyverse.org/reference/tally.html) をご覧ください。

### `tally()` {.unnumbered}

`tally()` は `summarise(n = n())` の省略形であり、データをグループ化しません。グループ化された集計をするには、 `group_by()` コマンドの後に書く必要があります。 `sort = TRUE` を追加すると、最大のグループを一番上に表示できます。

```{r}
linelist %>% 
  tally()
```

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally(sort = TRUE)
```

### `count()` {.unnumbered}

対照的に `count()` は次のことを行います:

1)  指定された列に `group_by()` を適応\
2)  `summarise()` を適用し、グループごとの行数が表示される `n` 列を返します\
3)   `ungroup()` を適応

```{r}
linelist %>% 
  count(outcome)
```

`group_by()` と同様に `count()` コマンド内に新しい列を作成できます。

```{r}
linelist %>% 
  count(age_class = ifelse(age >= 18, "adult", "child"), sort = T)
```

`count()` は、「ロールアップ」機能を使用して複数回呼び出すことができます。たとえば、性別ごとに存在する病院の数を要約するには、次のようにします。わかりやすくするために、最後の列の名前が（`name  =` を使って）デフォルトの「n」から変更されていることに注意してください。

```{r}
linelist %>% 
  # 一意なoutcome - genderグループをカウントします
  count(gender, hospital) %>% 
  # 性別ごとに行を集計し（3）、性別ごとに病院の数を数えます（6）
  count(gender, name = "hospitals per gender" ) 
```

### Add counts {.unnumbered}

In contrast to `count()` and `summarise()`, you can use `add_count()` to *add* a new column `n` with the counts of rows per group *while retaining all the other data frame columns*.

This means that a group's count number, in the new column `n`, will be printed in each row of the group. For demonstration purposes, we add this column and then re-arrange the columns for easier viewing. See the section below on [filter on group size](#group_filter_grp_size) for another example.

```{r}
linelist %>% 
  as_tibble() %>%                   # convert to tibble for nicer printing 
  add_count(hospital) %>%           # add column n with counts by hospital
  select(hospital, n, everything()) # re-arrange for demo purposes
```

### Add totals {.unnumbered}

To easily add total *sum* rows or columns after using `tally()` or `count()`, see the **janitor** section of the [Descriptive tables](#tbl_janitor) page. This package offers functions like `adorn_totals()` and `adorn_percentages()` to add totals and convert to show percentages. Below is a brief example:

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # cross-tabulate counts of two columns
  adorn_totals(where = "row") %>%             # add a total row
  adorn_percentages(denominator = "col") %>%  # convert to proportions with column denominator
  adorn_pct_formatting() %>%                  # convert proportions to percents
  adorn_ns(position = "front") %>%            # display as: "count (percent)"
  adorn_title(                                # adjust titles
    row_name = "Age Category",
    col_name = "Gender")
```

To add more complex totals rows that involve summary statistics other than *sums*, see [this section of the Descriptive Tables page](#tbl_dplyr_totals).

## Grouping by date

When grouping data by date, you must have (or create) a column for the date unit of interest - for example "day", "epiweek", "month", etc. You can make this column using `floor_date()` from **lubridate**, as explained in the [Epidemiological weeks section](#dates_epi_wks) of the [Working with dates] page. Once you have this column, you can use `count()` from **dplyr** to group the rows by those unique date values and achieve aggregate counts.

One additional step common for date situations, is to "fill-in" any dates in the sequence that are not present in the data. Use `complete()` from **tidyr** so that the aggregated date series is *complete* including *all possible date units* within the range. Without this step, a week with no cases reported might not appear in your data!

Within `complete()` you *re-define* your date column as a *sequence* of dates `seq.Date()` from the minimum to the maximum - thus the dates are expanded. By default, the case count values in any new "expanded" rows will be `NA`. You can set them to 0 using the `fill =` argument of `complete()`, which expects a named list (if your counts column is named `n`, provide `fill = list(n = 0)`. See `?complete` for details and the [Working with dates](#dates_epi_wks) page for an example.

### Linelist cases into days {.unnumbered}

Here is an example of grouping cases into days *without* using `complete()`. Note the first rows skip over dates with no cases.

```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # remove that were missing date_onset
  count(date_onset)              # count number of rows per unique date
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Below we add the `complete()` command to ensure every day in the range is represented.

```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # remove case missing date_onset
  count(date_onset) %>%                   # count number of rows per unique date
  complete(                               # ensure all days appear even if no cases
    date_onset = seq.Date(                # re-define date colume as daily sequence of dates
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) 
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist cases into weeks {.unnumbered}

The same principle can be applied for weeks. First create a new column that is the week of the case using `floor_date()` with `unit = "week"`. Then, use `count()` as above to achieve weekly case counts. Finish with `complete()` to ensure that all weeks are represented, even if they contain no cases.

```{r}
# Make dataset of weekly case counts
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # remove cases missing date_onset
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # new column of week of onset
  count(week) %>%                         # group data by week and count rows per group
  complete(                               # ensure all days appear even if no cases
    week = seq.Date(                      # re-define date colume as daily sequence of dates
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) 
```

Here are the first 50 rows of the resulting data frame:

```{r message=FALSE, echo=F}
DT::datatable(weekly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist cases into months {.unnumbered}

To aggregate cases into months, again use `floor_date()` from the **lubridate** package, but with the argument `unit = "months"`. This rounds each date down to the 1st of its month. The output will be class Date. Note that in the `complete()` step we also use `by = "months"`.

```{r}
# Make dataset of monthly case counts
monthly_counts <- linelist %>% 
  drop_na(date_onset) %>% 
  mutate(month = lubridate::floor_date(date_onset, unit = "months")) %>%  # new column, 1st of month of onset
  count(month) %>%                          # count cases by month
  complete(
    month = seq.Date(
      min(month, na.rm=T),     # include all months with no cases reported
      max(month, na.rm=T),
      by="month"),
    fill = list(n = 0))
```

```{r message=FALSE, echo=F}
DT::datatable(monthly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Daily counts into weeks {.unnumbered}

To aggregate daily counts into weekly counts, use `floor_date()` as above. However, use `group_by()` and `summarize()` instead of `count()` because you need to `sum()` daily case counts instead of just counting the number of rows per week.

#### Daily counts into months {.unnumbered}

To aggregate daily counts into months counts, use `floor_date()` with `unit = "month"` as above. However, use `group_by()` and `summarize()` instead of `count()` because you need to `sum()` daily case counts instead of just counting the number of rows per month.

## Arranging grouped data

Using the **dplyr** verb `arrange()` to order the rows in a data frame behaves the same when the data are grouped, *unless* you set the argument `.by_group =TRUE`. In this case the rows are ordered first by the grouping columns and then by any other columns you specify to `arrange()`.

## Filter on grouped data

### `filter()` {.unnumbered}

When applied in conjunction with functions that evaluate the data frame (like `max()`, `min()`, `mean()`), these functions will now be applied to the groups. For example, if you want to filter and keep rows where patients are above the median age, this will now apply per group - filtering to keep rows above the *group's* median age.

### Slice rows per group {.unnumbered}

The **dplyr** function `slice()`, which [filters rows based on their position](https://dplyr.tidyverse.org/reference/slice.html) in the data, can also be applied per group. Remember to account for sorting the data within each group to get the desired "slice".

For example, to retrieve only the latest 5 admissions from each hospital:

1)  Group the linelist by column `hospital`\
2)  Arrange the records from latest to earliest `date_hospitalisation` *within each hospital group*\
3)  Slice to retrieve the first 5 rows from each hospital

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            # for display
  select(case_id, hospital, date_hospitalisation)  # for display
```

`slice_head()` - selects n rows from the top\
`slice_tail()` - selects n rows from the end\
`slice_sample()` - randomly selects n rows\
`slice_min()` - selects n rows with highest values in `order_by =` column, use `with_ties = TRUE` to keep ties\
`slice_max()` - selects n rows with lowest values in `order_by =` column, use `with_ties = TRUE` to keep ties

See the [De-duplication] page for more examples and detail on `slice()`.

### Filter on group size {#group_filter_grp_size .unnumbered}

The function `add_count()` adds a column `n` to the original data giving the number of rows in that row's group.

Shown below, `add_count()` is applied to the column `hospital`, so the values in the new column `n` reflect the number of rows in that row's hospital group. Note how values in column `n` are repeated. In the example below, the column name `n` could be changed using `name =` within `add_count()`. For demonstration purposes we re-arrange the columns with `select()`.

```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # add "number of rows admitted to same hospital as this row" 
  select(hospital, n, everything())
```

It then becomes easy to filter for case rows who were hospitalized at a "small" hospital, say, a hospital that admitted fewer than 500 patients:

```{r, eval=F}
linelist %>% 
  add_count(hospital) %>% 
  filter(n < 500)
```

## Mutate on grouped data

To retain all columns and rows (not summarise) and *add a new column containing group statistics*, use `mutate()` after `group_by()` instead of `summarise()`.

This is useful if you want group statistics in the original dataset *with all other columns present* - e.g. for calculations that compare one row to its group.

For example, this code below calculates the difference between a row's delay-to-admission and the median delay for their hospital. The steps are:

1)  Group the data by hospital\
2)  Use the column `days_onset_hosp` (delay to hospitalisation) to create a new column containing the mean delay at the hospital of *that row*\
3)  Calculate the difference between the two columns

We `select()` only certain columns to display, for demonstration purposes.

```{r}
linelist %>% 
  # group data by hospital (no change to linelist yet)
  group_by(hospital) %>% 
  
  # new columns
  mutate(
    # mean days to admission per hospital (rounded to 1 decimal)
    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    
    # difference between row's delay and mean delay at their hospital (rounded to 1 decimal)
    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # select certain rows only - for demonstration/viewing purposes
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```

## Select on grouped data

The verb `select()` works on grouped data, but the grouping columns are always included (even if not mentioned in `select()`). If you do not want these grouping columns, use `ungroup()` first.

<!-- ======================================================= -->

## Resources

Here are some useful resources for more information:

You can perform any summary function on grouped data; see the [RStudio data transformation cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf)

The Data Carpentry page on [**dplyr**](https://datacarpentry.org/R-genomics/04-dplyr.html)\
The **tidyverse** reference pages on [group_by()](https://dplyr.tidyverse.org/reference/group_by.html) and [grouping](https://dplyr.tidyverse.org/articles/grouping.html)

This page on [Data manipulation](https://itsalocke.com/files/DataManipulationinR.pdf)

[Summarize with conditions in dplyr](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)

# 接触者の追跡 {#contact-tracing}

この章では、接触者追跡データの記述的分析を示し、接触者追跡データを分析する際に考慮する必要がある重要事項、ならびに対処法を説明します。

この章では、他の章で取り扱われている R を使用したデータ管理と可視化の基礎（データ前処理や整備、表の作り方や、時系列分析など）の多くを参照していますが、その中でも特に、実地疫学調査に関する意思決定に役立つ接触者追跡データに特有の例を取り上げます。例えば、接触者の追跡データを時系列や地理的エリアごとに視覚化する、また、接触者追跡業務の責任者に報告するための主要業績評価指標（Key Performance Indicator: KPI）の表を作成することが含まれます。

この章では、[Go.Data](https://www.who.int/tools/godata) プロジェクトからダウンロードできる接触者追跡データを例として使用します。この章で説明する事柄は、他のウェブサイトから取得した接触者追跡データにも通用します。その場合は、データの構造によって、必要な前処理が異なる可能性があります。

Go.Data の詳細については、Go.Data [公式ドキュメント](https://worldhealthorganization.github.io/godata/) や [公式ウェブサイト](https://community-godata.who.int/) をご覧ください。

## データ準備

### パッケージを読み込む {.unnumbered}

下に記載されたコードは、分析に必要なパッケージを読み込むためのコードです。このハンドブックでは、**pacman** パッケージの `p_load()` 主要なパッケージとして使用しています。`p_load()` 関数は、パッケージがインストールされているかチェックし、されている場合はパッケージを読み込み、インストールされていない場合はインストール後にパッケージを読み込みます。既にインストールされているパッケージは、**base** R の `library()` 関数を使用しても読み込むことができます。R のパッケージの詳細については、 [R の基礎] (\#basics) のページを参照してください。

```{r, message = F}
pacman::p_load(
  rio,          # データのインポート  
  here,         # 相対パス  
  janitor,      # データクリーニング
  lubridate,    # 日付型データ
  epikit,       # age_categories() 関数
  apyramid,     # 人口ピラミッド
  tidyverse,    # データの処理と可視化
  RColorBrewer, # 配色デザイン
  formattable,  # 見やすい表の作成
  kableExtra    #表のフォーマット整備
)
```

### データをインポートする {.unnumbered}

まず、接触者の連絡先と追跡状況のサンプルデータセットをインポートします。これらのデータは、Go.Data APIから取得され、ネストされておらず、「.rds」ファイルとして保存されています。

このハンドブックで使用するサンプルデータは、 [ハンドブックとデータのダウンロード] (\#data-used) のページからすべてダウンロードできます。

この章で使用するサンプルデータのみをダウンロードする場合は、以下のリンクをご利用ください。

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/cases_clean.rds?raw=true' class='download-button'> 感染者調査のサンプルデータ（.rds file） </a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/contacts_clean.rds?raw=true' class='download-button'> 接触者登録のサンプルデータ （.rds file） </a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/followups_clean.rds?raw=true' class='download-button'> 接触者追跡のサンプルデータ （.rds file） </a>

<!-- ```{r out.width = "100%", fig.align = "center", echo=F} -->

<!-- knitr::include_graphics(here::here("images", "godata_api_github.png")) -->

<!-- ``` -->

上のリンクからダウンロードしたファイルは、Go.Data API（APIの詳細については[こちら](#import_api)）が提供するデータであり、加工されていません。下のコードでは、データをインポートした後、この章で使いやすいようにデータの前処理を行います。Go.Data データの取得について、詳細が知りたい方は、[こちら](https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting) をご覧ください。

以下のコードでは、**rio** パッケージの `import()` 関数を使用し、サンプルのデータセットをインポートしています。データをインポートする方法は他にもたくさんあり、詳細を知りたい方は、 [インポートとエクスポート] (\#importing) のページを参照してください。下のコードでは、`here()` 関数を使用してファイルパスを指定していますが、コードを実行する際は、あなたのコンピュータ固有のファイルパスに変更してください。データをインポートした後、`select()` 関数を使用して特定の列のみを選択し、必要のないデータを除外します。

#### 感染者のデータ {.unnumbered}

このサンプルデータセットには、感染者の情報が含まれています。

```{r}
cases <- import(here("data", "godata", "cases_clean.rds")) %>% 
  select(case_id, firstName, lastName, gender, age, age_class,
         occupation, classification, was_contact, hospitalization_typeid)
```

以下は、このデータセットに含まれている `56` 人の感染者データの一覧です。

```{r, message=FALSE, echo=F}
DT::datatable(cases, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### 接触者のデータ {.unnumbered}

このサンプルデータセットには、接触者の連絡先と、多くの接触者追跡で必要となる情報が含まれています。下のコードを実行する際も、ファイルパスを指定してください。データをインポート後、以下の順で、データクリーニングを行います。

-   `age_class` 変数を因子（ファクタ）型に設定し、若い年齢が最初に来るように並び替える\
-   特定の列のみを選択し、選択した列のうち1つの列の名前を変更する\
-   `admin_2_name` 変数で空欄があった場合、「Djembe」を割り当て、後ほど作成するデータ可視化の例をわかりやすくする

```{r}
contacts <- import(here("data", "godata", "contacts_clean.rds")) %>% 
  mutate(age_class = forcats::fct_rev(age_class)) %>% 
  select(contact_id, contact_status, firstName, lastName, gender, age,
         age_class, occupation, date_of_reporting, date_of_data_entry,
         date_of_last_exposure = date_of_last_contact,
         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %>% 
  mutate(admin_2_name = replace_na(admin_2_name, "Djembe"))
```

以下は、このデータセットに含まれている `66` 人の接触者データの一覧です。

```{r, message=FALSE, echo=F}
DT::datatable(contacts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### 接触者追跡記録のデータ {.unnumbered}

このサンプルデータセットには、接触者調査（フォローアップ）の記録が含まれています。各接触者は、感染者との接触後 14 日間、毎日 1 回、調査担当者と連絡をとることになっています。

このサンプルデータセットには、接触者調査（フォローアップ）の記録が含まれています。各接触者は、感染者との接触後 14 日間、毎日 1 回、調査担当者と連絡をとることになっています。データをインポートした後、特定の列を選択し、文字列変数 `followup_status` をすべて小文字に変換します。

```{r}
followups <- rio::import(here::here("data", "godata", "followups_clean.rds")) %>% 
  select(contact_id, followup_status, followup_number,
         date_of_followup, admin_2_name, admin_1_name) %>% 
  mutate(followup_status = str_to_lower(followup_status))
```

以下では、接触者データの最初の `50` 人を表示しています。 （各行は 1 回の追跡調査の記録を表し、追跡調査の結果は `followup_status` 列に記録されています。）

```{r, message=FALSE, echo=F}
DT::datatable(head(followups, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### 感染者と接触者の関連データ {.unnumbered}

最後に、感染者と接触者の関連についてのデータをインポートし、特定の列のみを残します。

```{r}
relationships <- rio::import(here::here("data", "godata", "relationships_clean.rds")) %>% 
  select(source_visualid, source_gender, source_age, date_of_last_contact,
         date_of_data_entry, target_visualid, target_gender,
         target_age, exposure_type)
```

以下では、インポートしたデータの最初の `50` 人を表示しています。感染者と接触者の関連についてのあらゆる情報が含まれています。

```{r, message=FALSE, echo=F}
DT::datatable(head(relationships, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

## 記述統計

このハンドブックの他の章で説明されている分析手法やコードを使用し、感染者、接触者、そして感染者と接触者の関係について記述的な分析を行うことができます。以下に、いくつか例を示します。

### 人口統計 {.unnumbered}

[人口ピラミッドとリッカート尺度] (\#age-pyramid) の章で紹介したように、年齢や性別の分布を可視化することができます。（ここでは、**apyramid** パッケージを使用しています。）

#### 接触者の年齢と性別 {.unnumbered}

下の人口ピラミッドは、接触者の年齢分布を男女別に比較したものです。年齢が不明の接触者は、一番上の unknown に含まれていることに注意してください。年齢が不明の接触者を人口ピラミッドから除外することもできますが、その場合は、何人除外されたのかを、プロット下部に注意書きとして記すことをおすすめします。

```{r, warning=F, message=F}
apyramid::age_pyramid(
  data = contacts,                                   # 接触者サンプルデータを使用
  age_group = "age_class",                           # 年齢変数（因子型）を指定
  split_by = "gender") +                             # 性別による比較
  labs(
    fill = "Gender",                                 # 凡例のタイトル
    title = "Age/Sex Pyramid of COVID-19 contacts")+ # 図のタイトル
  theme_minimal()                                    # 背景テーマの設定
```

他にも、感染者と接触者両方の年齢が含まれているGo.Data の感染者と接触者の関連データ（`relationships` データセット）を使用すると、感染者と接触者の年齢層の違いを表す人口ピラミッドを作成することもできます。感染者と接触者の関連データ人口ピラミッドを作成する場合は、年齢変数をカテゴリ化し、数値型から因子（ファクタ型）にする必要があります（詳しくは、 [データクリーニングと主要関数] (\#cleaning) の章を参照ください）。また、**ggplot2** で図をプロットしやすくするために、データを縦型（long型）に変換する必要があります（詳細は、 [データの縦横変換] (\#pivoting) をご覧ください）。

```{r}
relation_age <- relationships %>% 
  select(source_age, target_age) %>% 
  transmute(                              # transmute() 関数は mutate() 関数と基本は同じだが、言及されていないすべての列を排除する機能を含む
    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),
    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),
    ) %>% 
  pivot_longer(cols = contains("class"), names_to = "category", values_to = "age_class")  # データを縦型（long 型）に変換する


relation_age
```

変換した感染者と接触者の関連データを、先ほどと同じように `age_pyramid()` をプロットしてみましょう。ただし、 `gender` 変数を使用するのではなく、 `category` 変数（感染者か接触者のどちらであるかを示す変数）を使用する必要があります。

```{r, warning=F, message=F}
apyramid::age_pyramid(
  data = relation_age,                               # 上のコードで作成したデータセットを使用
  age_group = "age_class",                           # 年齢変数（因子型）を指定
  split_by = "category") +                           # 感染者と接触者でグループ分け
  scale_fill_manual(
    values = c("orange", "purple"),                  # 各グループの色と名前を指定
    labels = c("Case", "Contact"))+
  labs(
    fill = "Legend",                                           # 凡例のタイトル
    title = "Age/Sex Pyramid of COVID-19 contacts and cases")+ # 図のタイトル
  theme_minimal()                                              # 背景テーマの設定
```

また、感染者の職業の内訳など、その他の特徴も可視化することができます。（ここでは、円グラフを作成します。）

```{r, warning=F, message=F}
# データを前処理し、職業ごとの感染者数を産出する
occ_plot_data <- cases %>% 
  mutate(occupation = forcats::fct_explicit_na(occupation),  # 欠損値を可視化する（NA を (Missing) と表示させる）
         occupation = forcats::fct_infreq(occupation)) %>%   # 職業変数を、職業ごとの感染者数で多い方から順に並び替える
  count(occupation)                                          # 職業ごとの感染者数を算出する
  
# 円グラフを作成する
ggplot(data = occ_plot_data, mapping = aes(x = "", y = n, fill = occupation))+
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  labs(
    fill = "Occupation",
    title = "Known occupations of COVID-19 cases")+
  theme_minimal() +                    
  theme(axis.line = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank())
```

### 感染者一人当たりの接触者数 {.unnumbered}

感染者一人当たりの接触者数は、接触者を見つけるための疫学調査の質や、住民がどの程度公衆衛生施策を順守しているかを評価するための重要な指標となります。

データ構造にもよりますが、すべての感染者と接触者を含むデータセットがあれば、感染者一人当たりの接触者数を算出し、評価を行うことができます。Go.Dataのデータセットでは、感染者（「sources」）と接触者（「targets」）の関連は、感染者と接触者の関連データ（`relationships` データセット）に含まれています。

感染者と接触者の関連データ（`relationships` データセット）では、各行が接触者の記録を示し、感染元となった感染者についての情報が記載されています。このデータセットには、複数の感染者と関連している接触者はありませんが、もし複数の感染者と関連している接触者がいる場合には、そのような接触者データを精査し、処理を行う必要があります。

まず、感染者一人当たりの接触者数を算出し、データフレーム（data frame）として保存します。

```{r}
contacts_per_case <- relationships %>% 
  count(source_visualid)

contacts_per_case
```

ここでは、 `geom_histogram()` を使用し、ヒストグラムを作成します。

```{r, warning=F, message=F}
ggplot(data = contacts_per_case)+        # 上のコードで作成したデータセットを使用
  geom_histogram(mapping = aes(x = n))+  # 感染者一人当たりの接触者数のヒストグラムを作成
  scale_y_continuous(expand = c(0,0))+   # y軸の0より下の余分なスペースを削除
  theme_light()+                         # 図の背景テーマの設定
  labs(
    title = "Number of contacts per case",
    y = "Cases",
    x = "Contacts per case"
  )
  

```

## 接触者調査（フォローアップ）

ほとんどの接触者追跡データには、隔離された人の毎日の症状チェックの結果を記録した接触者調査（フォローアップ）のデータが含まれています。接触者調査の記録を分析することで、今後の公衆衛生施策の策定に役立ち、追跡できなくなる危険性のある接触者や、疾患を発症する危険性のある接触者を特定することができます。

### データの前処理 {.unnumbered}

接触者調査に関する情報は、様々なフォーマットで記録されています。例えば、エクセルシートに各接触者を 1 行ごとに記録し、フォローアップの結果を1日ごとに列に記録した、横型（wide 型）データなどです。縦型（long 型）データと横型（wide 型）の詳細や、データの縦横変換の方法については、 [データの縦横変換] (\#pivoting) の章を参照してください。

Go.Data からダウンロードしたデータは、接触者追跡記録のデータ（`followups` データセット）に含まれており、フォローアップの記録が各行に記載されている縦型データとなっています。

以下では、接触者追跡記録データの最初の50行を表示しています。

```{r, message=FALSE, echo=FALSE}
# 接触者追跡記録のデータの最初の50行を表として表示する
DT::datatable(head(followups, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[[**注意点**]{.ul}***:*** 接触者調査（フォローアップ）に関するデータを扱う際は、重複した調査記録に注意してください。ある接触者に対し、同じ日に複数のフォローアップが誤って行われる可能性があります。例えば、調査員が接触者と連絡がとれなかった際にその記録を午前中に提出し、後に連絡できた際に 2 つ目の記録を提出することが起こりえます。重複した記録をどのように処理するかについては、調査の運用状況によりますが、重複記録を含んだデータを提示する際は、重複記録をどのように処理したかを明確に記載してください。]{style="color: orange;"}

接触者追跡記録のデータ（`followups` データセット）に、重複している記録がいくつあるのか、チェックしてみましょう。

```{r}
followups %>% 
  count(contact_id, date_of_followup) %>%   # contact_id 毎に、フォローアップ日の分布を算出
  filter(n > 1)                             # 1日2回以上フォローアップが行われた日を表示
```

In our example data, the only records that this applies to are ones missing an ID! We can remove those. But, for purposes of demonstration we will go show the steps for de-duplication so there is only one follow-up encoutner per person per day. See the page on [De-duplication] for more detail. We will assume that the most recent encounter record is the correct one. We also take the opportunity to clean the `followup_number` column (the "day" of follow-up which should range 1 - 14).

```{r, warning=F, message=F}
followups_clean <- followups %>%
  
  # De-duplicate
  group_by(contact_id, date_of_followup) %>%        # group rows per contact-day
  arrange(contact_id, desc(date_of_followup)) %>%   # arrange rows, per contact-day, by date of follow-up (most recent at top)
  slice_head() %>%                                  # keep only the first row per unique contact id  
  ungroup() %>% 
  
  # Other cleaning
  mutate(followup_number = replace(followup_number, followup_number > 14, NA)) %>% # clean erroneous data
  drop_na(contact_id)                               # remove rows with missing contact_id
```

For each follow-up encounter, we have a follow-up status (such as whether the encounter occurred and if so, did the contact have symptoms or not). To see all the values we can run a quick `tabyl()` (from **janitor**) or `table()` (from **base** R) (see [Descriptive tables]) by `followup_status` to see the frequency of each of the outcomes.

In this dataset, "seen_not_ok" means "seen with symptoms", and "seen_ok" means "seen without symptoms".

```{r}
followups_clean %>% 
  tabyl(followup_status)
```

### Plot over time {.unnumbered}

As the dates data are continuous, we will use a histogram to plot them with `date_of_followup` assigned to the x-axis. We can achieve a "stacked" histogram by specifying a `fill =` argument within `aes()`, which we assign to the column `followup_status`. Consequently, you can set the legend title using the `fill =` argument of `labs()`.

We can see that the contacts were identified in waves (presumably corresponding with epidemic waves of cases), and that follow-up completion did not seemingly improve over the course of the epidemic.

```{r, warning=F, message=F}
ggplot(data = followups_clean)+
  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +
  scale_fill_discrete(drop = FALSE)+   # show all factor levels (followup_status) in the legend, even those not used
  theme_classic() +
  labs(
    x = "",
    y = "Number of contacts",
    title = "Daily Contact Followup Status",
    fill = "Followup Status",
    subtitle = str_glue("Data as of {max(followups$date_of_followup, na.rm=T)}"))   # dynamic subtitle
  
```

[***CAUTION:*** If you are preparing many plots (e.g. for multiple jurisdictions) you will want the legends to appear identically even with varying levels of data completion or data composition. There may be plots for which not all follow-up statuses are present in the data, but you still want those categories to appear the legends. In ggplots (like above), you can specify the `drop = FALSE` argument of the `scale_fill_discrete()`. In tables, use `tabyl()` which shows counts for all factor levels, or if using `count()` from **dplyr** add the argument `.drop = FALSE` to include counts for all factor levels.]{style="color: orange;"}

### Daily individual tracking {.unnumbered}

If your outbreak is small enough, you may want to look at each contact individually and see their status over the course of their follow-up. Fortunately, this `followups` dataset already contains a column with the day "number" of follow-up (1-14). If this does not exist in your data, you could create it by calculating the difference between the encounter date and the date follow-up was intended to begin for the contact.

A convenient visualisation mechanism (if the number of cases is not too large) can be a heat plot, made with `geom_tile()`. See more details in the [heat plot] page.

```{r, warning=F, message=F}
ggplot(data = followups_clean)+
  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),
            color = "grey")+       # grey gridlines
  scale_fill_manual( values = c("yellow", "grey", "orange", "darkred", "darkgreen"))+
  theme_minimal()+
  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))
```

### Analyse by group {.unnumbered}

Perhaps these follow-up data are being viewed on a daily or weekly basis for operational decision-making. You may want more meaningful disaggregations by geographic area or by contact-tracing team. We can do this by adjusting the columns provided to `group_by()`.

```{r, warning=F, message=F}

plot_by_region <- followups_clean %>%                                        # begin with follow-up dataset
  count(admin_1_name, admin_2_name, followup_status) %>%   # get counts by unique region-status (creates column 'n' with counts)
  
  # begin ggplot()
  ggplot(                                         # begin ggplot
    mapping = aes(x = reorder(admin_2_name, n),     # reorder admin factor levels by the numeric values in column 'n'
                  y = n,                            # heights of bar from column 'n'
                  fill = followup_status,           # color stacked bars by their status
                  label = n))+                      # to pass to geom_label()              
  geom_col()+                                     # stacked bars, mapping inherited from above 
  geom_text(                                      # add text, mapping inherited from above
    size = 3,                                         
    position = position_stack(vjust = 0.5), 
    color = "white",           
    check_overlap = TRUE,
    fontface = "bold")+
  coord_flip()+
  labs(
    x = "",
    y = "Number of contacts",
    title = "Contact Followup Status, by Region",
    fill = "Followup Status",
    subtitle = str_glue("Data as of {max(followups_clean$date_of_followup, na.rm=T)}")) +
  theme_classic()+                                                                      # Simplify background
  facet_wrap(~admin_1_name, strip.position = "right", scales = "free_y", ncol = 1)      # introduce facets 

plot_by_region
```

<!-- If this was disaggregated by contact tracer, perhaps we would want to add a threshold line to display total # contacts that normally one person or area/team can handle, and how the current workload compares. We just do this by using `geom_hline()` function. -->

<!-- ```{r, warning=F, message=F} -->

<!-- plot_by_region +  -->

<!--      geom_hline(aes(yintercept=25), color="#C70039", linetype = "dashed") # fictitious threshold at 25 contacts -->

<!-- ``` -->

## KPI Tables

There are a number of different Key Performance Indicators (KPIs) that can be calculated and tracked at varying levels of disaggregations and across different time periods to monitor contact tracing performance. Once you have the calculations down and the basic table format; it is fairly easy to swap in and out different KPIs.

There are numerous sources of contact tracing KPIs, such as this one from [ResolveToSaveLives.org](https://contacttracingplaybook.resolvetosavelives.org/checklists/metrics). The majority of the work will be walking through your data structure and thinking through all of the inclusion/exclusion criteria. We show a few examples below; using Go.Data metadata structure:

+----------------------------------------------+------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| Category                                     | Indicator                                                                          | Go.Data Numerator                                                                                                                          | Go.Data Denominator   |
+==============================================+====================================================================================+============================================================================================================================================+=======================+
| Process Indicator - Speed of Contact Tracing | \% cases interviewed and isolated within 24h of case report                        | COUNT OF `case_id` WHERE (`date_of_reporting` - `date_of_data_entry`) \< 1 day AND (`isolation_startdate` - `date_of_data_entry`) \< 1 day | COUNT OF `case_id`    |
+----------------------------------------------+------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| Process Indicator - Speed of Contact Tracing | \% contacts notified and quarantined within 24h of elicitation                     | COUNT OF `contact_id` WHERE `followup_status` == "SEEN_NOT_OK" OR "SEEN_OK" AND `date_of_followup` - `date_of_reporting` \< 1 day          | COUNT OF `contact_id` |
+----------------------------------------------+------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| Process Indicator - Completeness of Testing  | \% new symptomatic cases tested and interviewed within 3 days of onset of symptoms | COUNT OF `case_id` WHERE (`date_of_reporting` - `date_of_onset`) \< =3 days                                                                | COUNT OF `case_id`    |
+----------------------------------------------+------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| Outcome Indicator - Overall                  | \% new cases among existing contact list                                           | COUNT OF `case_id` WHERE `was_contact` == "TRUE"                                                                                           | COUNT OF `case_id`    |
+----------------------------------------------+------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+

Below we will walk through a sample exercise of creating a nice table visual to show contact follow-up across admin areas. At the end, we will make it fit for presentation with the **formattable** package (but you could use other packages like **flextable** - see [Tables for presentation]).

How you create a table like this will depend on the structure of your contact tracing data. Use the [Descriptive tables] page to learn how to summarise data using **dplyr** functions.

We will create a table that will be dynamic and change as the data change. To make the results interesting, we will set a `report_date` to allow us to simulate running the table on a certain day (we pick 10th June 2020). The data are filtered to that date.

```{r, warning=F, message=F}
# Set "Report date" to simulate running the report with data "as of" this date
report_date <- as.Date("2020-06-10")

# Create follow-up data to reflect the report date.
table_data <- followups_clean %>% 
  filter(date_of_followup <= report_date)
```

Now, based on our data structure, we will do the following:

1)  Begin with the `followups` data and summarise it to contain, for each unique contact:\

-   The date of latest record (no matter the status of the encounter)\
-   The date of latest encounter where the contact was "seen"\
-   The encounter status at that final "seen" encounter (e.g. with symptoms, without symptoms)\

2)  Join these data to the contacts data, which contains other information such as the overall contact status, date of last exposure to a case, etc. Also we will calculate metrics of interest for each contact such as days since last exposure\
3)  We group the enhanced contact data by geographic region (`admin_2_name`) and calculate summary statistics per region\
4)  Finally, we format the table nicely for presentation

First we summarise the follow-up data to get the information of interest:

```{r, warning=F, message=F}
followup_info <- table_data %>% 
  group_by(contact_id) %>% 
  summarise(
    date_last_record   = max(date_of_followup, na.rm=T),
    date_last_seen     = max(date_of_followup[followup_status %in% c("seen_ok", "seen_not_ok")], na.rm=T),
    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %>% 
  ungroup()
```

Here is how these data look:

```{r, echo=F}
DT::datatable(followup_info, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Now we will add this information to the `contacts` dataset, and calculate some additional columns.

```{r}
contacts_info <- followup_info %>% 
  right_join(contacts, by = "contact_id") %>% 
  mutate(
    database_date       = max(date_last_record, na.rm=T),
    days_since_seen     = database_date - date_last_seen,
    days_since_exposure = database_date - date_of_last_exposure
    )
```

Here is how these data look. Note `contacts` column to the right, and new calculated column at the far right.

```{r, echo=F}
DT::datatable(contacts_info, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Next we summarise the contacts data by region, to achieve a concise data frame of summary statistic columns.

```{r}
contacts_table <- contacts_info %>% 
  
  group_by(`Admin 2` = admin_2_name) %>%
  
  summarise(
    `Registered contacts` = n(),
    `Active contacts`     = sum(contact_status == "UNDER_FOLLOW_UP", na.rm=T),
    `In first week`       = sum(days_since_exposure < 8, na.rm=T),
    `In second week`      = sum(days_since_exposure >= 8 & days_since_exposure < 15, na.rm=T),
    `Became case`         = sum(contact_status == "BECAME_CASE", na.rm=T),
    `Lost to follow up`   = sum(days_since_seen >= 3, na.rm=T),
    `Never seen`          = sum(is.na(date_last_seen)),
    `Followed up - signs` = sum(status_last_record == "Seen_not_ok" & date_last_record == database_date, na.rm=T),
    `Followed up - no signs` = sum(status_last_record == "Seen_ok" & date_last_record == database_date, na.rm=T),
    `Not Followed up`     = sum(
      (status_last_record == "NOT_ATTEMPTED" | status_last_record == "NOT_PERFORMED") &
        date_last_record == database_date, na.rm=T)) %>% 
    
  arrange(desc(`Registered contacts`))

```

```{r, echo=F}
DT::datatable(contacts_table, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

And now we apply styling from the **formattable** and **knitr** packages, including a footnote that shows the "as of" date.

```{r}
contacts_table %>%
  mutate(
    `Admin 2` = formatter("span", style = ~ formattable::style(
      color = ifelse(`Admin 2` == NA, "red", "grey"),
      font.weight = "bold",font.style = "italic"))(`Admin 2`),
    `Followed up - signs`= color_tile("white", "orange")(`Followed up - signs`),
    `Followed up - no signs`= color_tile("white", "#A0E2BD")(`Followed up - no signs`),
    `Became case`= color_tile("white", "grey")(`Became case`),
    `Lost to follow up`= color_tile("white", "grey")(`Lost to follow up`), 
    `Never seen`= color_tile("white", "red")(`Never seen`),
    `Active contacts` = color_tile("white", "#81A4CE")(`Active contacts`)
  ) %>%
  kable("html", escape = F, align =c("l","c","c","c","c","c","c","c","c","c","c")) %>%
  kable_styling("hover", full_width = FALSE) %>%
  add_header_above(c(" " = 3, 
                     "Of contacts currently under follow up" = 5,
                     "Status of last visit" = 3)) %>% 
  kableExtra::footnote(general = str_glue("Data are current to {format(report_date, '%b %d %Y')}"))

```

## Transmission Matrices

As discussed in the [Heat plots] page, you can create a matrix of "who infected whom" using `geom_tile()`.

When new contacts are created, Go.Data stores this relationship information in the `relationships` API endpoint; and we can see the first 50 rows of this dataset below. This means that we can create a heat plot with relatively few steps given each contact is already joined to it's source case.

```{r, warning=F, message=F, echo=F}
# display the first 50 rows of relationships data as a table
DT::datatable(head(relationships, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

As done above for the age pyramid comparing cases and contacts, we can select the few variables we need and create columns with categorical age groupings for both sources (cases) and targets (contacts).

```{r}
heatmap_ages <- relationships %>% 
  select(source_age, target_age) %>% 
  mutate(                              # transmute is like mutate() but removes all other columns
    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),
    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) 
```

As described previously, we create cross-tabulation;

```{r, warning=F, message=FALSE}

cross_tab <- table(
  source_cases = heatmap_ages$source_age_class,
  target_cases = heatmap_ages$target_age_class)

cross_tab
```

convert into long format with proportions;

```{r, warning=FALSE, message=FALSE}

long_prop <- data.frame(prop.table(cross_tab))

```

and create a heat-map for age.

```{r, warning=F, message=F}

ggplot(data = long_prop)+       # use long data, with proportions as Freq
  geom_tile(                    # visualize it in tiles
    aes(
      x = target_cases,         # x-axis is case age
      y = source_cases,     # y-axis is infector age
      fill = Freq))+            # color of the tile is the Freq column in the data
  scale_fill_gradient(          # adjust the fill color of the tiles
    low = "blue",
    high = "orange")+
  theme(axis.text.x = element_text(angle = 90))+
  labs(                         # labels
    x = "Target case age",
    y = "Source case age",
    title = "Who infected whom",
    subtitle = "Frequency matrix of transmission events",
    fill = "Proportion of all\ntranmsission events"     # legend title
  )

```

## Resources

<https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting>

<https://worldhealthorganization.github.io/godata/>

<https://community-godata.who.int/>

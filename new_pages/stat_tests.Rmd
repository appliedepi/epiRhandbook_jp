---
editor_options: 
  markdown: 
    wrap: 72
---

# Simple statistical tests　{\#stat-tests}

# **簡単な統計的検定**

このページでは、**base** R、**rstatix**、**gtsummary**
を使って、簡単な統計的検定を行う方法を紹介します。

-   T検定\
-   シャピローウィルク検定\
-   ウィルコクソンの順位和検定\
-   クラスカルーウォリス 検定\
-   カイ二乗検定\
-   数値変数間の相関

...他にも様々な検定を行うことができますが、ここでは一般的なものだけを紹介し、それ以外のものにはドキュメントへのリンクを張っています。

上記の各パッケージには、それぞれ利点と欠点があります：

-   **base** R 関数を使用して、R コンソールに統計的な出力を表示します。

-   データフレームで結果を表示する場合や、グループごとに検定を実行したい場合は、**rstatix**
    関数を使用します。

-   出版用の表を素早く表示したい場合は、**gtsummary** を使用します。

<!-- ======================================================= -->

## **準備**

### **パッケージを読み込む**

This code chunk shows the loading of packages required for the analyses.
In this handbook we emphasize `p_load()` from **pacman**, which installs
the package if necessary *and* loads it for use. You can also load
installed packages with `library()` from **base** R. See the page on [R
basics] for more information on R packages.

このコードの集合体は、分析に必要なパッケージの読み込みを示しています。このハンドブックでは
**pacman** の `p_load()`
をおすすめします。これは必要に応じてパッケージをインストールし、使用するためにパッケージを読み込みます。インストールされたパッケージは**base**
R の `library()`でも読み込みができます。R のパッケージに関する詳細は [R
basics] のページをご覧ください。

```{r}
pacman::p_load(
  rio,          # ファイルをインポートする
  here,         # ファイルの位置決める
  skimr,        # データの概要を把握する
  tidyverse,    # データ管理 + ggplot2 グラフィックス 
  gtsummary,    # 要約統計と検定をする
  rstatix,      # 統計を行う
  corrr,        # 数値変数の相関分析を行う
  janitor,      # 表に合計値とパーセンテージを加える
  flextable     # 表をHTMLに変換する
  )
```

### **データをインポートする**

私たちは、エボラ出血熱のシミュレーションで得られた症例のデータセットをインポートしています。このデータをみたい方は,
["clean"
linelistをダウンロードするためにここをクリック](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds)
( .rds fileとして読み込まれます). **rio** packageから、`import()`
ファンクションを使用してデータをインポートしてください。（.xlsx, .rds,
.csvなどの多くのタイプのファイルが使用可能です。詳しくは「インポート／エクスポート{\#importing}」のページをご覧ください。

```{r, echo=F}
# linelistをRにインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# linelistのインポート
linelist <- import("linelist_cleaned.rds")
```

linelistの最初の50行が下のように表示されます。

```{r, message=FALSE, echo=F}
# linelistのデータをテーブルとして表示する
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

## **base** R

**base**
Rの関数を使って、統計的検定を行うことができます。コマンドは比較的簡単で、結果はRのコンソールに表示されるので簡単に見ることができます。しかし、出力は、通常、リストですので、結果を次の操作で使用したい場合は、操作が難しくなります。

### T検定

「スチューデントのt検定」とも呼ばれる[ｔ検定](https://en.wikipedia.org/wiki/Student%27s_t-test)は、通常、2つのグループ間で何らかの数値変数の平均値に有意差があるかどうかを判定するために使用されます。ここでは、列が同じデータフレーム内にあるかどうかに応じて、この検定を行うための構文を示します。

**Syntax 1:** This is the syntax when your numeric and categorical
columns are in the same data frame. Provide the numeric column on the
left side of the equation and the categorical column on the right side.
Specify the dataset to `data =`. Optionally, set `paired = TRUE`, and
`conf.level =` (0.95 default), and `alternative =` (either "two.sided",
"less", or "greater"). Enter `?t.test` for more details.

構文1：これは、数値列とカテゴリー列が同じデータフレームにある場合の構文です。数式の左側に数値列を、右側にカテゴリー列を用意します。データセットを`data =`で指定します。オプションとして、`paired = TRUE`、`conf.level =`
(初期設定は0.95)、`alternative =` (two.sided, less,
greaterのいずれか)を設定します。詳細を知りたい場合は `?t.test`
と入力してください。

```{r}
##ｔ検定を使用してアウトカムグループごとに平均年齢を比較する
t.test(age_years ~ gender, data = linelist)
```

**Syntax 2:** You can compare two separate numeric vectors using this
alternative syntax. For example, if the two columns are in different
data sets.

構文2：この代替構文を使って、2つの別々の数値ベクトルを比較することができます。たとえば、2
つの列が異なるデータセットにある場合です。

```{r, eval=F}
t.test(df1$age_years, df2$age_years)
```

You can also use a t-test to determine whether a sample mean is
significantly different from some specific value. Here we conduct a
one-sample t-test with the known/hypothesized population mean as `mu =`:

また，t検定は，標本平均がある特定の値と有意に異なるかどうかを判定するためにも使用できます。ここでは、既知/仮説の母平均を`mu =`として、1標本のt検定を行います。

```{r, eval=F}
t.test(linelist$age_years, mu = 45)
```

### Shapiro-Wilk test {.unnumbered}

### **シャピローウィルク検定**

The [Shapiro-Wilk
test](https://en.wikipedia.org/wiki/Shapiro%E2%80%93Wilk_test) can be
used to determine whether a sample came from a normally-distributed
population (an assumption of many other tests and analysis, such as the
t-test). However, this can only be used on a sample between 3 and 5000
observations. For larger samples a [quantile-quantile
plot](https://ggplot2.tidyverse.org/reference/geom_qq.html) may be
helpful.

Shapiro-Wilk検定は，標本が正規分布の母集団から得られたものであるかどうかを判定するために使用できます（t-検定など，他の多くの検定や分析の仮定）．ただし，これは3件から5000件まで観察サンプルにしか使用できません。より大きなサンプルでは，Q-Qプロットを使用することが有用かもしれません。

```{r, eval=F}
shapiro.test(linelist$age_years)
```

### Wilcoxon rank sum test {.unnumbered}

### **ウィルコクソンの順位和検定**

The Wilcoxon rank sum test, also called the [Mann--Whitney U
test](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test), is
often used to help determine if two numeric samples are from the same
distribution when their populations are not normally distributed or have
unequal variance.

ウィルコクソンの順位和検定（マンーホイットニーのU検定とも呼ばれる）は、2つの数値サンプルの母集団が正規分布していない場合や、不均等な分散を持つ場合に、そのサンプルが同じ分布から来ているかどうかを判断するためによく使用されます。

```{r wilcox_base}

## ウィルコクソンの検定を使用してアウトカムグループごとに年齢の分布を比較する
wilcox.test(age_years ~ outcome, data = linelist)

```

### Kruskal-Wallis test {.unnumbered}

### クラスカルーウォリス 検定

The [Kruskal-Wallis
test](https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance)
is an extension of the Wilcoxon rank sum test that can be used to test
for differences in the distribution of more than two samples. When only
two samples are used it gives identical results to the Wilcoxon rank sum
test.

クラスカルーウォリス検定は、ウィルコクソンの順位和検定を拡張したもので、2つ以上のサンプルの分布の違いを検定するのに使用できます。2つのサンプルしか使用しない場合は、ウィルコクソンの順位和検定と同じ結果が得られます。

```{r }

## クラスカルーウォリス検定を使用して、アウトカムグループごとに年齢の分布を比較する
kruskal.test(age_years ~ outcome, linelist)

```

### Chi-squared test {.unnumbered}

### カイ二乗検定

[Pearson's Chi-squared
test](https://en.wikipedia.org/wiki/Chi-squared_test) is used in testing
for significant differences between categorical croups.

ピアソンのカイ二乗検定は、カテゴリー変数のグループ間の有意差を検定する際に使用されます。

```{r}

## 各グループにおける割合をカイ二乗検定で比較する
chisq.test(linelist$gender, linelist$outcome)

```

## **rstatix** package

### rstatix パッケージ

The **rstatix** package offers the ability to run statistical tests and
retrieve results in a "pipe-friendly" framework. The results are
automatically in a data frame so that you can perform subsequent
operations on the results. It is also easy to group the data being
passed into the functions, so that the statistics are run for each
group.

**rstatix**パッケージは、「パイプ・フレンドリー」なフレームワークで統計的検定を実行し、結果を取得する機能を提供します。結果は自動的にデータフレームに格納されるので、結果に対して後続の操作を行うことができます。また、関数に渡されるデータをグループ化して、グループごとに統計を実行することも容易です。

### Summary statistics {.unnumbered}

### 要約統計

The function `get_summary_stats()` is a quick way to return summary
statistics. Simply pipe your dataset to this function and provide the
columns to analyse. If no columns are specified, the statistics are
calculated for all columns.

`get_summary_stats()`関数は、要約統計を早く表示する方法です。データセットをこの関数に繋げて、分析したい列を指定するだけです。列が指定されていない場合は、すべての列の統計量が計算されます。

By default, a full range of summary statistics are returned: n, max,
min, median, 25%ile, 75%ile, IQR, median absolute deviation (mad), mean,
standard deviation, standard error, and a confidence interval of the
mean.

デフォルトでは、数、最大値、最小値、平均、25パーセンタイル値、75パーセンタイル値、四分位範囲、中央絶対偏差
(mad)、平均、標準偏差、標準誤差、平均値の信頼区間など、あらゆる種類の要約統計量が表示されます。

```{r}
linelist %>%
  rstatix::get_summary_stats(age, temp)
```

You can specify a subset of summary statistics to return by providing
one of the following values to `type =`: "full", "common", "robust",
"five_number", "mean_sd", "mean_se", "mean_ci", "median_iqr",
"median_mad", "quantile", "mean", "median", "min", "max"」」

`type =`
に以下の値のいずれかを指定することで、返す要約統計量のサブセットを指定することができます。「full"、"common"、"robust"、"five_number"、"mean_sd"、"mean_se"、"mean_ci"、"median_iqr"、"median_mad"、"quantile"、"mean"、"median"、"min"、"max"。

It can be used with grouped data as well, such that a row is returned
for each grouping-variable:

グループ化されたデータにも使用でき、グループ化された変数ごとに行として返される。

```{r}
linelist %>%
  group_by(hospital) %>%
  rstatix::get_summary_stats(age, temp, type = "common")
```

You can also use **rstatix** to conduct statistical tests:

また、**rstatix**を使って統計的な検定を行うこともできます。

### T-test {.unnumbered}

### T検定

Use a formula syntax to specify the numeric and categorical columns:

数式の構文を使って、数値とカテゴリーの列を指定します。

```{r}
linelist %>% 
  t_test(age_years ~ gender)
```

Or use `~ 1` and specify `mu =` for a one-sample T-test. This can also
be done by group.

また、`~ 1` を使用し、 `mu =` を指定すると、1標本の T
検定を行うことができます。これは、グループごとに行うこともできます。

```{r}
linelist %>% 
  t_test(age_years ~ 1, mu = 30)
```

If applicable, the statistical tests can be done by group, as shown
below:

該当する場合は、以下のようにグループごとに統計的検定を行うことができます。

```{r}
linelist %>% 
  group_by(gender) %>% 
  t_test(age_years ~ 1, mu = 18)
```

### Shapiro-Wilk test　 {.unnumbered}

### **シャピローウィルク検定** {.unnumbered}

As stated above, sample size must be between 3 and 5000.

前述の通り、サンプルサイズは3～5000の間でなければなりません。

```{r}
linelist %>% 
  head(500) %>%      # 例として、linelistでの最初の500行の症例
  shapiro_test(age_years)
```

### Wilcoxon rank sum test {.unnumbered}

### ウィルコクソンの順位和検定

マンーホイットニーのU検定としても知られている

```{r}
linelist %>% 
  wilcox_test(age_years ~ gender)
```

### Kruskal-Wallis test {.unnumbered}

### クラスカルウォリス検定

```{r}
linelist %>% 
  kruskal_test(age_years ~ outcome)
```

### Chi-squared test {.unnumbered}

### カイ二乗検定

The chi-square test function accepts a table, so first we create a
cross-tabulation. There are many ways to create a cross-tabulation (see
[Descriptive tables]) but here we use `tabyl()` from **janitor** and
remove the left-most column of value labels before passing to
`chisq_test()`.

カイ二乗検定の関数は表をもとに実施しますので、まずクロス集計を作成します。クロス集計を作成する方法はたくさんありますが（[記述表]{\#
tables-descriptive}を参照）、ここでは**janitor**の`tabyl()`を使用し、`chisq_test()`に渡す前に値ラベルの左端の列を削除します。

```{r}
linelist %>% 
  tabyl(gender, outcome) %>% 
  select(-1) %>% 
  chisq_test()

```

Many many more functions and statistical tests can be run with
**rstatix** functions. See the documentation for **rstatix** [online
here](https://github.com/kassambara/rstatix) or by entering ?rstatix.

**rstatix**関数では、さらに多くの関数や統計検定を実行できます。rstatixのドキュメントをオンラインで見るには、[ここをクリック](https://github.com/kassambara/rstatix)するか、?rstatixを入力してください。

## `gtsummary` package {#stats_gt}

## `gtsummary` パッケージ

Use **gtsummary** if you are looking to add the results of a statistical
test to a pretty table that was created with this package (as described
in the **gtsummary** section of the [Descriptive tables](#tbl_gt) page).

本パッケージで作成したきれいな表に統計的な検定の結果を追加したい場合は、**gtsummary**を使用してください（「記述表{\#
tables-descriptive}」ページの**gtsummary**セクションで説明しています）。

Performing statistical tests of comparison with `tbl_summary` is done by
adding the `add_p` function to a table and specifying which test to use.
It is possible to get p-values corrected for multiple testing by using
the `add_q` function. Run `?tbl_summary` for details.

`tbl_summary`で比較の統計的検定を行うには、テーブルに`add_p`関数を追加し、使用する検定を指定します。`add_q`関数を使用して、多重検定で補正されたp値を得ることができる。詳細は`?tbl_summary`を実行してください。

### Chi-squared test {.unnumbered}

### カイ二乗検定

Compare the proportions of a categorical variable in two groups. The
default statistical test for `add_p()` when applied to a categorical
variable is to perform a chi-squared test of independence with
continuity correction, but if any expected call count is below 5 then a
Fisher's exact test is used.

2つのグループにおけるカテゴリー変数の割合を比較します。カテゴリー変数に適用された場合の`add_p()`へのデフォルトの統計的検定は、連続性補正を用いた独立性のカイ二乗検定ですが、予想される算出数が5以下の場合は、フィッシャーの正確検定が用いられます。

```{r chi_gt}
linelist %>% 
  select(gender, outcome) %>%    # 興味のある変数を投入
  tbl_summary(by = outcome) %>%  # 要約表の作成とグループ化をする変数を指定
  add_p()                        # 実行する検定の指定
```

### T-tests {.unnumbered}

### T検定

Compare the difference in means for a continuous variable in two groups.
For example, compare the mean age by patient outcome.

2つのグループにおける連続変数の平均値の差を比較します。例えば、患者の転帰ごとに平均年齢を比較する。

```{r ttest_gt}

linelist %>% 
  select(age_years, outcome) %>%             # 興味のある変数を投入
  tbl_summary(                               # 要約表を作成
    statistic = age_years ~ "{mean} ({sd})", # 表示したい要約統計量を指定
    by = outcome) %>%                        # グループ化する変数を指定
  add_p(age_years ~ "t.test")                # 実行する検定を指定


```

### Wilcoxon rank sum test {.unnumbered}

ウィルコクソンの順位和検定

Compare the distribution of a continuous variable in two groups. The
default is to use the Wilcoxon rank sum test and the median (IQR) when
comparing two groups. However for non-normally distributed data or
comparing multiple groups, the Kruskal-wallis test is more appropriate.

2つのグループにおける連続変数の分布を比較します。デフォルトでは、2つのグループを比較する際にウィルコクソンの順位和検定と中央値（IQR）を使用します。しかし、非正規分布のデータや複数のグループを比較する場合は、クラスカルーウォリス検定を使用することがより適切です。

```{r wilcox_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # 興味ある変数を投入
  tbl_summary(                                         # 要約表を作成
    statistic = age_years ~ "{median} ({p25}, {p75})", # 表示したい統計量を指定(これは初期値なので取り除くことができる)
    by = outcome) %>%                                  # グループ化する変数を指定
  add_p(age_years ~ "wilcox.test")                     # 実行する検定を指定（これはデフォルトなので括弧内は取り除くこと可能）
```

### Kruskal-wallis test {.unnumbered}

Compare the distribution of a continuous variable in two or more groups,
regardless of whether the data is normally distributed.

### クラスカルーウォリス検定

データが正規分布しているかどうかに関わらず、2つ以上のグループにおける連続変数の分布を比較する。

```{r kruskal_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # 興味ある変数を投入
  tbl_summary(                                         # 要約表を作成
    statistic = age_years ~ "{median} ({p25}, {p75})", # 表示したい統計量を指定(これは初期値なので取り除くことができる)
    by = outcome) %>%                                  # グループ化する変数を指定
  add_p(age_years ~ "kruskal.test")                    # 実行する検定を指定


```

<!-- ## `dplyr` package {} -->

<!-- Performing statistical tests in `dplyr` alone is very dense, again because it  -->

<!-- does not fit within the tidy-data framework. It requires using `purrr` to create -->

<!-- a list of dataframes for each of the subgroups you want to compare. See the page on [Iteration, loops, and lists] to learn about **purrr**.   -->

<!-- An easier alternative may be the `rstatix` package.  -->

<!-- ### T-tests {.unnumbered}  -->

<!-- ```{r ttest_dplyr} -->

<!-- linelist %>%  -->

<!--   ## only keep variables of interest -->

<!--   select(age, outcome) %>%  -->

<!--   ## drop those missing outcome  -->

<!--   filter(!is.na(outcome)) %>%  -->

<!--   ## specify the grouping variable -->

<!--   group_by(outcome) %>%  -->

<!--   ## create a subset of data for each group (as a list) -->

<!--   nest() %>%  -->

<!--   ## spread in to wide format -->

<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->

<!--   mutate( -->

<!--     ## calculate the mean age for the death group -->

<!--     Death_mean = map(Death, ~mean(.x$age, na.rm = TRUE)), -->

<!--     ## calculate the sd among dead  -->

<!--     Death_sd = map(Death, ~sd(.x$age, na.rm = TRUE)), -->

<!--     ## calculate the mean age for the recover group -->

<!--     Recover_mean = map(Recover, ~mean(.x$age, na.rm = TRUE)),  -->

<!--     ## calculate the sd among recovered  -->

<!--     Recover_sd = map(Recover, ~sd(.x$age, na.rm = TRUE)), -->

<!--     ## using both grouped data sets compare mean age with a t-test -->

<!--     ## keep only the p.value -->

<!--     t_test = map2(Death, Recover, ~t.test(.x$age, .y$age)$p.value) -->

<!--   ) %>%  -->

<!--   ## drop datasets  -->

<!--   select(-Death, -Recover) %>%  -->

<!--   ## return a dataset with the medians and p.value (drop missing) -->

<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Wilcoxon rank sum test {.unnumbered} -->

<!-- ```{r wilcox_dplyr} -->

<!-- linelist %>%  -->

<!--   ## only keep variables of interest -->

<!--   select(age, outcome) %>%  -->

<!--   ## drop those missing outcome  -->

<!--   filter(!is.na(outcome)) %>%  -->

<!--   ## specify the grouping variable -->

<!--   group_by(outcome) %>%  -->

<!--   ## create a subset of data for each group (as a list) -->

<!--   nest() %>%  -->

<!--   ## spread in to wide format -->

<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->

<!--   mutate( -->

<!--     ## calculate the median age for the death group -->

<!--     Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->

<!--     ## calculate the sd among dead  -->

<!--     Death_iqr = map(Death, ~str_c( -->

<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->

<!--       collapse = ", " -->

<!--       )), -->

<!--     ## calculate the median age for the recover group -->

<!--     Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)),  -->

<!--     ## calculate the sd among recovered  -->

<!--     Recover_iqr = map(Recover, ~str_c( -->

<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->

<!--       collapse = ", " -->

<!--       )), -->

<!--     ## using both grouped data sets compare age distribution with a wilcox test -->

<!--     ## keep only the p.value -->

<!--     wilcox = map2(Death, Recover, ~wilcox.test(.x$age, .y$age)$p.value) -->

<!--   ) %>%  -->

<!--   ## drop datasets  -->

<!--   select(-Death, -Recover) %>%  -->

<!--   ## return a dataset with the medians and p.value (drop missing) -->

<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Kruskal-wallis test {.unnumbered} -->

<!-- ```{r kruskal_dplyr} -->

<!-- linelist %>%  -->

<!--   ## only keep variables of interest -->

<!--   select(age, outcome) %>%  -->

<!--   ## drop those missing outcome  -->

<!--   filter(!is.na(outcome)) %>%  -->

<!--   ## specify the grouping variable -->

<!--   group_by(outcome) %>%  -->

<!--   ## create a subset of data for each group (as a list) -->

<!--   nest() %>%  -->

<!--   ## spread in to wide format -->

<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->

<!--   mutate( -->

<!--     ## calculate the median age for the death group -->

<!--     Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->

<!--     ## calculate the sd among dead  -->

<!--     Death_iqr = map(Death, ~str_c( -->

<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->

<!--       collapse = ", " -->

<!--       )), -->

<!--     ## calculate the median age for the recover group -->

<!--     Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)),  -->

<!--     ## calculate the sd among recovered  -->

<!--     Recover_iqr = map(Recover, ~str_c( -->

<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->

<!--       collapse = ", " -->

<!--       )), -->

<!--     ## using the original data set compare age distribution with a kruskal test -->

<!--     ## keep only the p.value -->

<!--     kruskal = kruskal.test(linelist$age, linelist$outcome)$p.value -->

<!--   ) %>%  -->

<!--   ## drop datasets  -->

<!--   select(-Death, -Recover) %>%  -->

<!--   ## return a dataset with the medians and p.value (drop missing) -->

<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Chi-squared test {.unnumbered}  -->

<!-- ```{r} -->

<!-- linelist %>%  -->

<!--   ## do everything by gender  -->

<!--   group_by(outcome) %>%  -->

<!--   ## count the variable of interest -->

<!--   count(gender) %>%  -->

<!--   ## calculate proportion  -->

<!--   ## note that the denominator here is the sum of each gender -->

<!--   mutate(percentage = n / sum(n) * 100) %>%  -->

<!--   pivot_wider(names_from = outcome, values_from = c(n, percentage)) %>%  -->

<!--   filter(!is.na(gender)) %>%  -->

<!--   mutate(pval = chisq.test(linelist$gender, linelist$outcome)$p.value) -->

<!-- ``` -->

<!-- ======================================================= -->

## Correlations

### 相関

Correlation between numeric variables can be investigated using the
**tidyverse**\
**corrr** package. It allows you to compute correlations using Pearson,
Kendall tau or Spearman rho. The package creates a table and also has a
function to automatically plot the values.

数値変数間の相関は、**tidyversecorrr**パッケージを使用して調査することができます。ピアソン、ケンドールのタウ、スピアマン
ローを使って相関を計算することができます。このパッケージは表を作成し、値を自動的に記入する機能も備えています。

```{r, warning=F, message=F}

correlation_tab <- linelist %>% 
  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # 興味ある変数を投入
  correlate()      # 相関係数表を作成 (初期設定ではピアソンを使用)

correlation_tab    # 表示する

## 重複する項目を削除 (上記の表がミラーリングされている) 
correlation_tab <- correlation_tab %>% 
  shave()

## 相関係数表を表示
correlation_tab

## 相関をプロット
rplot(correlation_tab)
```

<!-- ======================================================= -->

## Resources

### リソース

Much of the information in this page is adapted from these resources and
vignettes online:

このページにおける多くの情報はオンラインでのこれらのリソースより採用しています。

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)
[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
[corrr](https://corrr.tidymodels.org/articles/using-corrr.html) [sthda
correlation](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r)

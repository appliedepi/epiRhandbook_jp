# 流行曲線（エピカーブ） {#epicurves}

```{r, out.width=c('75%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "epicurve_top.png"))
```

流行曲線（「エピカーブ」とも呼ばれる）は流行集団（クラスター）の疾病の発症の時間的パターンを可視化するための基本的な疫学グラフです。

流行曲線を分析することで、時間的な傾向、異常値、アウトブレイクの規模、曝露の可能性が最も高い時期、症例の世代間の時間間隔などが明らかになり、さらには未知の新しい疾患の伝播様式（点源、継続的な共通感染源、人から人への伝播など）を特定するのにも役立ちます。流行曲線の解釈に関するオンラインレッスンの1つとして [US CDC](https://www.cdc.gov/training/quicklearns/epimode/index.html) のウェブサイトがあります。

この章ではRで流行曲線を作成するための2つのアプローチを紹介します。

-   簡単なコマンドのみで流行曲線を作成することが出来る **incidence2** パッケージ の使用\
-   より複雑なコマンドを使用することで高度なカスタマイズが可能な **ggplot2** パッケージ の使用

また以下のような具体的な使用例にも対応しています。

-   集計データのプロット

-   ファセット化（複数グラフの作成）

-   移動平均の適用

-   報告が遅れている「暫定」データの表示

-   累積症例数を第2軸で重ね合わせたプロット

<!-- ======================================================= -->

## 準備

### パッケージをロード {.unnumbered}

解析に必要な標準パッケージをロードします。 このハンドブックでは、**pacman** の `p_load()` を使うことを強調しています。`p_load()` は、必要に応じてパッケージをインストールし、そして使用するためにパッケージをロードします。base R から `library()` を使用してパッケージをロードすることもできます。Rのパッケージについての詳細は\[R basics\]のページを参照してください。

```{r message=F, warning=F}
pacman::p_load(
  rio,          # file import/export
  here,         # relative filepaths 
  lubridate,    # working with dates/epiweeks
  aweek,        # alternative package for working with dates/epiweeks
  incidence2,   # epicurves of linelist data
  i2extras,     # supplement to incidence2
  stringr,      # search and manipulate character strings
  forcats,      # working with factors
  RColorBrewer, # Color palettes from colorbrewer2.org
  tidyverse     # data management + ggplot2 graphics
) 
```

### **データをインポート**

この章では2つのデータセットを使用します。

-   流行のシミュレーションデータから作成された症例ごとのデータ（ラインリスト）\
-   同じ流行のシミュレーションデータから作成された病院ごとの症例数の集計値

データセットは、**rio** パッケージの `import()` 関数を使ってインポートします。データをインポートする様々な方法については、\[Import and export\]のページを参照してください。

```{r, echo=F, message=F}
# linelist をインポート
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# 集計データをインポート
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```

**ラインリスト（linelist）**

エボラ出血熱のシミュレーションで得られた症例のデータセットを取り込みます。\[Download handbook and data\]のページで説明しています。ファイルが作業ディレクトリにある場合、ファイルパスにはファイル名のみ指定します。

```{r, eval=F}
linelist <- import("linelist_cleaned.rds") 
```

最初の50行を表示します：

```{r, message=FALSE, echo=F}
# ラインリストを表形式で表示
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

病院ごとの症例数

以下のコードで、病院ごとの週別の集計数を含んだデータセットを`linelist` から作成します。

```{r, eval=F}
# 集計データをRにインポート
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```

最初の50行を表示します：

```{r message=FALSE, echo=F}
# ラインリストを表形式で表示
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### パラメータの設定 {.unnumbered}

レポートを作成する際に、データの日付（「データ日」）を設定することが出来ます。これにより、`data_date` オブジェクトを参照することでフィルタリングする時や脚注に記載する時に用いることが出来ます。

```{r set_parameters}
## レポート用に日付を設定
## メモ：Sys.Date()でも最新の日付を設定することが出来ます
## note: can be set to Sys.Date() for the current date
data_date <- as.Date("2015-05-15")
```

### 日付の確認 {.unnumbered}

関連する各日付列が日付型であり、また適切な範囲であるを確認します。欠損値を除外 ( `na.rm=TRUE` )した上で `range()` を用いて範囲を確認することが出来ますし、 ヒストグラムで確認する場合は `hist()` あるいは以下のように `ggplot()` を使って簡単に行うことも出来ます。

```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# 発症日の範囲を確認
ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset))
```

<!-- ======================================================= -->

## **incidence2** パッケージ による流行曲線

以下では、**incidence2** パッケージを使用して流行曲線を作成する方法を示します。このパッケージの作者は、ユーザーが **ggplot2** の構文を知らなくても流行曲線を作成できるようにしています。このページの多くは **incidence2**の [github page](https://github.com/reconhub/incidence2) から引用しています。

<!-- ======================================================= -->

### 簡単な例 {.unnumbered}

***incidence2*** パッケージによる流行曲線の作り方は2つのステップからなります：

1)  *incidence* オブジェクトの作成 （ `incidence()` 関数の使用）

    -   データを準備\
    -   `date_index =` に日付列を指定\
    -   `interval =` で症例の集計単位を指定 （日、週、月等）\
    -   グループ化する列の指定 （例：性別、病院、転帰）\

2)  *incidence* オブジェクトの可視化

    -   ラベル、色、タイトル等の指定

以下では、incidence2 パッケージをロードし `linelist` の `date_onset` 列（発症日） から incidence オブジェクトを作成し、発症日ごとの症例を集計しています。そして、 incidence オブジェクトのサマリーを表示します。

```{r, warning=F, message=F}
# incidence2 パッケージのロード
pacman::p_load(incidence2)

# incidence オブジェクトを発症日別に集計して作成
epi_day <- incidence(       # incidence オブジェクトの作成
  x = linelist,             # データセットの指定
  date_index = date_onset,  # 日付列の指定
  interval = "day"          # 集計単位の指定
  )
```

**incidence2** オブジェクト自体は、（データフレームのような）tibble のようなっていて、データフレームのように表示したり、さらに操作したりすることが出来ます。

```{r}
class(epi_day)
```

以下のように表示されます。 `date_index` と `count` 列があります。

```{r}
epi_day
```

オブジェクトのサマリーも表示出来ます：

```{r}
# incidence オブジェクトのサマリーを表示
summary(epi_day)
```

incidence オブジェクトを可視化するには incidence オブジェクトに対して `plot()` を使用します。バックグラウンドでは、 `plot.incidence2()` 関数が呼び出されるので、**incidence2** 固有のドキュメントを読むには `?plot.incidence2` を実行します。

```{r}
# incidence オブジェクトの可視化
plot(epi_day)
```

白い縦線が多く表示される場合は、画像のサイズを調整しましょう。例えば、 `ggsave()` を使って図を出力した場合、 `width =` と `height =` に数字を入れることでサイズを調整出来ます。 プロットの幅を広げれば、これらの線は消えるでしょう。

### 症例集計の時間単位の変更 {.unnumbered}

`incidence()` の `interval =` という引数を用いることで観察された症例をどのような時間単位で集計するかを定義します

**時間単位の指定**

**incidence2** は症例数を流行曲線に集約する方法を指定するための柔軟で分かりやすい構文を与えます。 `interval =` 引数には以下のような値を指定します。下記のいずれも複数形で書くことが出来（例："weeks"）、前に数字を付けることも出来ます（例："3 months"）。

| 引数オプション          | 補足説明                               |
|-------------------------|----------------------------------------|
| 数字 (1, 7, 13, 14, 等) | 集計単位となる日数                     |
| "week"                  | メモ：月曜から始まるのがデフォルト     |
| "2 weeks"               | または3、４、５等                      |
| "Sunday week"           | 日曜から始まる週 ( Thursday 等も可能） |
| "2 Sunday weeks"        | または3、４、５等                      |
| "MMWRweek"              | 日曜から始まる週（米国CDC参照）        |
| "month"                 | 月の最初の日                           |
| "quarter"               | 四半期の最初の日                       |
| "2 months"              | または3、４、５等                      |
| "year"                  | カレンダー年の最初の日                 |

以下は、異なる間隔を `linelist` に適用した場合の表示例です。X軸上の日付ラベルのデフォルトフォーマットと頻度が、時間間隔の変更に伴ってどのように変化するかに注目してください。

```{r incidence, out.width=c('50%', '50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# incidence オブジェクトの作成 (異なる時間間隔)
##############################
# 週 (月曜から始まるのがデフォルト)
epi_wk      <- incidence(linelist, date_onset, interval = "Monday week")

# 日曜から始まる週
epi_Sun_wk  <- incidence(linelist, date_onset, interval = "Sunday week")

# 3週 (月曜から始まるのがデフォルト)
epi_2wk     <- incidence(linelist, date_onset, interval = "2 weeks")

# 月
epi_month   <- incidence(linelist, date_onset, interval = "month")

# 四半期
epi_quarter   <- incidence(linelist, date_onset, interval = "quarter")

# 年
epi_year   <- incidence(linelist, date_onset, interval = "year")

# incidence オブジェクトの可視化 (分かりやすいようにタイトルを変更)
############################
plot(epi_wk)+      labs(title = "Monday weeks")
plot(epi_Sun_wk)+  labs(title = "Sunday weeks")
plot(epi_2wk)+     labs(title = "2 (Monday) weeks")
plot(epi_month)+   labs(title = "Months")
plot(epi_quarter)+ labs(title = "Quarters")
plot(epi_year)+    labs(title = "Years")

```

<!-- **Begin at first case**   -->

<!-- If you want the intervals to begin at the first case, you can add the argument `standard = TRUE` to the `incidence()` command. This only works if the interval is either "week", "month", "quarter" or "year".   -->

**最初の日付**

`incidence()` コマンドでは日付型（例： `as.Date("2016-05-01")` )の値を `firstdate =` として指定することが出来ます。その場合、データはこの範囲で切り取られ、指定した日を集計単位の最初とすることが出来ます。

### グループ化 {.unnumbered}

グループは、 `incidence()` コマンドで指定され、棒グラフの色付けやデータのファセットに使用できます。データにグループを指定するには、 `incidence()` コマンドの `groups =` 引数に列名を指定します（列名は引用符で囲みません）。複数の列を指定する場合は、全ての列名を `c()` 内で指定します。

`na_as_group = TRUE` を設定すると、グループ化された列で値が欠損している症例を、個別の `NA` グループとして集計するように指定できます。それ以外の場合は、図から除外されます。

-   グループ化された列で棒グラフを色分けするためには、 `plot()` コマンドの `fill =` に列名を指定します。

-   グループ化された列でファセットを行うためには、下記の「**incidence2** によるファセット」のセクションを参照してください。

以下の例では、ラインリストの症例が年齢群によってグループ化されています。欠損値はグループとして含まれます。流行曲線の時間単位は週です。

```{r, message=F, warning=F}
# incidence オブジェクトを年齢群でグループ化して作成
age_outbreak <- incidence(
  linelist,                # データセットの指定
  date_index = date_onset, # 日付列の指定
  interval = "week",       # 症例を月曜始まりの週単位で集計
  groups = age_cat,        # age_cat をグループとして指定
  na_as_group = TRUE)      # 欠損値を1つのグループとして扱うように指定

# グループ化された incidence オブジェクトの可視化
plot(
  age_outbreak,             # 年齢群でグループ化したincidence オブジェクト
  fill = age_cat)+          # age_cat で棒グラフの色分け (必ず上で age_cat がグループ化されている必要がある)
labs(fill = "Age Category") # 凡例のタイトルをデフォルトの「age_cat」から変更する （ggplot2 の設定の変更）
```

[***TIP:*** **ggplot2** のコマンドである `+ labs(fill = "your title")` で凡例のタイトルを変更出来ます。]{style="color: darkgreen;"}

また、以下のように `plot()` で `stack = FALSE` と指定することで、グループ化された棒グラフを並べて表示することが出来ます：

```{r, warning=F, message=F}
# incidence オブジェクトを月単位で作成
monthly_gender <- incidence(
 linelist,
 date_index = date_onset,
 interval = "month",
 groups = gender            # gender をグループとして指定
)

plot(
  monthly_gender,   # incidence オブジェクト
  fill = gender,    # gender で棒グラフの色分け
  stack = FALSE)    # 棒グラフをグループ毎に横に並べる (積み上げではなく)
```

`incidence()` コマンドの `na_as_group =` 引数を FALSE と指定することで、欠損値のある行を図から除外することが出来ます。

### フィルタリングされたデータ {.unnumbered}

データの一部を使って流行曲線を作成するためには：

1)  linelist データに対してフィルタリングを行う\
2)  `incidence()` コマンドにフィルタリングされたデータを指定する\
3)  incidence オブジェクトを可視化する

以下の例では、 Central Hospital の症例のみを表示するようにフィルタリングされたデータを使用しています。

```{r, warning=F, message=F}
# linelist をフィルタリング
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# フィルタリングされたデータを使用して incidence オブジェクトの作成
central_outbreak <- incidence(central_data, date_index = date_onset, interval = "week")

# incidence オブジェクトの可視化
plot(central_outbreak, title = "Weekly case incidence at Central Hospital")
```

### 集計値 {.unnumbered}

元のデータが集計（カウント）されている場合は、`incidence()`で incidence オブジェクトを作成する際に、`count =` 引数に症例カウントを含む列名を指定します。

例えば、 `count_data` というデータフレームは、病院別の1日毎に症例数がカウントされています。最初の50行は次のようになっています。

```{r message=FALSE, echo=F}
DT::datatable(head(count_data,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

上のデータセットのように日単位のカウントデータで分析を行う場合、これを病院別の週単位のエピカーブに変換する `incidence()` コマンドは次のようになります。

```{r}
epi_counts <- incidence(              # incidence オブジェクトを週単位で作成
  count_data,                         # 日単位で集計されたデータセットを指定
  date_index = date_hospitalisation,  # 日付の列を指定
  count = n_cases,                    # カウント数の列を指定
  interval = "week",                  # 日単位のカウント数を週単位に変更するように指定
  groups = hospital                   # hospital をグループとして指定
  )

# 病院別でグループ化された積み上げ棒グラフの流行曲線を週単位で作成
plot(epi_counts,                      # incidence オブジェクト
     fill = hospital)                 # hospital で棒グラフの色分け
```

### ファセット/分割 {.unnumbered}

グループ別にデータをファセットする（つまり「小分割」を生成する）ためには：

1)  incidence オブジェクトの作成時に、ファセットしたい列を `groups =` に指定する。\
2)  `plot()` の代わりに `facet_plot()` コマンドを使用する。\
3)  `fill =` としてグループ化する列と `facets =` として使用するグループ化する列を指定する。

以下では、 `incidence()` コマンドで、 `hospital` と `outcome` の両方の列をグループ化列として指定します。そして `facet_plot()` によって病院ごとに異なる流行曲線を作成し、各流行曲線の中で `outcome` 別に色分けされた棒グラフを重ねるように指定します。

```{r, warning=F, message=F}
epi_wks_hosp_out <- incidence(
  linelist,                      # データセットを指定
  date_index = date_onset,       # 日付列を指定
  interval = "month",            # 月単位に指定  
  groups = c(outcome, hospital)  # outcome と hospital の2つをグループ化する列と指定指定
  )

# 可視化
incidence2::facet_plot(
  epi_wks_hosp_out,      # incidence オブジェクト
  facets = hospital,     # ファセット化する列名
  fill = outcome)        # 色分けする列名 

```

系統樹の可視化に使用される ggtree パッケージにも `facet_plot()` という関数があるため注意が必要です - このため上記で `incidence2::facet_plot()` というように明示的に関数名を指定しています。

### `plot()` に修正 {.unnumbered}

**incidence2** によって生成された 流行曲線 は、*`plot()`* 関数内の以下の引数によって修正することが出来ます。

**以下は棒グラフの見た目を変更する `plot()` の引数です。**

+----------------+-----------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| 引数           | 説明                                                                                                | 例                                                  |
+================+=====================================================================================================+=====================================================+
| `fill =`       | 棒グラフの色を指定する。 `incidence()` コマンドで `groups =` に指定された色名または列名のいずれか。 | `fill = "red"`、または `fill = gender`              |
+----------------+-----------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| `color =`      | 棒グラフの枠線、または棒グラフの中の各グループの枠線に色をつける。                                  | `border = "white"`                                  |
+----------------+-----------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| `legend =`     | 凡例の場所を指定する。                                                                              | "bottom"、"top"、"left", "right"、 "none"のいずれか |
+----------------+-----------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| `alpha =`      | 棒グラフの色の透明度を指定する                                                                      | 1が最も濃く、0が最も透明                            |
+----------------+-----------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| `width =`      | 時間間隔に対する棒グラフの相対的な大きさを示す0～1の値                                              | `width = .7`                                        |
+----------------+-----------------------------------------------------------------------------------------------------+-----------------------------------------------------+
| `show_cases =` | 論理値。もし TRUE の場合は各症例が枠で表示される。アウトブレイクが小さい場合に適している。          |                                                     |
+----------------+-----------------------------------------------------------------------------------------------------+-----------------------------------------------------+

**以下は時間軸を変更する `plot()` の引数です。**

+------------------+---------------------------------------------------------------------------------------------------+
| 引数             | 説明                                                                                              |
+==================+===================================================================================================+
| `centre_dates =` | 日付表示を棒グラフの中央に表示するか、先頭に表示するかについての TRUE/FALSE                       |
+------------------+---------------------------------------------------------------------------------------------------+
| `date_format =`  | strptime ("%") 構文を使用して日付表示形式を調整。center_dates = FALSEの場合のみ動作（詳細は後述） |
+------------------+---------------------------------------------------------------------------------------------------+
| `n.breaks =`     | X軸の日付ラベルの分割数の目安                                                                     |
+------------------+---------------------------------------------------------------------------------------------------+
| `angle =`        | X軸の日付ラベルの角度                                                                             |
+------------------+---------------------------------------------------------------------------------------------------+
| `size =`         | 文字サイズ                                                                                        |
+------------------+---------------------------------------------------------------------------------------------------+

`date_breaks =` 引数は、 `centre_dates = FALSE` の場合にのみ機能することに注意してください。\[Working with dates\]のページで説明されているように、以下のstrptime構文を使用して、引用符で囲まれた文字値を指定します。改行」には `\n` を使うことができます。

%d = 日付 (5, 17, 28, etc.)\
%j = 年における日付 (ユリウス通日 001-366)\
%a = 省略された曜日名 (Mon, Tue, Wed 等)\
%A = 省略されたいない曜日名 (Monday, Tuesday 等)\
%w = 曜日番号 (0-6, 日曜日が0)\
%u = 曜日番号 (1-7, 月曜日が1)\
%W = 週番号 (00-53, 月曜日が週の始め)\
%U = 週番号(01-53, 日曜日が週の始め)\
%m = 月 (01, 02, 03, 04 等)\
%b = 省略された月名 (Jan, Feb 等)\
%B = 省略されていない月名 (January, February 等)\
%y = 2桁年 (例：89)\
%Y = 4桁年 (例：1989)\
%h = 時間 (24時間単位)\
%m = 分\
%s = 秒\
%z = グリニッジ標準時間からの時間差\
%Z = タイムゾーン （文字列型）

<!-- <span style="color: darkgreen;">**_TIP:_** For breaks every "nth" interval (e.g. every 4th), use `n.breaks = nrow(i)/n` (where “i” is your incidence object name and “n” is a number). If your data are grouped, you will need to multiply "n" by the number of unique groups.</span>   -->

**Here are `plot()` arguments that modify plot labels:**

**以下はラベルを変更する `plot()` の引数です。**

+------------+------------------------------------------------------------------------------------------------+
| 引数       | 説明                                                                                           |
+============+================================================================================================+
| `title =`  | グラフのタイトル                                                                               |
+------------+------------------------------------------------------------------------------------------------+
| `xlab =`   | x軸のタイトル                                                                                  |
+------------+------------------------------------------------------------------------------------------------+
| `ylab =`   | y軸のタイトル                                                                                  |
+------------+------------------------------------------------------------------------------------------------+
| `size =`   | x軸の文字のサイズ（単位：pt）（他のサイズを調整するには ggplot の theme() を使用してください。 |
+------------+------------------------------------------------------------------------------------------------+

上記引数の例を示します：

```{r, warning=F, message=F}
# linelistのフィルタリング
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# フィルタリングデータを使った incidence オブジェクトの作成 
central_outbreak <- incidence(
  central_data,
  date_index = date_onset,
  interval = "week",
  groups = outcome)

# incidence オブジェクトの可視化
plot(
  central_outbreak,
  fill = outcome,                       # グラフの色分け
  legend = "top",                       # 凡例を一番上に置く
  title = "Cases at Central Hospital",  # タイトル
  xlab = "Week of onset",               # x軸のタイトル
  ylab = "Week of onset",               # y軸のタイトル
  show_cases = TRUE,                    # それぞれの症例を枠線で示す
  alpha = 0.7,                          # 透明度 
  border = "grey",                      # 症例ごとの枠線
  angle = 30,                           # 日付ラベルの角度
  centre_dates = FALSE,                 # 日付ラベルを各グラフの先頭に配置
  date_format = "%a %d %b %Y\n(Week %W)" # 日付の記載方法の変更
  )
```

グラフの見た目をさらに調整するには、以下の「 `ggplot()` による修正」のセクションを参照してください。

### ggplot2 による調整 {.unnumbered}

以下に示すように、 **incidence2** の `plot()` 関数の終了後に `+` で **ggplot2** による調整を加えることが出来ます。

下の例では、**incidence2** のプロットが終了した後、**ggplot2** コマンドを使って、軸の修正、脚注の追加、太字フォントと文字サイズの調整を行っています。

`scale_x_date()` を追加すると、`plot()` の日付フォーマットのほとんどが上書きされてしまうことに注意してください。他の多くの方法については、`ggplot()` の流行曲線のセクションと、このハンドブックの\[ggplot tips\]のページを参照してください。

```{r, warning=F, message=F}
# linelist のフィルタリング
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# フィルタリングデータを使った incidence オブジェクトの作成
central_outbreak <- incidence(
  central_data,
  date_index = date_onset,
  interval = "week",
  groups = c(outcome))

# incidence オブジェクトの可視化
plot(
  central_outbreak,
  fill = outcome,                       # グラフの色分け
  legend = "top",                       # 凡例を一番上に置く
  title = "Cases at Central Hospital",  # タイトル
  xlab = "Week of onset",               # x軸のタイトル
  ylab = "Week of onset",               # y軸のタイトル
  show_cases = TRUE,                    # それぞれの症例を枠線で示す
  alpha = 0.7,                          # 透明度 
  border = "grey",                      # 症例ごとの枠線
  centre_dates = FALSE,                   
  date_format = "%a %d %b\n%Y (Week %W)", 
  angle = 30                           # 日付ラベルの角度
  )+
  
  scale_y_continuous(
    breaks = seq(from = 0, to = 30, by = 5),  # y軸を5ずつで区分
    expand = c(0,0))+                         # y軸の0以下の余分なスペースを削除
  
  # 脚注の追加
  labs(
    fill = "Patient outcome",                               # 凡例タイトル
    caption = stringr::str_glue(                            # 脚注（詳細は characters and strings に関するページを参照）
      "n = {central_cases} from Central Hospital
      Case onsets range from {earliest_date} to {latest_date}. {missing_onset} cases are missing date of onset and not shown",
      central_cases = nrow(central_data),
      earliest_date = format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),
      latest_date = format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),      
      missing_onset = nrow(central_data %>% filter(is.na(date_onset)))))+
  
  # 太字フォントの追加と脚注の位置の指定
  theme(
    axis.title = element_text(size = 12, face = "bold"),    # 軸タイトルを大きく、太字にする
    axis.text = element_text(size = 10, face = "bold"),     # 軸の文字を大きく、太字にする
    plot.caption = element_text(hjust = 0, face = "italic") # 脚注を左に寄せる
  )
  
```

### 色の変更 {.unnumbered}

#### 色パレットの指定 {.unnumbered}

`plot()` の `col_pal =` 引数に、定義済みの色パレットの名前を指定します。**incidence2** パッケージには、「vibrant 」と 「muted 」という2つの色パレットが付属しています。「vibrant 」では最初の6色が、「muted 」では最初の9色がそれぞれ異なる色となっています。それ以降の色は、他の色の補間となります。これらの定義されたパレットは、[このウェブサイト](https://personal.sron.nl/~pault/#sec:qualitative) で見ることが出来ます。これらのパレットには灰色が含まれていませんが、これは欠損値があった場合に用いられるためです（`na_color =` を指定することでこのデフォルトを変更出来ます）。

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
# age でグループ化された incidence オブジェクトの作成
age_outbreak <- incidence(
  linelist,
  date_index = date_onset,   # x軸を発症日に指定
  interval = "week",         # 症例を週単位で集計
  groups = age_cat)

# デフォルトの色パレットを用いて流行曲線を作成
plot(age_outbreak, fill = age_cat, title = "'vibrant' default incidence2 palette")

# 異なる色パレットを用いる場合は以下
#plot(age_outbreak, fill = age_cat, col_pal = muted, title = "'muted' incidence2 palette")
```

また、R の**ベースの色**パレットを使用することも出来ます（パレットの名前を引用符なしで入れてください）。

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
# Rのベースの色パレットを使用して可視化
plot(age_outbreak, fill = age_cat, col_pal = heat.colors, title = "base R heat.colors palette")

# Rのベースの色パレットを使用して可視化
plot(age_outbreak, fill = age_cat, col_pal = rainbow, title = "base R rainbow palette")
```

**viridis** パッケージや **RColorBrewer** パッケージから色パレットを追加することも出来ます。これらのパッケージをロードしてから、それぞれの `scale_fill_*()` 関数を以下のように `+` で追加する必要があります。

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
pacman::p_load(RColorBrewer, viridis)

# 色パレットを使用して可視化
plot(age_outbreak, fill = age_cat, title = "Viridis palette")+
  scale_fill_viridis_d(
    option = "inferno",     # color scheme, try also "plasma" or the default
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values

# 色パレットを使用して可視化
plot(age_outbreak, fill = age_cat, title = "RColorBrewer palette")+
  scale_fill_brewer(
    palette = "Dark2",      # color palette, try also Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values
```

#### マニュアルで色を指定 {.unnumbered}

マニュアルで色を指定するには、**ggplot2** の関数 `scale_fill_manual()` を `plot()` に `+` で追加し、色の名前またはHEXコードのベクトルを引数 `values =` に与えます。 リストアップされた色の数は、グループの数と等しくなければなりません。欠損値がグループであるかどうかに注意してください。欠損値は、 \[Factors\]のページで説明したように、データの準備中に `fct_explicit_na()` という関数で「Missing」のような文字型に変換することが出来ます。

```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}
# 色のマニュアル指定
plot(age_outbreak, fill = age_cat, title = "Manually-specified colors")+
  scale_fill_manual(
    values = c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange", "red", "lightblue"),  # 色
    name = "Age Category")      # 凡例のタイトル
```

\[ggplot tips\] ページにあるように、色のベクトルに `colorRampPalette()` を使って、欲しい色の数を指定することで、独自の色パレットを作ることができます。これは、いくつかの色を指定することで、多くの色を取得出来る良い方法です。

```{r}
my_cols <- c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange")
my_palette <- colorRampPalette(my_cols)(12)  # 6つの色を12色に拡張
my_palette
```

### レベル順序の調整 {.unnumbered}

グループの表示順（グラフや凡例での表示）を調整するには、グループ化した列が因子型である必要があります。詳細は、 \[Factors\] のページを参照してください。

まず、デフォルトの順序で病院別の週単位での流行曲線を見てみましょう：

```{r, message=F, warning=F}
# オリジナル（hospital が因子型出ない場合）
###################################

# hospitalでグループ化された週単位の incidence オブジェクトの作成
hospital_outbreak <- incidence(
  linelist,
  date_index = date_onset, 
  interval = "week", 
  groups = hospital)

# incidence オブジェクトの可視化
plot(hospital_outbreak, fill = hospital, title = "ORIGINAL - hospital not a factor")
```

次に "Missing "と "Other "が流行曲線の一番上に来るように順番を調整するために以下のことを行います：

-   因子型を扱うために **forcats** パッケージをロードする

-   データセットの調整 - ここでは、新しいデータセット(`plot_data`)を定義します：

    -   `gender` 列を因子型として定義した後に `fct_relevel()` でレベルの順序を設定し、"Other "と "Missing "が最初に来るようにすることで、棒グラフの一番上に表示されるようにします。

-   incidence オブジェクトを作成し、可視化します is created and plotted as before

-   **ggplot2** の修正を加えます。

    -   `scale_fill_manual()` を使って、"Missing "が灰色、"Other "がベージュになるように、マニュアルで色を割り当てます。

```{r, message=F, warning=F}
# hospital 列を因子型に変更する
###############################

# 因子型データを扱うために forcats パッケージをロード
pacman::p_load(forcats)

# hospital 列を因子型に変換しレベルを変更する
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # "Missing" と "Other" が最初になるようにレベルを指定


# hospital と week でグループ化された週ごとの incidence オブジェクトの作成
hospital_outbreak_mod <- incidence(
  plot_data,
  date_index = date_onset, 
  interval = "week", 
  groups = hospital)

# incidence オブジェクトの可視化
plot(hospital_outbreak_mod, fill = hospital)+
  
  # マニュアルで色を指定
  scale_fill_manual(values = c("grey", "beige", "darkgreen", "green2", "orange", "red", "pink"))+                      

  # ggplot でラベルを追加
  labs(
      title = "MODIFIED - hospital as factor",   # グラフのタイトル
      subtitle = "Other & Missing at top of epicurve",
      y = "Weekly case incidence",               # y軸のタイトル
      x = "Week of symptom onset",               # x軸のタイトル
      fill = "Hospital")                         # 凡例のタイトル
```

[***TIP:*** 凡例の順番のみを逆にしたい場合は **ggplot2** コマンドの]{style="color: darkgreen;"}`guides(fill = guide_legend(reverse = TRUE))`[を追加する]{style="color: darkgreen;"}

### 縦罫線 {.unnumbered}

デフォルトの **incidence2** の設定でグラフを作成した場合、縦罫線が各日付ラベルと各日付ラベルの間に1回ずつ表示されることに気づくかもしれません。このため、罫線が一部の棒グラフの上部と交差してしまうことがあります。

<!-- [TO DO Note this paragraph is not applicable with version 1.0.0 of incidence2). You can specify the interval for the gridlines by adding **ggplot2**'s `scale_x_date()` command to your **incidence2** plot. Within it, specify the intervals for `date_breaks = ` and `date_minor_breaks = ` (e.g. "weeks" or "3 weeks" or "months"). Note that use of `scale_x_date()` will over-ride any formatting of the date labels in `plot()`, so you will need to specify any string format to `date_labels = ` as below.   -->

**ggplot2** コマンド `theme_classic()` を追加することで、すべての罫線を削除することが出来ます。

```{r, warning=F, message=F, out.width = c('50%', '50%', '50%'), fig.show='hold'}
# incidence オブジェクトの作成
a <- incidence(
  central_data,
  date_index = date_onset,
  interval = "Monday weeks"
)

# デフォルトの罫線
plot(a, title = "Default lines")

# 罫線幅の指定
# INCIDENCE2 1.0.0 では動作しません
# plot(a, title = "Weekly lines")+
#   scale_x_date(
#     date_breaks = "4 weeks",      # major vertical lines align on weeks
#     date_minor_breaks = "weeks",  # minor vertical lines every week
#     date_labels = "%a\n%d\n%b")   # format of date labels

# 罫線の削除
plot(a, title = "No lines")+
  theme_classic()                 # 罫線の削除
```

ただし、週ごとに集計する場合、`date_breaks` と `date_minor_breaks` 引数は月曜日始まりの週にしか機能しないことに注意してください。週の始まりが他の曜日の場合は、代わりに `breaks =` と `minor_breaks =` 引数に日付を手動で与える必要があります。`seq.Date()` を使った例は **ggplot2** のセクションを参照してください。

### 累積罹患率 {.unnumbered}

incidence オブジェクトを **incidence2 コマンド**の `cumulate()` に渡し、次に `plot()` に渡すことで、累積罹患率のグラフを簡単に作成することが出来ます。これは `facet_plot()` でも動作します。

```{r}
# 週ごとの incidence オブジェクトの作成
wkly_inci <- incidence(
  linelist,
  date_index = date_onset,
  interval = "week"
)

# 累積罹患率グラフの作成
wkly_inci %>% 
  cumulate() %>% 
  plot()
```

**ggplot2** を使って累積罹患率のグラフを作成する別の方法については、このページの下の方にあるセクションを参照して下さい - 例えば、流行曲線の上に累積罹患率の線グラフを重ねることも可能です。

### 移動平均 {.unnumbered}

**i2extras** パッケージの `add_rolling_average()` を使って、**Incidence2** プロットに簡単に移動平均を追加することができます。**incidence2** オブジェクトをこの関数に渡し、次に `plot()` に渡します。 `before =` を移動平均に含めたい過去の日数として設定します（デフォルトは2）。データがグループ化されている場合は、グループごとに移動平均が計算されます。

```{r, warning=F, message=F}
rolling_avg <- incidence(                    # incidence オブジェクトの作成
  linelist,
  date_index = date_onset,
  interval = "week",
  groups = gender) %>% 
  
  i2extras::add_rolling_average(before = 6)  # 移動平均を追加 (ここではgenderごと)

# plot
plot(rolling_avg, n.breaks = 3) # グループごとに移動平均が作成されているので自動でファセット化される
```

より一般的なデータに対して移動平均を算出する場合はこのハンドブックの [Moving averages] を参照して下さい。

<!-- ======================================================= -->

## ggplot2 を用いた流行曲線

`ggplot()` を使用して流行曲線を作成すると、より柔軟にカスタマイズできますが、より多くの手順と `ggplot()` の動作の理解が必要です。

**incidence2** パッケージを使用する場合とは異なり、症例の集計単位（週、月など）や、日付軸のラベルの間隔をマニュアルで制御する必要があります。これは注意して行う必要があります。

以下の例では、`linelist` データセットの一部（Central Hospital の症例のみ）を使用しています。

```{r, echo=F}
# linelist のインポート
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r}
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")
```

```{r, eval=F, echo=F}
detach("package:tidyverse", unload=TRUE)
library(tidyverse)
```

`ggplot()` を使用した流行曲線の作成は3つの要素に分かれます：

-   ラインリストの症例を、特定の「分割」ポイントで区別される「ビン」に集約したヒストグラム\
-   軸のスケールとそのラベル\
-   タイトル、ラベル、キャプションなど、グラフの見た目に関するテーマ

### 症例のビンの指定 {.unnumbered}

ここでは、症例をヒストグラムのビン（「棒グラフ」）に集約する方法を説明します。ここで重要なのは、ヒストグラムのビンへの症例の集約は、必ずしもx軸に表示される日付と同じ間隔ではないということです。

以下は、日次と週次の流行曲線を作成するための最も簡単なコードです。

`ggplot()` コマンドでは、データセットを `data =` で指定します。 この土台の上に、ヒストグラムの形状を `+` で追加します。`geom_histogram()` では、`date_onset` 列がx軸にマッピングされるように指定します。また、`geom_histogram()` 内では、`aes()` 内ではなく、ヒストグラムの `binwidth =` を日単位で設定します。この**ggplot2**の構文が分かりにくい場合は、\[ggplot basics\]のページを参照して下さい。

[***注意：***`binwidth = 7` ***を使って週別の症例数をプロットすると、7日間の最初のビンが最初の症例で開始されます。特定の週を作成するには、以下のセクションを参照してください。***]{style="color: orange;"}

```{r ggplot_simple,  out.width = c('50%', '50%'), fig.show='hold', warning= F, message = F}
# daily 
ggplot(data = central_data) +          # データセットの指定
  geom_histogram(                      # ヒストグラムの追加
    mapping = aes(x = date_onset),     # 日付列をx軸に指定
    binwidth = 1)+                     # 1日ごとのビンを指定
  labs(title = "Central Hospital - Daily")                # タイトル

# weekly
ggplot(data = central_data) +          # データセットの指定 
  geom_histogram(                      # ヒストグラムの追加
      mapping = aes(x = date_onset),   # 日付列をx軸に指定
      binwidth = 7)+                   # 7日ごとのビンを指定、最初の症例から始まる（！）
  labs(title = "Central Hospital - 7-day bins, starting at first case") # タイトル
```

この Central Hospital のデータセットの最初の症例は、症状が出たのが1日目だったことに注目しましょう：

```{r}
format(min(central_data$date_onset, na.rm=T), "%A %d %b, %Y")
```

**ヒストグラムのビンの区切りをマニュアルで指定するには，`binwidth =` を使用せず，代わりに `breaks =` に日付のベクトルを指定します。**

日付のベクトルは、Rのベース関数 `seq.Date()` で作成します。この関数は開始日 `from =` 、終了日 `to =` と日単位 `by =` を引数に取ります。例えば、以下のコマンドは、1月15日から6月28日までの月ごとの日付を返します。

```{r}
monthly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                           to = as.Date("2015-07-15"),
                           by = "months")

monthly_breaks   # 表示
```

このベクトルは、`geom_histogram()` に `breaks =` として与えることができます：

```{r, warning=F, message=F}
# 月ごと 
ggplot(data = central_data) +  
  geom_histogram(
    mapping = aes(x = date_onset),
    breaks = monthly_breaks)+         # 上で定義した日付ベクトルを指定 vector of breaks                    
  labs(title = "Monthly case bins")   # タイトル
```

`by = "week"` を設定すると、単純な週単位の日付列を返すことが出来ます。例えば：

```{r}
weekly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                          to = as.Date("2015-07-15"),
                          by = "week")
```

開始日と終了日を指定する代わりに、週単位のビンが最初の症例の前の月曜日から始まるようにコードを書くことも出来ます。**以下の例では、これらの日付ベクトルを使用します。**

```{r}
# CENTRAL HOSPITAL データにおける月曜日だけを含んだ日付ベクトル
weekly_breaks_central <- seq.Date(
  from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # 最初の症例以前の月曜日の日付
  to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # 最後の症例以後の月曜日の日付
  by   = "week")
```

上の少し複雑なコードを紐解いてみましょう：

-   「from」の数値（日付ベクトルの最初の日付）は以下のようにして設定されます：**lubridate パッケージにおける** `floor_date()` 関数に `date_onset` 列の最少の値（`na.rm=TRUE` で欠損値を除外した`min()` 関数で得られます）を渡します。この時に `floor_date()` に「week」を指定すると、各週の開始日が月曜日 (`week_start = 1`) であるとした場合に、その症例の 「week」 の開始日が返されます。

-   同様に、「to 」の数値（日付ベクトルの最後の日付）は、逆の関数である `ceiling_date()` を用いて、最後の症例の翌月曜日を返すように作成されます。\

-    `seq.Date()` の引数 by には、日、週、月の任意の数を指定することが出来ます。\

-   `week_start = 7` を使用することで日曜から開始される週にすることが出来ます。

これらの日付ベクトルはこのページ全体で使用するため、全体のデータに対するものも以下で定義しておきます（上記は Central Hospital のみ）。

```{r}
#  全体のデータにおける日付ベクトルの作成
weekly_breaks_all <- seq.Date(
  from = floor_date(min(linelist$date_onset, na.rm=T),   "week", week_start = 1), # 最初の症例以前の月曜日の日付
  to   = ceiling_date(max(linelist$date_onset, na.rm=T), "week", week_start = 1), # 最後の症例以後の月曜日の日付
  by   = "week")
```

これらの `seq.Date()` の出力は、ヒストグラムのビンの区切りだけでなく、ビンから独立した日付ラベルの区切りを作成するためにも使用できます。日付ラベルについては、後のセクションで詳しく説明します。

TIP：よりシンプルなggplot()コマンドを使用するには、bin breakとdate label breakをあらかじめ名前付きベクトルとして保存しておき、breaks =にその名前を指定するだけです。

[***TIP:*** bin breaks と date label breaks をあらかじめ名前付きのベクトルとして保存しておき、`breaks =` にそのベクトルを指定することで、よりシンプルな `ggplot()` コマンドにすることが出来ます。]{style="color: darkgreen;"}

### 週別流行曲線の例 {.unnumbered}

**以下は日付ラベル、縦罫線を含んだ、月曜始まりの週別流行曲線を作成するための詳細なサンプルコードです。**このセクションは、すぐにコードを必要とするユーザーのためのものです。それぞれの側面（テーマ、日付ラベル等）を深く理解するためには、以降のセクションを参照して下さい。注目すべき点として以下があります：

-   ヒストグラムのビンの区切りは、上で説明したように `seq.Date()` で定義され、最も早い症例の前の月曜日から始まり、最後の症例の後の月曜日で終わります。

-   日付ラベルの間隔は `scale_x_date()` の中の `date_breaks =` で指定します。\

-   日付ラベルの間の縦罫線の間隔は `date_minor_breaks =` で指定します。\

-   x軸とy軸のスケールで `expand = c(0,0)` を使用すると、軸の両側の余分なスペースがなくなり、日付ラベルが最初のバーから始まるように出来ます。

```{r, warning=F, message=F}
# 月曜日ごとの集計
#############################
# 週ごとの日付ベクトルの作成
weekly_breaks_central <- seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # 最初の症例以前の月曜日の日付
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # 最後の症例以後の月曜日の日付
      by   = "week")    # 7日間隔に指定


ggplot(data = central_data) + 
  
  # ヒストグラムの作成：ビンの分割数の指定：最初の症例の前の月曜日から始まり、最後の症例の後の月曜日を終了する
  geom_histogram(
    
    # マッピング
    mapping = aes(x = date_onset),  # 日付列をx軸にマッピング
    
    # ビンの分割指定
    breaks = weekly_breaks_central, # 上で定義したビンの分割
    
    # bars
    color = "darkblue",     # 枠線の色指定
    fill = "lightblue"      # 棒グラフの色の指定
  )+ 
    
  # x軸ラベル
  scale_x_date(
    expand            = c(0,0),           # X軸の前後の余分なスペースを削除
    date_breaks       = "4 weeks",        # 日付ラベルと主要な縦罫線を4週ごとに表示。
    date_minor_breaks = "week",           # 小縦罫線を1週ごとに表示
    date_labels       = "%a\n%d %b\n%Y")+ # 日付ラベルのフォーマット
  
  # y-axis
  scale_y_continuous(
    expand = c(0,0))+             # y軸の前後の余分なスペースを削除
  
  # テーマの指定
  theme_minimal()+                # 背景を簡潔なものに指定
  
  theme(
    plot.caption = element_text(hjust = 0,        # 脚注を左寄せに配置
                                face = "italic"), # キャプションをイタリック体に指定
    axis.title = element_text(face = "bold"))+    # 軸タイトルを太字に指定
  
  # 脚注を含んだラベル
  labs(
    title    = "Weekly incidence of cases (Monday weeks)",
    subtitle = "Note alignment of bars, vertical gridlines, and axis labels on Monday weeks",
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

#### 日曜始まりの週 {.unnumbered}

`date_breaks = "weeks"` は月曜始まりの週に対してのみ機能するため、日曜始まりの週に対して上記の可視化を行うには、いくつかの修正が必要です。

-   ヒストグラムビンの分割点を日曜日に設定する必要があります （`week_start = 7`）。\
-   `scale_x_date()` 内で、日付ラベルと縦罫線が日曜日に揃うように、`breaks =` と `minor_breaks =` に同様の日付の分割点を設定する必要があります。

例えば、日曜始まりの週に対する `scale_x_date()` コマンドは、以下のようになります：

```{r, eval=F}
scale_x_date(
    expand = c(0,0),
    
    # 日付ラベルと縦罫線の間隔を指定
    breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # 最初の症例以前の月曜日の日付
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # 最後の症例以後の月曜日の日付
      by   = "4 weeks"),
    
    # 小縦罫線の間隔を指定 
    minor_breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # 最初の症例以前の月曜日の日付
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # 最後の症例以後の月曜日の日付
      by   = "week"),
   
    # 日付ラベルのフォーマット
    date_labels = "%a\n%d %b\n%Y")+         # 曜日＋日付と省略月名と年

```

### グループ化・値による色分け {.unnumbered}

棒グラフは、グループごとに色分けして積み重ねることが出来ます。グループ化する列を指定するには、以下のように変更します。詳しくは\[ggplot の基礎\]ページを参照して下さい．

-   `aes()` 内で，列名を `group =` と `fill =` の引数に対応させます。\
-   `aes()` の外側にある `fill =` の引数は、内側の引数を上書きするので削除してください。\
-   `aes()` の内側の引数はグループごとに適用されますが、外側の引数はすべての棒グラフに適用されます (例えば、`color =` outside を指定して、各棒グラフに同じ枠線を表示することが出来ます)。

以下は、`aes()` コマンドで棒グラフを性別でグループ化、色分けする場合の例です。

```{r, eval=F}
aes(x = date_onset, group = gender, fill = gender)
```

以下の適用されます：

```{r, warning=F, message=F}
ggplot(data = linelist) +     # begin with linelist (many hospitals)
  
  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = hospital,       # set data to be grouped by hospital
      fill = hospital),       # bar fill (inside color) by hospital
    
    # bin breaks are Monday weeks
    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       
    
    # Color around bars
    color = "black")
```

### 色の調整 {.unnumbered}

-   To *manually* set the fill for each group, use `scale_fill_manual()` (note: `scale_color_manual()` is different!).

    -   Use the `values =` argument to apply a vector of colors.\
    -   Use `na.value =` to specify a color for `NA` values.\
    -   Use the `labels =` argument to change the text of legend items. To be safe, provide as a named vector like `c("old" = "new", "old" = "new")` or adjust the values in the data itself.\
    -   Use `name =` to give a proper title to the legend\

-   For more tips on color scales and palettes, see the page on \[ggplot basics\].

```{r, warning=F, message=F}
ggplot(data = linelist)+           # begin with linelist (many hospitals)
  
  # make histogram
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,          # cases grouped by hospital
        fill = hospital),          # bar fill by hospital
    
    # bin breaks
    breaks = weekly_breaks_all,        # sequence of weekly Monday bin breaks, defined in previous code
    
    # Color around bars
    color = "black")+              # border color of each bar
  
  # manual specification of colors
  scale_fill_manual(
    values = c("black", "orange", "grey", "beige", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital") # specify fill colors ("values") - attention to order!
```

### Adjust level order {.unnumbered}

The order in which grouped bars are stacked is best adjusted by classifying the grouping column as class Factor. You can then designate the factor level order (and their display labels). See the page on \[Factors\] or \[ggplot tips\] for details.

Before making the plot, use the `fct_relevel()` function from **forcats** package to convert the grouping column to class factor and manually adjust the level order, as detailed in the page on \[Factors\].

```{r}
# load forcats package for working with factors
pacman::p_load(forcats)

# Define new dataset with hospital as factor
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # Convert to factor and set "Missing" and "Other" as top levels to appear on epicurve top

levels(plot_data$hospital) # print levels in order
```

In the below plot, the only differences from previous is that column `hospital` has been consolidated as above, and we use `guides()` to reverse the legend order, so that "Missing" is on the bottom of the legend.

```{r, warning=F, message=F}
ggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor
  
  # make histogram
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,               # cases grouped by hospital
        fill = hospital),               # bar fill (color) by hospital
    
    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section
    
    color = "black")+                   # border color around each bar
    
  # x-axis labels
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space before and after case bars
    date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
    date_minor_breaks = "week",         # vertical lines appear every Monday week
    date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(
    expand = c(0,0))+                   # remove excess y-axis space below 0
  
  # manual specification of colors, ! attention to order
  scale_fill_manual(
    values = c("grey", "beige", "black", "orange", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital")+ 
  
  # aesthetic themes
  theme_minimal()+                      # simplify plot background
  
  theme(
    plot.caption = element_text(face = "italic", # caption on left side in italics
                                hjust = 0), 
    axis.title = element_text(face = "bold"))+   # axis titles in bold
  
  # labels
  labs(
    title    = "Weekly incidence of cases by hospital",
    subtitle = "Hospital as re-ordered factor",
    x        = "Week of symptom onset",
    y        = "Weekly cases")
```

[***TIP:*** To reverse the order of the legend only, add this **ggplot2** command: `guides(fill = guide_legend(reverse = TRUE))`.]{style="color: darkgreen;"}

### Adjust legend {.unnumbered}

Read more about legends and scales in the \[ggplot tips\] page. Here are a few highlights:

-   Edit legend title either in the scale function or with `labs(fill = "Legend title")` (if your are using `color =` aesthetic, then use `labs(color = "")`)\
-   `theme(legend.title = element_blank())` to have no legend title\
-   `theme(legend.position = "top")` ("bottom", "left", "right", or "none" to remove the legend)
-   `theme(legend.direction = "horizontal")` horizontal legend
-   `guides(fill = guide_legend(reverse = TRUE))` to reverse order of the legend

### Bars side-by-side {.unnumbered}

Side-by-side display of group bars (as opposed to stacked) is specified within `geom_histogram()` with `position = "dodge"` placed outside of `aes()`.

If there are more than two value groups, these can become difficult to read. Consider instead using a faceted plot (small multiples). To improve readability in this example, missing gender values are removed.

```{r, warning=F, message=F}
ggplot(central_data %>% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender
    geom_histogram(
        mapping = aes(
          x = date_onset,
          group = gender,         # cases grouped by gender
          fill = gender),         # bars filled by gender
        
        # histogram bin breaks
        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section
        
        color = "black",          # bar edge color
        
        position = "dodge")+      # SIDE-BY-SIDE bars
                      
  
  # The labels on the x-axis
  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
               date_minor_breaks = "week",         # vertical lines appear every Monday week
               date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels
  
  #scale of colors and legend labels
  scale_fill_manual(values = c("brown", "orange"),  # specify fill colors ("values") - attention to order!
                    na.value = "grey" )+     

  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases, by gender",
       subtitle = "Subtitle",
       fill     = "Gender",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported")
```

### Axis limits {.unnumbered}

There are two ways to limit the extent of axis values.

Generally the preferred way is to use the command `coord_cartesian()`, which accepts `xlim = c(min, max)` and `ylim = c(min, max)` (where you provide the min and max values). This acts as a "zoom" without actually removing any data, which is important for statistics and summary measures.

Alternatively, you can set maximum and minimum date values using `limits = c()` within `scale_x_date()`. For example:

```{r eval=F}
scale_x_date(limits = c(as.Date("2014-04-01"), NA)) # sets a minimum date but leaves the maximum open.  
```

Likewise, if you want to the x-axis to extend to a specific date (e.g. current date), even if no new cases have been reported, you can use:

```{r eval=F}
scale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  
```

[***DANGER:*** Be cautious setting the y-axis scale breaks or limits (e.g. 0 to 30 by 5: `seq(0, 30, 5)`). Such static numbers can cut-off your plot too short if the data changes to exceed the limit!.]{style="color: red;"}

### Date-axis labels/gridlines {.unnumbered}

[***TIP:*** Remember that date-axis **labels** are independent from the aggregation of the data into bars, but visually it can be important to align bins, date labels, and vertical grid lines.]{style="color: darkgreen;"}

To **modify the date labels and grid lines**, use `scale_x_date()` in one of these ways:

-   **If your histogram bins are days, Monday weeks, months, or years**:

    -   Use `date_breaks =` to specify the interval of labels and major gridlines (e.g. "day", "week", "3 weeks", "month", or "year")
    -   Use `date_minor_breaks =` to specify interval of minor vertical gridlines (between date labels)\
    -   Add `expand = c(0,0)` to begin the labels at the first bar\
    -   Use `date_labels =` to specify format of date labels - see the Dates page for tips (use `\n` for a new line)\

-   **If your histogram bins are Sunday weeks**:

    -   Use `breaks =` and `minor_breaks =` by providing a sequence of date breaks for each
    -   You can still use `date_labels =` and `expand =` for formatting as described above

Some notes:

-   See the opening ggplot section for instructions on how to create a sequence of dates using `seq.Date()`.\
-   See [this page](https://rdrr.io/r/base/strptime.html) or the \[Working with dates\] page for tips on creating date labels.

#### Demonstrations {.unnumbered}

Below is a demonstration of plots where the bins and the plot labels/grid lines are aligned and not aligned:

```{r fig.show='hold', class.source = 'fold-hide', warning=F, message=F}
# 7-day bins + Monday labels
#############################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,                 # 7-day bins with start at first case
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),               # remove excess x-axis space below and after case bars
    date_breaks = "3 weeks",       # Monday every 3 weeks
    date_minor_breaks = "week",    # Monday weeks
    date_labels = "%a\n%d\n%b\n'%y")+  # label format
  
  scale_y_continuous(
    expand = c(0,0))+              # remove excess space under x-axis, make flush
  
  labs(
    title = "MISALIGNED",
    subtitle = "! CAUTION: 7-day bars start Thursdays at first case\nDate labels and gridlines on Mondays\nNote how ticks don't align with bars")



# 7-day bins + Months
#####################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),                  # remove excess x-axis space below and after case bars
    date_breaks = "months",           # 1st of month
    date_minor_breaks = "week",       # Monday weeks
    date_labels = "%a\n%d %b\n%Y")+    # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(
    title = "MISALIGNED",
    subtitle = "! CAUTION: 7-day bars start Thursdays with first case\nMajor gridlines and date labels at 1st of each month\nMinor gridlines weekly on Mondays\nNote uneven spacing of some gridlines and ticks unaligned with bars")


# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays
#################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Monday before first case
    breaks = weekly_breaks_central,    # defined earlier in this page
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "4 weeks",           # Monday every 4 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%a\n%d %b\n%Y")+      # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(
    title = "ALIGNED Mondays",
    subtitle = "7-day bins manually set to begin Monday before first case (28 Apr)\nDate labels and gridlines on Mondays as well")


# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:
############################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Monday before first case
    breaks = weekly_breaks_central,            # defined earlier in this page
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "months",            # Monday every 4 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%b\n%Y")+          # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)
          
  labs(
    title = "ALIGNED Mondays with MONTHLY labels",
    subtitle = "7-day bins manually set to begin Monday before first case (28 Apr)\nDate labels on 1st of Month\nMonthly major gridlines removed")


# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays
############################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Sunday before first case
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "7 days"),
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),
    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "3 weeks"),
    
    # minor gridlines set to weekly beginning Sunday before first case
    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                            by   = "7 days"),
    
    date_labels = "%a\n%d\n%b\n'%y")+  # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(title = "ALIGNED Sundays",
       subtitle = "7-day bins manually set to begin Sunday before first case (27 Apr)\nDate labels and gridlines manually set to Sundays as well")

```

### Aggregated data {.unnumbered}

Often instead of a linelist, you begin with aggregated counts from facilities, districts, etc. You can make an epicurve with `ggplot()` but the code will be slightly different. This section will utilize the `count_data` dataset that was imported earlier, in the data preparation section. This dataset is the `linelist` aggregated to day-hospital counts. The first 50 rows are displayed below.

```{r message=FALSE, warning=F, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Plotting daily counts {.unnumbered}

We can plot a daily epicurve from these *daily counts*. Here are the differences to the code:

-   Within the aesthetic mapping `aes()`, specify `y =` as the counts column (in this case, the column name is `n_cases`)
-   Add the argument `stat = "identity"` within `geom_histogram()`, which specifies that bar height should be the `y =` value, not the number of rows as is the default\
-   Add the argument `width =` to avoid vertical white lines between the bars. For daily data set to 1. For weekly count data set to 7. For monthly count data, white lines are an issue (each month has different number of days) - consider transforming your x-axis to a categorical ordered factor (months) and using `geom_col()`.

```{r, message=FALSE, warning=F}
ggplot(data = count_data)+
  geom_histogram(
   mapping = aes(x = date_hospitalisation, y = n_cases),
   stat = "identity",
   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars
  labs(
    x = "Date of report", 
    y = "Number of cases",
    title = "Daily case incidence, from daily count data")
```

#### Plotting weekly counts {.unnumbered}

If your data are already case counts by week, they might look like this dataset (called `count_data_weekly`):

```{r, warning=F, message=F, echo=F}
# Create weekly dataset with epiweek column
count_data_weekly <- count_data %>%
  mutate(epiweek = lubridate::floor_date(date_hospitalisation, "week")) %>% 
  group_by(hospital, epiweek, .drop=F) %>% 
  summarize(n_cases_weekly = sum(n_cases, na.rm=T))   
```

The first 50 rows of `count_data_weekly` are displayed below. You can see that the counts have been aggregated into weeks. Each week is displayed by the first day of the week (Monday by default).

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(count_data_weekly, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Now plot so that `x =` the epiweek column. Remember to add `y =` the counts column to the aesthetic mapping, and add `stat = "identity"` as explained above.

```{r, warning=F, message=F}
ggplot(data = count_data_weekly)+
  
  geom_histogram(
    mapping = aes(
      x = epiweek,           # x-axis is epiweek (as class Date)
      y = n_cases_weekly,    # y-axis height in the weekly case counts
      group = hospital,      # we are grouping the bars and coloring by hospital
      fill = hospital),
    stat = "identity")+      # this is also required when plotting count data
     
  # labels for x-axis
  scale_x_date(
    date_breaks = "2 months",      # labels every 2 months 
    date_minor_breaks = "1 month", # gridlines every month
    date_labels = '%b\n%Y')+       #labeled by month with year below
     
  # Choose color palette (uses RColorBrewer package)
  scale_fill_brewer(palette = "Pastel2")+ 
  
  theme_minimal()+
  
  labs(
    x = "Week of onset", 
    y = "Weekly case incidence",
    fill = "Hospital",
    title = "Weekly case incidence, from aggregated count data by hospital")
```

### Moving averages {.unnumbered}

See the page on [Moving averages] for a detailed description and several options. Below is one option for calculating moving averages with the package **slider**. In this approach, *the moving average is calculated in the dataset prior to plotting*:

1)  Aggregate the data into counts as necessary (daily, weekly, etc.) (see \[Grouping data\] page)\
2)  Create a new column to hold the moving average, created with `slide_index()` from **slider** package\
3)  Plot the moving average as a `geom_line()` on top of (after) the epicurve histogram

See the helpful online [vignette for the **slider** package](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)

```{r, warning=F, message=F}
# load package
pacman::p_load(slider)  # slider used to calculate rolling averages

# make dataset of daily counts and 7-day moving average
#######################################################
ll_counts_7day <- linelist %>%    # begin with linelist
  
  ## count cases by date
  count(date_onset, name = "new_cases") %>%   # name new column with counts as "new_cases"
  drop_na(date_onset) %>%                     # remove cases with missing date_onset
  
  ## calculate the average number of cases in 7-day window
  mutate(
    avg_7day = slider::slide_index(    # create new column
      new_cases,                       # calculate based on value in new_cases column
      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window 
      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed
      .before = 6,                     # window is the day and 6-days before
      .complete = FALSE),              # must be FALSE for unlist() to work in next step
    avg_7day = unlist(avg_7day))       # convert class list to class numeric


# plot
######
ggplot(data = ll_counts_7day) +  # begin with new dataset defined above 
    geom_histogram(              # create epicurve histogram
      mapping = aes(
        x = date_onset,          # date column as x-axis
        y = new_cases),          # height is number of daily new cases
        stat = "identity",       # height is y value
        fill="#92a8d1",          # cool color for bars
        colour = "#92a8d1",      # same color for bar border
        )+ 
    geom_line(                   # make line for rolling average
      mapping = aes(
        x = date_onset,          # date column for x-axis
        y = avg_7day,            # y-value set to rolling average column
        lty = "7-day \nrolling avg"), # name of line in legend
      color="red",               # color of line
      size = 1) +                # width of line
    scale_x_date(                # date scale
      date_breaks = "1 month",
      date_labels = '%d/%m',
      expand = c(0,0)) +
    scale_y_continuous(          # y-axis scale
      expand = c(0,0),
      limits = c(0, NA)) +       
    labs(
      x="",
      y ="Number of confirmed cases",
      fill = "Legend")+ 
    theme_minimal()+
    theme(legend.title = element_blank())  # removes title of legend
```

### Faceting/small-multiples {.unnumbered}

As with other ggplots, you can create facetted plots ("small multiples"). As explained in the \[ggplot tips\] page of this handbook, you can use either `facet_wrap()` or `facet_grid()`. Here we demonstrate with `facet_wrap()`. For epicurves, `facet_wrap()` is typically easier as it is likely that you only need to facet on one column.

The general syntax is `facet_wrap(rows ~ cols)`, where to the left of the tilde (\~) is the name of a column to be spread across the "rows" of the facetted plot, and to the right of the tilde is the name of a column to be spread across the "columns" of the facetted plot. Most simply, just use one column name, to the right of the tilde: `facet_wrap(~age_cat)`.

**Free axes**\
You will need to decide whether the scales of the axes for each facet are "fixed" to the same dimensions (default), or "free" (meaning they will change based on the data within the facet). Do this with the `scales =` argument within `facet_wrap()` by specifying "free_x" or "free_y", or "free".

**Number of cols and rows of facets**\
This can be specified with `ncol =` and `nrow =` within `facet_wrap()`.

**Order of panels**\
To change the order of appearance, change the underlying order of the levels of the factor column used to create the facets.

**Aesthetics**\
Font size and face, strip color, etc. can be modified through `theme()` with arguments like:

-   `strip.text = element_text()` (size, colour, face, angle...)
-   `strip.background = element_rect()` (e.g. element_rect(fill="grey"))\
-   `strip.position =` (position of the strip "bottom", "top", "left", or "right")

**Strip labels**\
Labels of the facet plots can be modified through the "labels" of the column as a factor, or by the use of a "labeller".

Make a labeller like this, using the function `as_labeller()` from **ggplot2**. Then provide the labeller to the `labeller =` argument of `facet_wrap()` as shown below.

```{r, class.source = 'fold-show'}
my_labels <- as_labeller(c(
     "0-4"   = "Ages 0-4",
     "5-9"   = "Ages 5-9",
     "10-14" = "Ages 10-14",
     "15-19" = "Ages 15-19",
     "20-29" = "Ages 20-29",
     "30-49" = "Ages 30-49",
     "50-69" = "Ages 50-69",
     "70+"   = "Over age 70"))
```

**An example facetted plot** - facetted by column `age_cat`.

```{r, warning=F, message=F}
# make plot
###########
ggplot(central_data) + 
  
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),    # arguments inside aes() apply by group
      
    color = "black",      # arguments outside aes() apply to all data
        
    # histogram breaks
    breaks = weekly_breaks_central)+  # pre-defined date vector (see earlier in this page)
                      
  # The labels on the x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "grey"))+         # axis titles in bold
  
  # create facets
  facet_wrap(
    ~age_cat,
    ncol = 4,
    strip.position = "top",
    labeller = my_labels)+             
  
  # labels
  labs(
    title    = "Weekly incidence of cases, by age category",
    subtitle = "Subtitle",
    fill     = "Age category",                                      # provide new title for legend
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

See this [link](https://ggplot2.tidyverse.org/reference/labellers.html) for more information on labellers.

#### Total epidemic in facet background {.unnumbered}

To show the total epidemic in the background of each facet, add the function `gghighlight()` with empty parentheses to the ggplot. This is from the package **gghighlight**. Note that the y-axis maximum in all facets is now based on the peak of the entire epidemic. There are more examples of this package in the \[ggplot tips\] page.

```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # epicurves by group
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),  # arguments inside aes() apply by group
    
    color = "black",    # arguments outside aes() apply to all data
    
    # histogram breaks
    breaks = weekly_breaks_central)+     # pre-defined date vector (see top of ggplot section)                
  
  # add grey epidemic in background to each facet
  gghighlight::gghighlight()+
  
  # labels on x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "white"))+        # axis titles in bold
  
  # create facets
  facet_wrap(
    ~age_cat,                          # each plot is one value of age_cat
    ncol = 4,                          # number of columns
    strip.position = "top",            # position of the facet title/strip
    labeller = my_labels)+             # labeller defines above
  
  # labels
  labs(
    title    = "Weekly incidence of cases, by age category",
    subtitle = "Subtitle",
    fill     = "Age category",                                      # provide new title for legend
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

#### One facet with data {.unnumbered}

If you want to have one facet box that contains all the data, duplicate the entire dataset and treat the duplicates as one faceting value. A "helper" function `CreateAllFacet()` below can assist with this (thanks to this [blog post](https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2)). When it is run, the number of rows doubles and there will be a new column called `facet` in which the duplicated rows will have the value "all", and the original rows have the their original value of the faceting colum. Now you just have to facet on the `facet` column.

Here is the helper function. Run it so that it is available to you.

```{r}
# Define helper function
CreateAllFacet <- function(df, col){
     df$facet <- df[[col]]
     temp <- df
     temp$facet <- "all"
     merged <-rbind(temp, df)
     
     # ensure the facet value is a factor
     merged[[col]] <- as.factor(merged[[col]])
     
     return(merged)
}
```

Now apply the helper function to the dataset, on column `age_cat`:

```{r}
# Create dataset that is duplicated and with new column "facet" to show "all" age categories as another facet level
central_data2 <- CreateAllFacet(central_data, col = "age_cat") %>%
  
  # set factor levels
  mutate(facet = fct_relevel(facet, "all", "0-4", "5-9",
                             "10-14", "15-19", "20-29",
                             "30-49", "50-69", "70+"))

# check levels
table(central_data2$facet, useNA = "always")
```

Notable changes to the `ggplot()` command are:

-   The data used is now central_data2 (double the rows, with new column "facet")
-   Labeller will need to be updated, if used\
-   Optional: to achieve vertically stacked facets: the facet column is moved to rows side of equation and on right is replaced by "." (`facet_wrap(facet~.)`), and `ncol = 1`. You may also need to adjust the width and height of the saved png plot image (see `ggsave()` in \[ggplot tips\]).

```{r, fig.height=12, fig.width=5, warning=F, message=F}
ggplot(central_data2) + 
  
  # actual epicurves by group
  geom_histogram(
        mapping = aes(
          x = date_onset,
          group = age_cat,
          fill = age_cat),  # arguments inside aes() apply by group
        color = "black",    # arguments outside aes() apply to all data
        
        # histogram breaks
        breaks = weekly_breaks_central)+    # pre-defined date vector (see top of ggplot section)
                     
  # Labels on x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom")+               
  
  # create facets
  facet_wrap(facet~. ,                            # each plot is one value of facet
             ncol = 1)+            

  # labels
  labs(title    = "Weekly incidence of cases, by age category",
       subtitle = "Subtitle",
       fill     = "Age category",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

## Tentative data

The most recent data shown in epicurves should often be marked as tentative, or subject to reporting delays. This can be done in by adding a vertical line and/or rectangle over a specified number of days. Here are two options:

1)  Use `annotate()`:

    -   For a line use `annotate(geom = "segment")`. Provide `x`, `xend`, `y`, and `yend`. Adjust size, linetype (`lty`), and color.\
    -   For a rectangle use `annotate(geom = "rect")`. Provide xmin/xmax/ymin/ymax. Adjust color and alpha.\

2)  Group the data by tentative status and color those bars differently

[***CAUTION:*** You might try `geom_rect()` to draw a rectangle, but adjusting the transparency does not work in a linelist context. This function overlays one rectangle for each observation/row!. Use either a very low alpha (e.g. 0.01), or another approach.]{style="color: orange;"}

### Using `annotate()` {.unnumbered}

-   Within `annotate(geom = "rect")`, the `xmin` and `xmax` arguments must be given inputs of class Date.\
-   Note that because these data are aggregated into weekly bars, and the last bar extends to the Monday after the last data point, the shaded region may appear to cover 4 weeks\
-   Here is an `annotate()` [online example](https://ggplot2.tidyverse.org/reference/annotate.html)

```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # histogram
  geom_histogram(
    mapping = aes(x = date_onset),
    
    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section
    
    color = "darkblue",
    
    fill = "lightblue") +

  # scales
  scale_y_continuous(expand = c(0,0))+
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "1 month",           # 1st of month
    date_minor_breaks = "1 month",     # 1st of month
    date_labels = "%b\n'%y")+          # label format
  
  # labels and theme
  labs(
    title = "Using annotate()\nRectangle and line showing that data from last 21-days are tentative",
    x = "Week of symptom onset",
    y = "Weekly case indicence")+ 
  theme_minimal()+
  
  # add semi-transparent red rectangle to tentative data
  annotate(
    "rect",
    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()
    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()
    ymin  = 0,
    ymax  = Inf,
    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()
    fill  = "red")+
  
  # add black vertical line on top of other layers
  annotate(
    "segment",
    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data
    xend  = max(central_data$date_onset, na.rm = T) - 21, 
    y     = 0,         # line begins at y = 0
    yend  = Inf,       # line to top of plot
    size  = 2,         # line size
    color = "black",
    lty   = "solid")+   # linetype e.g. "solid", "dashed"

  # add text in rectangle
  annotate(
    "text",
    x = max(central_data$date_onset, na.rm = T) - 15,
    y = 15,
    label = "Subject to reporting delays",
    angle = 90)
```

The same black vertical line can be achieved with the code below, but using `geom_vline()` you lose the ability to control the height:

```{r, eval=F}
geom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,
           size = 2,
           color = "black")
```

### Bars color {.unnumbered}

An alternative approach could be to adjust the color or display of the tentative bars of data themselves. You could create a new column in the data preparation stage and use it to group the data, such that the `aes(fill = )` of tentative data can be a different color or alpha than the other bars.

```{r, message=F, warning=F}
# add column
############
plot_data <- central_data %>% 
  mutate(tentative = case_when(
    date_onset >= max(date_onset, na.rm=T) - 7 ~ "Tentative", # tenative if in last 7 days
    TRUE                                       ~ "Reliable")) # all else reliable

# plot
######
ggplot(plot_data, aes(x = date_onset, fill = tentative)) + 
  
  # histogram
  geom_histogram(
    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page
    color = "black") +

  # scales
  scale_y_continuous(expand = c(0,0))+
  scale_fill_manual(values = c("lightblue", "grey"))+
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "3 weeks",           # Monday every 3 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%d\n%b\n'%y")+      # label format
  
  # labels and theme
  labs(title = "Show days that are tentative reporting",
    subtitle = "")+ 
  theme_minimal()+
  theme(legend.title = element_blank())                 # remove title of legend
  
```

## Multi-level date labels

If you want multi-level date labels (e.g. month and year) *without duplicating the lower label levels*, consider one of the approaches below:

Remember - you can can use tools like `\n` *within* the `date_labels` or `labels` arguments to put parts of each label on a new line below. However, the code below helps you take years or months (for example) on a lower line *and only once*. A few notes on the code below:

-   Case counts are aggregated into weeks for aesthetic reasons. See Epicurves page (aggregated data tab) for details.\
-   A `geom_area()` line is used instead of a histogram, as the faceting approach below does not work well with histograms.

**Aggregate to weekly counts**

```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}

# Create dataset of case counts by week
#######################################
central_weekly <- linelist %>%
  filter(hospital == "Central Hospital") %>%   # filter linelist
  mutate(week = lubridate::floor_date(date_onset, unit = "weeks")) %>%  
  count(week) %>%                              # summarize weekly case counts
  drop_na(week) %>%                            # remove cases with missing onset_date
  complete(                                    # fill-in all weeks with no cases reported
    week = seq.Date(
      from = min(week),   
      to   = max(week),
      by   = "week"),
    fill = list(n = 0))                        # convert new NA values to 0 counts
```

**Make plots**

```{r, warning=F, message=F}
# plot with box border on year
##############################
ggplot(central_weekly) +
  geom_area(aes(x = week, y = n),    # make line, specify x and y
            stat = "identity") +             # because line height is count number
  scale_x_date(date_labels="%b",             # date label format show month 
               date_breaks="month",          # date labels on 1st of each month
               expand=c(0,0)) +              # remove excess space on each end
  scale_y_continuous(
    expand  = c(0,0))+                       # remove excess space below x-axis
  facet_grid(~lubridate::year(week), # facet on year (of Date class column)
             space="free_x",                
             scales="free_x",                # x-axes adapt to data range (not "fixed")
             switch="x") +                   # facet labels (year) on bottom
  theme_bw() +
  theme(strip.placement = "outside",         # facet labels placement
        strip.background = element_rect(fill = NA, # facet labels no fill grey border
                                        colour = "grey50"),
        panel.spacing = unit(0, "cm"))+      # no space between facet panels
  labs(title = "Nested year labels, grey label border")


# plot with no box border on year
#################################
ggplot(central_weekly,
       aes(x = week, y = n)) +              # establish x and y for entire plot
  geom_line(stat = "identity",              # make line, line height is count number
            color = "#69b3a2") +            # line color
  geom_point(size=1, color="#69b3a2") +     # make points at the weekly data points
  geom_area(fill = "#69b3a2",               # fill area below line
            alpha = 0.4)+                   # fill transparency
  scale_x_date(date_labels="%b",            # date label format show month 
               date_breaks="month",         # date labels on 1st of each month
               expand=c(0,0)) +             # remove excess space
  scale_y_continuous(
    expand  = c(0,0))+                      # remove excess space below x-axis
  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)
             space="free_x",                
             scales="free_x",               # x-axes adapt to data range (not "fixed")
             switch="x") +                  # facet labels (year) on bottom
  theme_bw() +
  theme(strip.placement = "outside",                     # facet label placement
          strip.background = element_blank(),            # no facet lable background
          panel.grid.minor.x = element_blank(),          
          panel.border = element_rect(colour="grey40"),  # grey border to facet PANEL
          panel.spacing=unit(0,"cm"))+                   # No space between facet panels
  labs(title = "Nested year labels - points, shaded, no label border")
```

The above techniques were adapted from [this](https://stackoverflow.com/questions/44616530/axis-labels-on-two-lines-with-nested-x-variables-year-below-months) and [this](https://stackoverflow.com/questions/20571306/multi-row-x-axis-labels-in-ggplot-line-chart) post on stackoverflow.com.

<!-- ======================================================= -->

## Dual-axis

Although there are fierce discussions about the validity of dual axes within the data visualization community, many epi supervisors still want to see an epicurve or similar chart with a percent overlaid with a second axis. This is discussed more extensively in the \[ggplot tips\] page, but one example using the **cowplot** method is shown below:

-   Two distinct plots are made, and then combined with **cowplot** package.\
-   The plots must have the exact same x-axis (set limits) or else the data and labels will not align\
-   Each uses `theme_cowplot()` and one has the y-axis moved to the right side of the plot

```{r, warning=F, message=F}
#load package
pacman::p_load(cowplot)

# Make first plot of epicurve histogram
#######################################
plot_cases <- linelist %>% 
  
  # plot cases per week
  ggplot()+
  
  # create histogram  
  geom_histogram(
    
    mapping = aes(x = date_onset),
    
    # bin breaks every week beginning monday before first case, going to monday after last case
    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)
        
  # specify beginning and end of date axis to align with other plot
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram
  
  # labels
  labs(
      y = "Daily cases",
      x = "Date of symptom onset"
    )+
  theme_cowplot()


# make second plot of percent died per week
###########################################
plot_deaths <- linelist %>%                        # begin with linelist
  group_by(week = floor_date(date_onset, "week")) %>%  # create week column
  
  # summarise to get weekly percent of cases who died
  summarise(n_cases = n(),
            died = sum(outcome == "Death", na.rm=T),
            pct_died = 100*died/n_cases) %>% 
  
  # begin plot
  ggplot()+
  
  # line of weekly percent who died
  geom_line(                                # create line of percent died
    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column
    stat = "identity",                      # set line height to the value in pct_death column, not the number of rows (which is default)
    size = 2,
    color = "black")+
  
  # Same date-axis limits as the other plot - perfect alignment
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram
  
  
  # y-axis adjustments
  scale_y_continuous(                # adjust y-axis
    breaks = seq(0,100, 10),         # set break intervals of percent axis
    limits = c(0, 100),              # set extent of percent axis
    position = "right")+             # move percent axis to the right
  
  # Y-axis label, no x-axis label
  labs(x = "",
       y = "Percent deceased")+      # percent axis label
  
  theme_cowplot()                   # add this to make the two plots merge together nicely
```

Now use **cowplot** to overlay the two plots. Attention has been paid to the x-axis alignment, side of the y-axis, and use of `theme_cowplot()`.

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```

## Cumulative Incidence

Note: If using **incidence2**, see the section on how you can produce cumulative incidence with a simple function. This page will address how to calculate cumulative incidence and plot it with `ggplot()`.

If beginning with a case linelist, create a new column containing the cumulative number of cases per day in an outbreak using `cumsum()` from **base** R:

```{r}
cumulative_case_counts <- linelist %>% 
  count(date_onset) %>%                # count of rows per day (returned in column "n")   
  mutate(                         
    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date
    )
```

The first 10 rows are shown below:

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(cumulative_case_counts, 10), rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

This cumulative column can then be plotted against `date_onset`, using `geom_line()`:

```{r, warning=F, message=F}
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")

plot_cumulative
```

It can also be overlaid onto the epicurve, with dual-axis using the **cowplot** method described above and in the \[ggplot tips\] page:

```{r, warning=F, message=F}
#load package
pacman::p_load(cowplot)

# Make first plot of epicurve histogram
plot_cases <- ggplot()+
  geom_histogram(          
    data = linelist,
    aes(x = date_onset),
    binwidth = 1)+
  labs(
    y = "Daily cases",
    x = "Date of symptom onset"
  )+
  theme_cowplot()

# make second plot of cumulative cases line
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")+
  scale_y_continuous(
    position = "right")+
  labs(x = "",
       y = "Cumulative cases")+
  theme_cowplot()+
  theme(
    axis.line.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks = element_blank())
```

Now use **cowplot** to overlay the two plots. Attention has been paid to the x-axis alignment, side of the y-axis, and use of `theme_cowplot()`.

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```

<!-- ======================================================= -->

## Resources

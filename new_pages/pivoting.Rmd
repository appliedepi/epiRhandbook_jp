<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

# データの縦横変換 {#pivoting}

```{r, warning=F, message=F, out.height = c('50%'), fig.align="center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pivoting", "Pivoting_500x500.png"))

#knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_bar.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

データを管理する上で、[ピボットする]{.ul}とは次の2つの工程のどちらかを指しています。

1.  [ピボットテーブル]{.ul}（より大きなテーブルデータを要約した統計表）を作成すること。
2.  表を縦長形式から横長形式へ、またはその逆へ変換すること。

**このページでは、後者の定義に焦点をあてます。**前者はデータ解析の重要なステップであり、[データのグループ化](#grouping)および[記述統計表の作り方](#tables-descriptive)のページで別に取り上げています。

このページでは、データの形式について説明します。個々の変数が 1 つの列を持ち、個々の観測が 1 つの行を持ち、個々の値が 1 つのセルを持つという「整然データ」の考え方を知っておくと便利です。このトピックについて詳しくは、[R for Data Scienceの章](https://r4ds.had.co.nz/tidy-data.html)を参照してください。

## 準備

### パッケージの読み込み {.unnumbered}

このコードチャンクは、解析に必要なパッケージの読み込みを示しています。このハンドブックでは **pacman** の `p_load()` を強調し、必要ならパッケージをインストールのうえ使用するためにロードします。インストールされたパッケージは **base** R から `library()` でロードすることもできます。R のパッケージについて詳しくは [R の基礎](#basics) のページを参照してください。

```{r}
pacman::p_load(
  rio,          # ファイルのインポートする
  here,         # ファイルの場所を指定する
  tidyverse)    # データ管理とggplot2を使用したデータ可視化のパッケージ
```

### データのインポート {.unnumbered}

### マラリア発症数のデータ {.unnumbered}

このページでは、毎日のマラリア発症について、施設別、年齢層別の架空のデータセットを使用します。続いて、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_facility_count_data.rds' class='download-button'>ここをクリックしてダウンロードしてください（rdsファイル）<span></a>。**rio** パッケージの `import()` 関数でデータをインポートします (これは .xlsx, .csv, .rds など多くの種類のファイルを扱えます - 詳しくは [データのインポート・エクスポート](#importing) ページを参照してください)。

```{r, echo=F}
count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()
```

```{r, eval=F}
# データをインポートする
count_data <- import("malaria_facility_count_data.rds")
```

最初の 50 行が以下に表示されます。

```{r, message=FALSE, echo=F}
# ラインリストデータを表形式で表示する
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### 発症数データのラインリスト

このページの後半では、エボラ出血熱の流行をシミュレーションした発症数のデータセットも使用する予定です。これを実行したい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>クリックして「きれいな」ラインリストをダウンロードしてください（rds ファイル）。**rio** パッケージの `import()` 関数でデータをインポートします (これは .xlsx, .rds, .csv など多くのファイル形式を扱うことができます - 詳しくは [データのインポート・エクスポート](#importing) ページを参照)。

```{r, echo=F}
# Rにラインリストをインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# データセットをインポートする
linelist <- import("linelist_cleaned.xlsx")
```

<!-- ======================================================= -->

## 横長から縦長へ

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```

<!-- ======================================================= -->

### 「横長」形式

データは「横長」形式で入力・保存されることがよくあります。つまり、被験者の特性や回答が1つの行に保存されるのです。これはプレゼンテーションには便利かもしれませんが、1 部の分析には適していません。

上記の準備の章でインポートした `count_data` のデータセットを例にとってみましょう。各行が「施設利用日」を表していることがわかります。実際の発症数（一番右の列）は「横長」形式で格納されており、ある施設利用日のすべての年齢層の情報が一行に格納されています。

```{r, echo=F}
DT::datatable(count_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T) )
```

このデータセットのそれぞれの観測値は、与えられた日付の `count_data$data_date %>% min()` から `count_data$data_date %>% max()` までの 65 施設のうちの 1 施設におけるマラリアの発症数を指しています。これらの施設は、1 つの`Province`（North）と4つの`District`（Spring、Bolo、Dingo、Barnard）に位置している。このデータセットでは、マラリアの全体の発症数と、3 つの年齢層（ 4 歳未満、5 ～ 14 歳、15 歳以上）におけるマラリアの発症数が与えられています。\\

このような「横長」データは、列見出しが実際には「変数」を表しておらず、仮想的な「年齢層」の[値]{.ul}を表しているため、「整然データ」の基準に従っているとは言えません。\\

この形式は、情報を表で表示したり、症例報告書からデータを入力（ Excel など）する際に便利です。しかし、解析段階では、これらのデータは通常、「整然データ」基準に沿った「縦長」形式に変換した方が良いです。特に R パッケージの **ggplot2** は、データが 「縦長」形式である場合に最適に機能します。

マラリアの[総]{.ul}発症数を時系列で視覚化することは、現在のデータ形式では難しくありません。

```{r, warning=F, message=F}
ggplot(count_data) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

しかし、この総発症数に対する各年齢層の相対的な寄与を表示したいとしたらどうでしょうか。この場合、`{ggplot2}` の「マッピングと見栄え」を指定する`aes()` 引数に渡すことができる単一の列で、関心のある変数（年齢層）がデータセットに表示されていることを確認する必要があります。

<!-- ======================================================= -->

### `pivot_longer()` {.unnumbered}

**tidyr** の関数 `pivot_longer()` は、データを「長く」します。**tidyr** は、R パッケージの**tidyverse** の一部です。

それは、変換する列の範囲（ `= cols` に指定）を受け取ります。したがって、それはデータセットの 1 部だけで操作することができます。これは、発症数の列だけを縦横変換したいので、マラリアのデータには適しています。

この処理では、2 つの「新しい」列が作成されます。1 つはカテゴリ (以前の列名) で、もう 1 つは対応する値 (例: 発症数) で構成されます。これらの新しい列の名前は、既定のままでも構いませんが、`names_to =` および `values_to =` を用いて独自のを指定することもできます。

それでは、`pivot_longer()` を実際に動かしてみましょう...。

### 標準的な縦横変換

**tidyr** の `pivot_longer()` 関数を使用して、「横長」データを 「縦長」 形式に変換したいと思います。具体的には、マラリアの発症数のデータを持つ4つの数値列を、[年齢層]{.ul}を保持する列と対応する[値]{.ul}を保持する列の2つの新しい列に変換します。

```{r, eval=F}
df_long <- count_data %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

新しく作成されたデータフレーム（ `df_long` ）は行数が増え（ 12,152 vs 3,038 ）、[長く]{.ul}なっていることに注目してください。実際、それは正確に 4 倍の長さです。なぜなら、オリジナルのデータセットの各行が、df_long の 4 行を表し、マラリア発症数の観測値（4 歳未満、5 ～ 14 歳、15 歳以上、総数）のそれぞれについて 1 行ずつだからです。\\

長くなっただけでなく、新しいデータセットでは列数が 8 から 10 に減っています。以前は 4 つの列（ `malaria_` で始まる列）に格納されていたデータが、現在は 2 つの列に格納されているからです。\\

これらの 4 つの列の列名はすべて `malaria_` で始まるので、便利な「 tidyselect 」関数 `starts_with()` を使って同じ結果を得ることができました（これらのヘルパ関数については、[データクリーニングと主要関数](#cleaning)のページを参照してください）。

```{r}
# tidyselectのヘルパ関数で列を指定する
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

位置による指定

```{r, eval=F}
# 位置で列を指定する
count_data %>% 
  pivot_longer(
    cols = 6:9
  )
```

列名の範囲による指定

```{r, eval=F}
# 連続する列の範囲を指定する
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```

この2つの新しい列には `name` と `value` という既定の列名が与えられていますが、`names_to` と `values_to` という引数を使えば、これらを上書きして、より意味のある列名を付けることができますし、中に何が格納されているかを思い出すのに便利です。`age_group` と `counts` という列名を使ってみましょう。

```{r}
df_long <- 
  count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )

df_long
```

この新しいデータセットを `{ggplot2}` に渡して、新しい列 `count` を Y 軸に、新しい列 `age_group` を `fill =` 引数（列の色）に対応させることができます。これは、年齢層ごとに積み上げられた棒グラフでマラリアの発症数を表示します。

```{r, warning=F, message=F}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

この新しいプロットと先ほど作ったプロットを比較してみてください。[問題点に気づきましたか？]{.ul}

調査データを扱うときによくある問題に遭遇しました - `malaria_tot` 列からの総数も含まれているので、プロットの各棒の大きさは、あるべき大きさの2倍になっています。

この問題はいくつかの方法で対処することができます。`ggplot()` に渡す前に、データセットからこれらの総数を単純に抽出することができます。

```{r, warning=F, message=F}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

また、`pivot_longer()` を実行する際にこの変数を除外することで、別の変数としてデータセットに保持することも可能です。新しい行を埋めるために、この変数の値がどのように「拡張」されるかを見てみましょう。

```{r, warning=F, message=F}
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # 総数の列は含まない
    names_to = "age_group",
    values_to = "counts"
  )
```

### 複数クラスのデータのピボット

上記の例は、「縦長変換する」列がすべて同じクラス（文字列、数値、論理など）である場合にうまく機能します。\\

しかし、疫学者の領域では、非専門家によって作成され、独自の標準的ではない論理に従ったデータを扱う場合が多くあります。Hadley Wickham は、**Tidy Data** の原則に関する彼の[重要な論文](https://vita.had.co.nz/papers/tidy-data.pdf)（トルストイを参照）で次のように指摘しています。「家族のように、整然データセットはどれも似ているが、乱雑なデータセットは乱雑のあり方がそれぞれ異なっている。」\\

特によくある問題は、異なるクラスのデータを含む列を縦横変換する必要があることです。この縦横変換では、これらの異なるデータ型を 1 つの列に格納することになりますが、これは良い状況ではありません。このような混乱を回避するために、さまざまなアプローチがありますが、`pivot_longer()` を使用して、自分でこのような状況を作らないようにするための重要なステップがあります。\\

3つの項目 A , B , C のそれぞれについて、異なる時点で時系列による観測が行われた状況を考えてみましょう。例えば、個人（例えば、エボラ出血熱患者の接触者を21日間毎日追跡する）や、遠隔地の村のヘルスポストがまだ機能しているかどうか年に1回確認することなどが挙げられます。接触者追跡の例を使ってみましょう。データが以下のように保存されているとします。

```{r, message=FALSE, echo=F}

df <- 
  tibble::tribble(
     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,
     "A", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",     "Unwell",
     "B", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy",
     "C", "2021-04-23",    "Missing", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy"
     ) 

DT::datatable(df, rownames = FALSE)

```

見ての通り、少し複雑なデータになっています。各行には 1 つの項目に関する情報が格納されていますが、時間が進むにつれて時系列がどんどん右に流れています。さらに、列のクラスは日付と文字列の値が交互に並んでいます。\\

筆者が遭遇した特にひどい例は、コレラの調査データで、**4 年間**[毎日]{.ul}8列の新しい観測値が追加されたものであった。筆者のノートパソコンでは、このデータが保存されている Excel ファイルを開くだけで 10 分以上かかった！\\

これらのデータを扱うには、データフレームを縦長形式に変換する必要がありますが、各項目の観測ごとに、`data` 列と `character` （ステータス）列の分離を維持する必要があります。そうしないと、1 つの列の中に変数の種類が混在してしまう可能性があります（データ管理や整然データにおいて、非常に大きな「やってはいけないこと」です）。

```{r}
df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation")
  )

```

Above, our pivot has merged *dates* and *characters* into a single `value` column. R will react by converting the entire column to class character, and the utility of the dates is lost.

To prevent this situation, we can take advantage of the syntax structure of the original column names. There is a common naming structure, with the observation number, an underscore, and then either "status" or "date". We can leverage this syntax to keep these two data types in separate columns after the pivot.

We do this by:

-   Providing a character vector to the `names_to =` argument, with the second item being (`".value"` ). This special term indicates that the pivoted columns will be split based on a character in their name...\
-   You must also provide the "splitting" character to the `names_sep =` argument. In this case, it is the underscore "\_".

Thus, the naming and split of new columns is based around the underscore in the existing variable names.

上記では、ピボットによって日付と文字が1つの列の`value`に統合されています。R は列全体をクラス文字に変換することで対応し、日付の実用性が失われます。

このような事態を防ぐには、元の列名の構文構造を利用します。観察番号、アンダースコア、そして "status "または "date "のいずれかを含む共通の命名構造が存在します。この構文を利用して、ピボット後にこれら 2 つのデータ型を別の列に保持することができます。

これを行うには、以下のようにします。

-   `names_to =` 引数に文字ベクトルを指定し、2番目の項目に (`".value"`) を指定する。この特別な用語は、回転した列がその名前に含まれる文字に基づいて分割されることを示します...

-   また、`names_sep =` の引数には、「分割」する文字を指定する必要があります。この場合、アンダースコア"\_"である。

このように、新しい列の命名と分割は、既存の列名のアンダースコア"\_"を中心に行われる。

```{r}

df_long <- 
  df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation", ".value"),
    names_sep = "_"
  )

df_long

```

**Finishing touches**:

**仕上げに**

Note that the `date` column is currently in *character* class - we can easily convert this into it's proper date class using the `mutate()` and `as_date()` functions described in the [Working with dates] page.

We may also want to convert the `observation` column to a `numeric` format by dropping the "obs" prefix and converting to numeric. We cando this with `str_remove_all()` from the **stringr** package (see the [Characters and strings] page).

`date`列は現在文字クラスであることに注意してください。日付の操作のページで説明した `mutate()` と `as_date()` 関数を使用すれば、これを適切な日付クラスに簡単に変換できます。

"obs" というプレフィックスを削除して数値形式に変換することで、 `observation`列も`numeric`形式に変換できます。これは**stringr**パッケージの`str_remove_all()`を使って行うことができます([文字列型データ]のページを参照してください)。

```{r}

df_long <- 
  df_long %>% 
  mutate(
    date = date %>% lubridate::as_date(),
    observation = 
      observation %>% 
      str_remove_all("obs") %>% 
      as.numeric()
  )

df_long

```

And now, we can start to work with the data in this format, e.g. by plotting a descriptive heat tile:

そして、この形式のデータを使って、例えば、記述的なヒートタイルをプロットするなどの作業を開始することができます。

```{r}
ggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +
  geom_tile(colour = "black") +
  scale_fill_manual(
    values = 
      c("Healthy" = "lightgreen", 
        "Unwell" = "red", 
        "Missing" = "orange")
  )

```

<!-- ======================================================= -->

## Long-to-wide

## ロングからワイドへ

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

In some instances, we may wish to convert a dataset to a wider format. For this, we can use the `pivot_wider()` function.

A typical use-case is when we want to transform the results of an analysis into a format which is more digestible for the reader (such as a [Table for presentation][Tables for presentation]). Usually, this involves transforming a dataset in which information for one subject is are spread over multiple rows into a format in which that information is stored in a single row.

場合によっては、データセットをより広いフォーマットに変換したいことがあります。このような場合は、`pivot_wider()`関数を使用します。

典型的な使用例としては、分析結果を読み手にとって理解しやすい形式（[プレゼンテーション用の表]など）に変換する場合です。通常は、1 つの主題に関する情報が複数の行にまたがっているデータセットを、その情報が 1 つの行に格納される形式に変換することが必要です。

### Data {.unnumbered}

### データ {.unnumbered}

For this section of the page, we will use the case linelist (see the [Preparation](#pivot_prep) section), which contains one row per case.

Here are the first 50 rows:

この章では、1つの症例につき1行が含まれる症例ラインリスト（[準備](#pivot_prep)の章を参照）を使用することにします。

ここでは、最初の50行を示します。

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Suppose that we want to know the counts of individuals in the different age groups, by gender: 例えば、男女別の年齢層別の個体数を知りたいとします。

```{r}
df_wide <- 
  linelist %>% 
  count(age_cat, gender)

df_wide
```

This gives us a long dataset that is great for producing visualisations in **ggplot2**, but not ideal for presentation in a table: これは長いデータセットで、**ggplot2**での視覚化には最適ですが、表での表示には適していません。

```{r}
ggplot(df_wide) +
  geom_col(aes(x = age_cat, y = n, fill = gender))
```

### Pivot wider {.unnumbered}

Therefore, we can use `pivot_wider()` to transform the data into a better format for inclusion as tables in our reports.

The argument `names_from` specifies the column *from* which to generate the new column *names*, while the argument `values_from` specifies the column *from* which to take the *values* to populate the cells. The argument `id_cols =` is optional, but can be provided a vector of column names that should not be pivoted, and will thus identify each row.

したがって、`pivot_wider()` を使用して、データを報告書の表として含めるためのより良い形式に変換することができます。\
引数 `names_from` は、新しい*列名*を生成する*ための*列を指定し、引数 `values_from` は、セルに入力する*値*を取得する*ための*列を指定します。`id_cols =` はオプションですが、ピボット化されるべきでない列名のベクトルを提供することができ、それによって各行を識別することができます。

```{r}
table_wide <- 
  df_wide %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = n
  )

table_wide
```

This table is much more reader-friendly, and therefore better for inclusion in our reports. You can convert into a pretty table with several packages including **flextable** and **knitr**. This process is elaborated in the page [Tables for presentation]. この表は、より読みやすいので、報告書に掲載するのに適しています。**flextable**や**knitr**を含むいくつかのパッケージできれいな表に変換することができます。この作業は、[見やすい表の作り方]のページで詳しく説明されています。

```{r}
table_wide %>% 
  janitor::adorn_totals(c("row", "col")) %>% # adds row and column totals
  knitr::kable() %>% 
  kableExtra::row_spec(row = 10, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

------------------------------------------------------------------------

<!-- ======================================================= -->

## Fill

In some situations after a `pivot`, and more commonly after a `bind`, we are left with gaps in some cells that we would like to fill. `pivot`の後、そしてより一般的には`bind`の後、いくつかのセルに隙間ができてしまい、それを埋めたいと思うことがあります。 <!-- ======================================================= -->

### Data {.unnumbered}

### データ {.unnumbered}

For example, take two datasets, each with observations for the measurement number, the name of the facility, and the case count at that time. However, the second dataset also has a variable `Year`. 例えば、2つのデータセットがあり、それぞれ測定番号、施設名、その時点の症例数の観測値があるとします。しかし、2番目のデータセットには変数`Year`もあります。

```{r}
df1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

df1 

df2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

df2
```

When we perform a `bind_rows()` to join the two datasets together, the `Year` variable is filled with `NA` for those rows where there was no prior information (i.e. the first dataset): `bind_rows()`で2つのデータセットを結合すると、事前情報がない行（つまり最初のデータセット）については、`Year`変数が`NA`で埋められる。

```{r}
df_combined <- 
  bind_rows(df1, df2) %>% 
  arrange(Measurement, Facility)

df_combined

```

<!-- ======================================================= -->

### `fill()` {.unnumbered}

In this case, `Year` is a useful variable to include, particularly if we want to explore trends over time. Therefore, we use `fill()` to *fill* in those empty cells, by specifying the column to fill and the direction (in this case **up**): この場合、`Year`は特に時間的な傾向を調べるのに有効な変数である。したがって、塗りつぶす列と方向 (この場合は**上**) を指定して、空のセルを*塗りつぶす*ために `fill()` を使用します。

```{r}
df_combined %>% 
  fill(Year, .direction = "up")
```

Alternatively, we can rearrange the data so that we would need to fill in a downward direction: あるいは、下方向に塗りつぶす必要があるように、データを並べ替えることもできる。

```{r}
df_combined <- 
  df_combined %>% 
  arrange(Measurement, desc(Facility))

df_combined

df_combined <- 
  df_combined %>% 
  fill(Year, .direction = "down")

df_combined
```

We now have a useful dataset for plotting: これで、プロットするのに便利なデータセットができました。

```{r}
ggplot(df_combined) +
  aes(Year, Cases, fill = Facility) +
  geom_col()
```

But less useful for presenting in a table, so let's practice converting this long, untidy dataframe into a wider, tidy dataframe: そこで、この長くて整頓されていないデータフレームを、より広くて整頓されたデータフレームに変換する練習をしてみましょう。

```{r}
df_combined %>% 
  pivot_wider(
    id_cols = c(Facility, Year, Cases),
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  arrange(Facility) %>% 
  janitor::adorn_totals(c("row", "col")) %>% 
  knitr::kable() %>% 
  kableExtra::row_spec(row = 5, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

N.B. In this case, we had to specify to only include the three variables `Facility`, `Year`, and `Cases` as the additional variable `Measurement` would interfere with the creation of the table: 注）この場合、変数`Measurement`を追加すると表の作成に支障が出るため、`Facility`、`Year`、`Cases`の3つの変数のみを含めるように指定する必要がありました。

```{r}
df_combined %>% 
  pivot_wider(
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  knitr::kable()
```

## Resources

Here is a helpful [tutorial](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html) 役に立つ[チュートリアル](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)はこちら

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

# Pivoting data

# 12 データの縦横変換

```{r, warning=F, message=F, out.height = c('50%'), fig.align="center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pivoting", "Pivoting_500x500.png"))

#knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_bar.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

When managing data, *pivoting* can be understood to refer to one of two processes:

1.  The creation of *pivot tables*, which are tables of statistics that summarise the data of a more extensive table\
2.  The conversion of a table from **long** to **wide** format, or vice versa.

**In this page, we will focus on the latter definition.** The former is a crucial step in data analysis, and is covered elsewhere in the [Grouping data] and [Descriptive tables] pages.

This page discusses the formats of data. It is useful to be aware of the idea of "tidy data", in which each variable has it's own column, each observation has it's own row, and each value has it's own cell. More about this topic can be found [at this online chapter in R for Data Science](https://r4ds.had.co.nz/tidy-data.html).

データを管理する上で、[データの縦横変換（ピボット）]とは次の2つのプロセスのいずれかを指しています。

1.  [ピボットテーブル]（より大きなテーブルデータを要約した統計表）を作成すること。\
2.  表を**ロング**形式から**ワイド**形式へ、またはその逆へ変換すること。

**このページでは、後者の定義に焦点を当てます。**前者はデータ解析の重要なステップであり、[データのグループ化]および[記述統計表]のページで別に取り上げています。\
このページでは、データのフォーマットについて説明します。各変数がそれぞれ列を持ち、各観測値がそれぞれ行を持ち、各値がそれぞれセルを持つという「整頓されたデータ」の考え方を知っておくと便利です。このトピックについて詳しくは、[R for Data Scienceの章](https://r4ds.had.co.nz/tidy-data.html).を参照してください。

## Preparation

## 12.1 準備

### Load packages {.unnumbered}

### パッケージの読み込み {.unnumbered}

This code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with `library()` from **base** R. See the page on [R basics] for more information on R packages.

----------andの斜体をどこにあてるか

このコードチャンクは、解析に必要なパッケージの読み込みを示しています。このハンドブックでは **pacman** の `p_load()` を強調し、必要ならパッケージをインストールし、使用するためにロードします。インストールされたパッケージは **base** R から `library()` でロードすることもできます。R のパッケージについて詳しくは [R の基礎] のページを参照してください。

```{r}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  tidyverse)    # data management + ggplot2 graphics
```

### Import data {.unnumbered}

### データのインポート {.unnumbered}

### Malaria count data {.unnumbered}

### マラリア発生数のデータ {.unnumbered}

In this page, we will use a fictional dataset of daily malaria cases, by facility and age group. If you want to follow along, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_facility_count_data.rds' class='download-button'>click here to download (as .rds file)<span></a>. Import data with the `import()` function from the **rio** package (it handles many file types like .xlsx, .csv, .rds - see the [Import and export] page for details).

このページでは、毎日のマラリア症例について、施設別、年齢層別の架空のデータセットを使用することにします。続いて、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_facility_count_data.rds' class='download-button'>ここをクリックしてダウンロードしてください（rdsファイルです）<span></a>。**rio** パッケージの `import()` 関数でデータをインポートします (これは .xlsx, .csv, .rds など多くの種類のファイルを扱えます - 詳しくは [Import and export] ページを参照してください)。

```{r, echo=F}
count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()
```

```{r, eval=F}
# Import data
count_data <- import("malaria_facility_count_data.rds")
```

The first 50 rows are displayed below.

最初の50行が以下に表示されます。

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist case data {.unnumbered}

### ラインリスト症例データ

In the later part of this page, we will also use the dataset of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the "clean" linelist</a> (as .rds file). Import your data with the `import()` function from the **rio** package (it accepts many file types like .xlsx, .rds, .csv - see the [Import and export] page for details).

このページの後半では、エボラ出血熱の流行をシミュレーションした症例のデータセットも使用する予定です。もし、これに従いたいなら、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>クリックして「きれいな」ラインリストをダウンロードする（rds ファイルです）。**rio** パッケージの `import()` 関数でデータをインポートする (これは .xlsx, .rds, .csv など多くのファイル形式を受け付ける - 詳しくは [データのインポートとエクスポート] ページを参照)。

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import your dataset
linelist <- import("linelist_cleaned.xlsx")
```

<!-- ======================================================= -->

## Wide-to-long

## ワイドからロングへ

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```

<!-- ======================================================= -->

### "Wide" format {.unnumbered}

### ワイドのフォーマット

Data are often entered and stored in a "wide" format - where a subject's characteristics or responses are stored in a single row. While this may be useful for presentation, it is not ideal for some types of analysis.

Let us take the `count_data` dataset imported in the Preparation section above as an example. You can see that each row represents a "facility-day". The actual case counts (the right-most columns) are stored in a "wide" format such that the information for every age group on a given facility-day is stored in a single row.

データはしばしば「ワイド」フォーマットで入力・保存されます。つまり、被験者の特性や回答が1つの行に保存されるのです。これはプレゼンテーションには便利かもしれませんが、ある種の分析には理想的ではありません。

上記の準備の章でインポートした `count_data` データセットを例にとってみましょう。各行が「施設日」を表していることがわかります。実際の症例数（一番右の列）は「ワイド」形式で格納されており、ある施設日のすべての年齢層の情報が一行に格納されています。

```{r, echo=F}
DT::datatable(count_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T) )
```

Each observation in this dataset refers to the malaria counts at one of 65 facilities on a given date, ranging from `count_data$data_date %>% min()` to `count_data$data_date %>% max()`. These facilities are located in one `Province` (North) and four `District`s (Spring, Bolo, Dingo, and Barnard). The dataset provides the overall counts of malaria, as well as age-specific counts in each of three age groups - \<4 years, 5-14 years, and 15 years and older.

"Wide" data like this are not adhering to "tidy data" standards, because the column headers do not actually represent "variables" - they represent *values* of a hypothetical "age group" variable.

This format can be useful for presenting the information in a table, or for entering data (e.g. in Excel) from case report forms. However, in the analysis stage, these data typically should be transformed to a "longer" format more aligned with "tidy data" standards. The plotting R package **ggplot2** in particular works best when data are in a "long" format.

Visualising the *total* malaria counts over time poses no difficulty with the data in it's current format:

このデータセットの各オブザベーションは、与えられた日付の、`count_data$data_date %>% min()` から `count_data$data_date %>% max()` までの65施設の一つにおけるマラリアカウントを指しています。これらの施設は、1つの`Province`（North）と4つの`District`（Spring、Bolo、Dingo、Barnard）に位置している。このデータセットでは、マラリア全体のカウントと、3つの年齢グループ（4歳未満、5～14歳、15歳以上）のそれぞれにおける年齢別のカウントが提供されています。\\

このような「ワイド」データは、列見出しが実際には「変数」を表しておらず、仮想的な「年齢層」変数の値を表しているため、「整頓されたデータ」の基準に従っているとは言えません。\\

このフォーマットは、情報を表で表示したり、症例報告書からデータを入力（Excelなど）する際に便利である。しかし、解析段階では、これらのデータは通常、「整頓されたデータ」基準に沿った「長い」形式に変換した方が良いです。特にRパッケージのggplot2は、データが "long "フォーマットである場合に最適に機能します。

マラリアの総計を時系列で視覚化することは、現在のデータ形式では困難ではありません。

```{r, warning=F, message=F}
ggplot(count_data) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

However, what if we wanted to display the relative contributions of each age group to this total count? In this case, we need to ensure that the variable of interest (age group), appears in the dataset in a single column that can be passed to `{ggplot2}`'s "mapping aesthetics" `aes()` argument.

しかし、この総数に対する各年齢層の相対的な寄与を表示したいとしたらどうだろうか。この場合、`{ggplot2}`の「マッピングの美学」`aes()`引数に渡すことができる単一の列で、関心のある変数（年齢層）がデータセットに表示されていることを確認する必要があります。

<!-- ======================================================= -->

### `pivot_longer()` {.unnumbered}

The **tidyr** function `pivot_longer()` makes data "longer". **tidyr** is part of the **tidyverse** of R packages.

It accepts a range of columns to transform (specified to `cols =`). Therefore, it can operate on only a part of a dataset. This is useful for the malaria data, as we only want to pivot the case count columns.

In this process, you will end up with two "new" columns - one with the categories (the former column names), and one with the corresponding values (e.g. case counts). You can accept the default names for these new columns, or you can specify your own to `names_to =` and `values_to =` respectively.

Let's see `pivot_longer()` in action...

**tidyr**の関数`pivot_longer()`は、データを「より長く」します。**tidyr**は、Rパッケージの**tidyverse**の一部です。

それは、変換する列の範囲（`= cols`に指定）を受け取ります。したがって、それはデータセットの一部だけで操作することができます。これは、ケースカウント列だけをピボット化したいので、マラリアデータには便利です。

この処理では、2 つの「新しい」列が作成されます。1 つはカテゴリ (以前の列名) で、もう 1 つは対応する値 (例: 症例数) で構成されます。これらの新しい列の名前は、デフォルトのままでも構いませんが、`names_to =`および`values_to =`にそれぞれ独自の名前を指定することもできます。

それでは、`pivot_longer()` を実際に動かしてみましょう...。

### Standard pivoting {.unnumbered}

標準的な変換

We want to use **tidyr**'s `pivot_longer()` function to convert the "wide" data to a "long" format. Specifically, to convert the four numeric columns with data on malaria counts to two new columns: one which holds the *age groups* and one which holds the corresponding *values*.

**tidyr** の `pivot_longer()` 関数を使用して、「ワイド」データを 「ロング」 形式に変換したいと思います。具体的には、マラリアの症例のデータを持つ4つの数値列を、年齢グループを保持する列と対応する値を保持する列の2つの新しい列に変換します。

```{r, eval=F}
df_long <- count_data %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

Notice that the newly created data frame (`df_long`) has more rows (12,152 vs 3,038); it has become *longer*. In fact, it is precisely four times as long, because each row in the original dataset now represents four rows in df_long, one for each of the malaria count observations (\<4y, 5-14y, 15y+, and total).

In addition to becoming longer, the new dataset has fewer columns (8 vs 10), as the data previously stored in four columns (those beginning with the prefix `malaria_`) is now stored in two.

Since the names of these four columns all begin with the prefix `malaria_`, we could have made use of the handy "tidyselect" function `starts_with()` to achieve the same result (see the page [Cleaning data and core functions] for more of these helper functions).

新しく作成されたデータフレーム（`df_long`）は行数が増え（12,152 vs 3,038）、[より長く]{.ul}なっていることに注意してください。実際、それは正確に4倍の長さです。なぜなら、オリジナルのデータセットの各行が、df_longの4行を表し、マラリア・カウントのオブザベーション（\<4y, 5-14y, 15y+, and total）のそれぞれについて1行ずつだからです。\\

長くなっただけでなく、新しいデータセットでは列数が8から10に減っています。以前は4つの列（接頭辞`malaria_`で始まる列）に格納されていたデータが、現在は2つの列に格納されているからです。\\

これらの4つの列の名前はすべて接頭辞`malaria_`で始まるので、便利な「tidyselect」関数`starts_with()`を使って同じ結果を得ることができました（これらのヘルパー関数については、[データクリーニングと主要関数]のページを参照してください）。

```{r}
# provide column with a tidyselect helper function
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

or by position:

または位置によって

```{r, eval=F}
# provide columns by position
count_data %>% 
  pivot_longer(
    cols = 6:9
  )
```

or by named range:

または名前の範囲によって

```{r, eval=F}
# provide range of consecutive columns
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```

These two new columns are given the default names of `name` and `value`, but we can override these defaults to provide more meaningful names, which can help remember what is stored within, using the `names_to` and `values_to` arguments. Let's use the names `age_group` and `counts`:

この2つの新しいカラムには`name`と`value`というデフォルトの名前が与えられていますが、`names_to`と`values_to`という引数を使えば、これらのデフォルトを上書きして、より意味のある名前を付けることができますし、中に何が格納されているかを覚えるのに役立ちます。`age_group`と`counts`という名前を使ってみましょう。

```{r}
df_long <- 
  count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )

df_long
```

We can now pass this new dataset to `{ggplot2}`, and map the new column `count` to the y-axis and new column `age_group` to the `fill =` argument (the column internal color). This will display the malaria counts in a stacked bar chart, by age group:

この新しいデータセットを`{ggplot2}`に渡して、新しい列`count`をY軸に、新しい列`age_group`を`fill =`引数（列の内部の色）に対応させることができます。これは、年齢グループごとに積み上げられた棒グラフでマラリア患者数を表示します。

```{r, warning=F, message=F}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Examine this new plot, and compare it with the plot we created earlier - *what has gone wrong?*

We have encountered a common problem when wrangling surveillance data - we have also included the total counts from the `malaria_tot` column, so the magnitude of each bar in the plot is twice as high as it should be.

We can handle this in a number of ways. We could simply filter these totals from the dataset before we pass it to `ggplot()`:

この新しいプロットを調べて、先ほど作ったプロットと比較してみてください。[何が悪い？]{.ul}

監視データを扱うときによくある問題に遭遇しました - `malaria_tot`列からの総カウントも含まれているので、プロットの各棒の大きさは、あるべき大きさの2倍になっています。

この問題はいくつかの方法で対処することができます。`ggplot()`に渡す前に、データセットからこれらの合計を単純にフィルタリングすることができます。

```{r, warning=F, message=F}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Alternatively, we could have excluded this variable when we ran `pivot_longer()`, thereby maintaining it in the dataset as a separate variable. See how its values "expand" to fill the new rows.

また、`pivot_longer()`を実行する際にこの変数を除外することで、別の変数としてデータセットに保持することも可能です。新しい行を埋めるために、この変数の値がどのように「拡張」されるかを見てみましょう。

```{r, warning=F, message=F}
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column
    names_to = "age_group",
    values_to = "counts"
  )
```

### Pivoting data of multiple classes {.unnumbered}

### 複数クラスのデータのピボット

The above example works well in situations in which all the columns you want to "pivot longer" are of the same class (character, numeric, logical...).

However, there will be many cases when, as a field epidemiologist, you will be working with data that was prepared by non-specialists and which follow their own non-standard logic - as Hadley Wickham noted (referencing Tolstoy) in his [seminal article](https://vita.had.co.nz/papers/tidy-data.pdf) on **Tidy Data** principles: "Like families, tidy datasets are all alike but every messy dataset is messy in its own way."

One particularly common problem you will encounter will be the need to pivot columns that contain different classes of data. This pivot will result in storing these different data types in a single column, which is not a good situation. There are various approaches one can take to separate out the mess this creates, but there is an important step you can take using `pivot_longer()` to avoid creating such a situation yourself.

Take a situation in which there have been a series of observations at different time steps for each of three items A, B and C. Examples of such items could be individuals (e.g. contacts of an Ebola case being traced each day for 21 days) or remote village health posts being monitored once per year to ensure they are still functional. Let's use the contact tracing example. Imagine that the data are stored as follows:

上記の例は、「長くピボットする」列がすべて同じクラス（文字列、数値、論理など）である場合にうまく機能します。\\

しかし、フィールドの疫学者として、非専門家によって作成され、独自の非標準的な論理に従ったデータを扱う場合が多くあります。Hadley Wickhamは、**Tidy Data**の原則に関する彼の[重要な論文]で（トルストイを参照）次のように指摘しています。「家族のように、整頓されたデータセットはすべて似ているが、乱雑なデータセットはそれなりに乱雑である。」\\

特によくある問題は、異なるクラスのデータを含む列をピボットする必要があることです。このピボットでは、これらの異なるデータ型を 1 つの列に格納することになりますが、これは良い状況ではありません。このような混乱を回避するために、さまざまなアプローチがありますが、`pivot_longer()` を使用して、自分でこのような状況を作らないようにするための重要なステップがあります。\\

3つの項目A, B, Cのそれぞれについて、異なる時間ステップで一連の観測が行われた状況を考えてみましょう。例えば、個人（例えば、エボラ出血熱患者の接触者を21日間毎日追跡する）や、遠隔地の村のヘルスポストがまだ機能しているかどうか年に1回モニターすることなどが挙げられます。接触者追跡の例を使ってみましょう。データが以下のように保存されていると想像してください。

```{r, message=FALSE, echo=F}

df <- 
  tibble::tribble(
     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,
     "A", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",     "Unwell",
     "B", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy",
     "C", "2021-04-23",    "Missing", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy"
     ) 

DT::datatable(df, rownames = FALSE)

```

As can be seen, the data are a bit complicated. Each row stores information about one item, but with the time series running further and further away to the right as time progresses. Moreover, the column classes alternate between date and character values.

One particularly bad example of this encountered by this author involved cholera surveillance data, in which 8 new columns of observations were added *each day* over the course of **4 years**. Simply opening the Excel file in which these data were stored took \>10 minuntes on my laptop!

In order to work with these data, we need to transform the data frame to long format, but keeping the separation between a `date` column and a `character` (status) column, for each observation for each item. If we don't, we might end up with a mixture of variable types in a single column (a very big "no-no" when it comes to data management and tidy data):

見ての通り、ちょっと複雑なデータになっています。各行には1つの項目に関する情報が格納されていますが、時間が進むにつれて時系列がどんどん右に流れています。さらに、列のクラスは日付と文字列の値が交互に並んでいます。\\

筆者が遭遇した特にひどい例は、コレラの監視データで、**4年間**[毎日]{.ul}8列の新しい観測値が追加されたものであった。これらのデータが保存されているExcelファイルを開くだけで、筆者のノートパソコンでは10分以上かかった。\\

これらのデータを扱うには、データフレームをロング形式に変換する必要がありますが、各項目の観測ごとに、`data`列と`character`（ステータス）列の分離を維持する必要があります。そうしないと、1つの列の中に変数の種類が混在してしまうかもしれません（データ管理や整頓されたデータに関しては、非常に大きな「やってはいけないこと」です）。

```{r}
df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation")
  )

```

Above, our pivot has merged *dates* and *characters* into a single `value` column. R will react by converting the entire column to class character, and the utility of the dates is lost.

To prevent this situation, we can take advantage of the syntax structure of the original column names. There is a common naming structure, with the observation number, an underscore, and then either "status" or "date". We can leverage this syntax to keep these two data types in separate columns after the pivot.

We do this by:

-   Providing a character vector to the `names_to =` argument, with the second item being (`".value"` ). This special term indicates that the pivoted columns will be split based on a character in their name...\
-   You must also provide the "splitting" character to the `names_sep =` argument. In this case, it is the underscore "\_".

Thus, the naming and split of new columns is based around the underscore in the existing variable names.

上記では、ピボットによって日付と文字が1つの列の`value`に統合されています。R は列全体をクラス文字に変換することで対応し、日付の実用性が失われます。

このような事態を防ぐには、元の列名の構文構造を利用します。観察番号、アンダースコア、そして "status "または "date "のいずれかを含む共通の命名構造が存在します。この構文を利用して、ピボット後にこれら 2 つのデータ型を別の列に保持することができます。

これを行うには、以下のようにします。

-   `names_to =` 引数に文字ベクトルを指定し、2番目の項目に (`".value"`) を指定する。この特別な用語は、回転した列がその名前に含まれる文字に基づいて分割されることを示します...

-   また、`names_sep =` の引数には、「分割」する文字を指定する必要があります。この場合、アンダースコア"\_"である。

このように、新しい列の命名と分割は、既存の変数名のアンダースコア"\_"を中心に行われる。

```{r}

df_long <- 
  df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation", ".value"),
    names_sep = "_"
  )

df_long

```

**Finishing touches**:

**仕上げに**

Note that the `date` column is currently in *character* class - we can easily convert this into it's proper date class using the `mutate()` and `as_date()` functions described in the [Working with dates] page.

We may also want to convert the `observation` column to a `numeric` format by dropping the "obs" prefix and converting to numeric. We cando this with `str_remove_all()` from the **stringr** package (see the [Characters and strings] page).

`date`列は現在文字クラスであることに注意してください。日付の操作のページで説明した `mutate()` と `as_date()` 関数を使用すれば、これを適切な日付クラスに簡単に変換できます。

"obs" というプレフィックスを削除して数値形式に変換することで、 `observation`列も`numeric`形式に変換できます。これは**stringr**パッケージの`str_remove_all()`を使って行うことができます([文字列型データ]のページを参照してください)。

```{r}

df_long <- 
  df_long %>% 
  mutate(
    date = date %>% lubridate::as_date(),
    observation = 
      observation %>% 
      str_remove_all("obs") %>% 
      as.numeric()
  )

df_long

```

And now, we can start to work with the data in this format, e.g. by plotting a descriptive heat tile:

そして、この形式のデータを使って、例えば、記述的なヒートタイルをプロットするなどの作業を開始することができます。

```{r}
ggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +
  geom_tile(colour = "black") +
  scale_fill_manual(
    values = 
      c("Healthy" = "lightgreen", 
        "Unwell" = "red", 
        "Missing" = "orange")
  )

```

<!-- ======================================================= -->

## Long-to-wide

## ロングからワイドへ

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

In some instances, we may wish to convert a dataset to a wider format. For this, we can use the `pivot_wider()` function.

A typical use-case is when we want to transform the results of an analysis into a format which is more digestible for the reader (such as a [Table for presentation][Tables for presentation]). Usually, this involves transforming a dataset in which information for one subject is are spread over multiple rows into a format in which that information is stored in a single row.

場合によっては、データセットをより広いフォーマットに変換したいことがあります。このような場合は、`pivot_wider()`関数を使用します。

典型的な使用例としては、分析結果を読み手にとって理解しやすい形式（[プレゼンテーション用の表]など）に変換する場合です。通常は、1 つの主題に関する情報が複数の行にまたがっているデータセットを、その情報が 1 つの行に格納される形式に変換することが必要です。

### Data {.unnumbered}

### データ {.unnumbered}

For this section of the page, we will use the case linelist (see the [Preparation](#pivot_prep) section), which contains one row per case.

Here are the first 50 rows:

この章では、1つの症例につき1行が含まれる症例ラインリスト（[準備](#pivot_prep)の章を参照）を使用することにします。

ここでは、最初の50行を示します。

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Suppose that we want to know the counts of individuals in the different age groups, by gender: 例えば、男女別の年齢層別の個体数を知りたいとします。

```{r}
df_wide <- 
  linelist %>% 
  count(age_cat, gender)

df_wide
```

This gives us a long dataset that is great for producing visualisations in **ggplot2**, but not ideal for presentation in a table: これは長いデータセットで、**ggplot2**での視覚化には最適ですが、表での表示には適していません。

```{r}
ggplot(df_wide) +
  geom_col(aes(x = age_cat, y = n, fill = gender))
```

### Pivot wider {.unnumbered}

Therefore, we can use `pivot_wider()` to transform the data into a better format for inclusion as tables in our reports.

The argument `names_from` specifies the column *from* which to generate the new column *names*, while the argument `values_from` specifies the column *from* which to take the *values* to populate the cells. The argument `id_cols =` is optional, but can be provided a vector of column names that should not be pivoted, and will thus identify each row.

したがって、`pivot_wider()` を使用して、データを報告書の表として含めるためのより良い形式に変換することができます。\
引数 `names_from` は、新しい*列名*を生成する*ための*列を指定し、引数 `values_from` は、セルに入力する*値*を取得する*ための*列を指定します。`id_cols =` はオプションですが、ピボット化されるべきでない列名のベクトルを提供することができ、それによって各行を識別することができます。

```{r}
table_wide <- 
  df_wide %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = n
  )

table_wide
```

This table is much more reader-friendly, and therefore better for inclusion in our reports. You can convert into a pretty table with several packages including **flextable** and **knitr**. This process is elaborated in the page [Tables for presentation]. この表は、より読みやすいので、報告書に掲載するのに適しています。**flextable**や**knitr**を含むいくつかのパッケージできれいな表に変換することができます。この作業は、[見やすい表の作り方]のページで詳しく説明されています。

```{r}
table_wide %>% 
  janitor::adorn_totals(c("row", "col")) %>% # adds row and column totals
  knitr::kable() %>% 
  kableExtra::row_spec(row = 10, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

------------------------------------------------------------------------

<!-- ======================================================= -->

## Fill

In some situations after a `pivot`, and more commonly after a `bind`, we are left with gaps in some cells that we would like to fill. `pivot`の後、そしてより一般的には`bind`の後、いくつかのセルに隙間ができてしまい、それを埋めたいと思うことがあります。 <!-- ======================================================= -->

### Data {.unnumbered}

### データ {.unnumbered}

For example, take two datasets, each with observations for the measurement number, the name of the facility, and the case count at that time. However, the second dataset also has a variable `Year`. 例えば、2つのデータセットがあり、それぞれ測定番号、施設名、その時点の症例数の観測値があるとします。しかし、2番目のデータセットには変数`Year`もあります。

```{r}
df1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

df1 

df2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

df2
```

When we perform a `bind_rows()` to join the two datasets together, the `Year` variable is filled with `NA` for those rows where there was no prior information (i.e. the first dataset): `bind_rows()`で2つのデータセットを結合すると、事前情報がない行（つまり最初のデータセット）については、`Year`変数が`NA`で埋められる。

```{r}
df_combined <- 
  bind_rows(df1, df2) %>% 
  arrange(Measurement, Facility)

df_combined

```

<!-- ======================================================= -->

### `fill()` {.unnumbered}

In this case, `Year` is a useful variable to include, particularly if we want to explore trends over time. Therefore, we use `fill()` to *fill* in those empty cells, by specifying the column to fill and the direction (in this case **up**): この場合、`Year`は特に時間的な傾向を調べるのに有効な変数である。したがって、塗りつぶす列と方向 (この場合は**上**) を指定して、空のセルを*塗りつぶす*ために `fill()` を使用します。

```{r}
df_combined %>% 
  fill(Year, .direction = "up")
```

Alternatively, we can rearrange the data so that we would need to fill in a downward direction: あるいは、下方向に塗りつぶす必要があるように、データを並べ替えることもできる。

```{r}
df_combined <- 
  df_combined %>% 
  arrange(Measurement, desc(Facility))

df_combined

df_combined <- 
  df_combined %>% 
  fill(Year, .direction = "down")

df_combined
```

We now have a useful dataset for plotting: これで、プロットするのに便利なデータセットができました。

```{r}
ggplot(df_combined) +
  aes(Year, Cases, fill = Facility) +
  geom_col()
```

But less useful for presenting in a table, so let's practice converting this long, untidy dataframe into a wider, tidy dataframe: そこで、この長くて整頓されていないデータフレームを、より広くて整頓されたデータフレームに変換する練習をしてみましょう。

```{r}
df_combined %>% 
  pivot_wider(
    id_cols = c(Facility, Year, Cases),
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  arrange(Facility) %>% 
  janitor::adorn_totals(c("row", "col")) %>% 
  knitr::kable() %>% 
  kableExtra::row_spec(row = 5, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

N.B. In this case, we had to specify to only include the three variables `Facility`, `Year`, and `Cases` as the additional variable `Measurement` would interfere with the creation of the table: 注）この場合、変数`Measurement`を追加すると表の作成に支障が出るため、`Facility`、`Year`、`Cases`の3つの変数のみを含めるように指定する必要がありました。

```{r}
df_combined %>% 
  pivot_wider(
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  knitr::kable()
```

## Resources

Here is a helpful [tutorial](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html) 役に立つ[チュートリアル](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)はこちら

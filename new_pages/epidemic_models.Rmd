---
editor_options: 
  markdown: 
    wrap: 72
---

# エピデミックモデリング

<!-- =============================≈========================= -->

## 概要

流行のモデリングのためのツールが増加してきており、最小の労力でかなり複雑な分析を行うことができるようになっています。このセクションでは、これらのツールをどのように使用するかについての概要を説明します：

-   実効再生産数（effective reproduction number）R<sub>t</sub>
    や倍化時間（doubling time）など関連する統計量を推定する
-   将来のインシデンスの短期的な予測（プロジェクション）を実施する

ここではこれらの基礎となっている方法論や統計学的な手法の概要を説明する意図は*ありません*ので、関連論文へのリンクについてはResources
tabを参照してください。ここで説明するツールを使用する前に、手法を理解しておくことで、正確に結果を解釈できるようになります。

以下はこのセクションで作成するアウトプットの１つの例です。

```{r out.width=c('100%', '100%'), fig.show='hold', echo=F, fig.width = 12, fig.height = 9, message=F, warning=F}

## パッケージのインストールとロード
pacman::p_load(tidyverse, EpiNow2, EpiEstim, here, incidence2, epicontacts, rio, projections)

## load linelist
linelist <- import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

## generate contacts
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## generate epicontacts
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)

## ## estimate gamma generation time
## generation_time <- bootstrapped_dist_fit(
##   get_pairwise(epic, "date_infection"),
##   dist = "gamma",
##   max_value = 20,
##   bootstraps = 1
## )

## ## export for caching
## export(
##   generation_time,
##   here("data/cache/epidemic_models/generation_time.rds")
## )

## import cached generation time
generation_time <- import(here("data/cache/epidemic_models/generation_time.rds"))

## ## estimate incubation period
## incubation_period <- bootstrapped_dist_fit(
##   linelist$date_onset - linelist$date_infection,
##   dist = "lognormal",
##   max_value = 100,
##   bootstraps = 1
## )

## ## export for caching
## export(
##   incubation_period,
##   here("data/cache/epidemic_models/incubation_period.rds")
## )

## import cached incubation period
incubation_period <- import(here("data/cache/epidemic_models/incubation_period.rds"))

## get incidence from onset date
cases <- linelist %>%
  group_by(date = date_onset) %>%
  summarise(confirm = n())

## ## run epinow
## epinow_res <- epinow(
##   reported_cases = cases,
##   generation_time = generation_time,
##   delays = delay_opts(incubation_period),
##   target_folder = here("data/cache/epidemic_models"),
##   return_output = TRUE,
##   output = "samples",
##   verbose = TRUE,
##   stan = stan_opts(samples = 750, chains = 4),
##   horizon = 21
## )

## ## export for caching
## export(
##   epinow_res,
##   here("data/cache/epidemic_models/epinow_res.rds")
## )

## import cached epinow results
epinow_res <- import(here("data/cache/epidemic_models/epinow_res.rds"))

## plot summary figure
plot(epinow_res)

```

<!-- ======================================================= -->

## 準備

R<sub>t</sub> 推定には **EpiNow** と **EpiEstim**
という2つの異なる手法とパッケージを使用し、症例（ケース）の発生数の予測には
**projections** パッケージを用います。

以下のコードチャンクは、（本ページの）分析に必要なパッケージのローディングを示しています。このハンドブックでは
**pacman** の `p_load()` の利用を強調しています。 `p_load()`
を利用することで、必要に応じてパッケージをインストールし、ロードすることが可能となります。R
の **base** から `library()`
でインストール済みのパッケージをロードすることもできます。R
のパッケージに関するさらなる情報は [R basics]
のページを参照してください。

```{r epidemic_models_packages, }
pacman::p_load(
   rio,          # ファイルをインポート
   here,         # ファイルロケーター
   tidyverse,    # データマネジメント + ggplot2 のグラフィックス
   epicontacts,  # トランスミッションネットワークの分析
   EpiNow2,      # Rt 推定
   EpiEstim,     # Rt 推定
   projections,  # 発生数のプロジェクション
   incidence2,   # 発生データの取り扱い
   epitrix,      # 便利な epi の機能
   distcrete     # 離散的な遅れの分布
)
```

このセクションのすべての分析において、前処理をされた症例のラインリストを使用します。引き続き分析を行いたい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>
クリックして、「クリーンな」ラインリスト </a>（.rds
ファイルとして)をダウンロードしてください。本ハンドブックで使用しているすべての例示データをダウンロードするには
[Download handbook and data] ページをご覧ください。

```{r, echo=F}
# ラインリストの取り込み
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r eval=F}
# クリーンなラインリストの取り込み
linelist <- import("linelist_cleaned.rds")
```

<!-- ======================================================= -->

## R<sub>t</sub> 推定

### EpiNow2 vs. EpiEstim {.unnumbered}

再生産数 R
は、疾病の感染性を示す指標であり、感染者1人あたりの二次感染者数の期待値として定義されます。感受性保持者しかいないような集団では、この値は基本再生産数
R<sub>0</sub>
を意味します。しかし、集団内の感受性保持者はアウトブレイクやパンデミックの期間中に変化し、また様々な対策が講じられるため、感染性の指標として最も一般的に使用されるのは実効再生産数です（ある時刻
*t* における感染者1人あたりの二次感染者数の期待値）。

**EpiNow2** パッケージは最も洗練された R<sub>t</sub>
推定のためのフレームワークを提供しています。ほかに一般的に使用されている
**EpiEstim** と比較して、2つの重要な利点があります：

-   告の遅れを考慮しているので、直近のデータが不完全の場合であっても
    R<sub>t</sub> を推定することができます。
-   報告日ではなく、*感染日*に基づいて R<sub>t</sub>
    を推定するので、遅れを生じずすぐに R<sub>t</sub>
    の変化として介入の効果が反映されま。

しかし、2つの重要なデメリットもあります：

-   世代時間の分布（一次感染者から二次感染者までの遅れの分布）、潜伏期間の分布（感染から症状発現までの遅れの分布）、およびデータに関連するその他の遅れの分布（例えば、報告の日付がある場合、症状発現から報告までの遅れの分布）に関する知識が必要です。これにより、より正確な
    R<sub>t</sub> を推定できますが、**EpiEstim**
    は発症間隔発症間隔（一次感染者の症状発現から二次感染者の症状発現までの遅れの分布）のみを必要とし、これのみが唯一利用可能な分布である場合があります。
-   **EpiNow2** は **EpiEstim** に
    比べて著しく遅く、約100～1000倍の差があるといわれています！例えば、このセクションで利用するサンプルアウトブレイクにおける
    R<sub>t</sub>
    推定には、約4時間かかります（これは高い精度を確保するために多数の反復処理を行ったのであり、必要に応じて短縮することも可能ですが、アルゴリズムが一般的に遅いという点は変わりません）。定期的に
    R<sub>t</sub>
    の推定値を更新している場合は、この方法は現実的ではないかもしれません。

そのため、どのパッケージを選ぶかは、利用できるデータや時間、計算資源によります。

### EpiNow2 {.unnumbered}

#### 遅れの分布の推定 {.unnumbered}

**EpiNow2**
の実行に必要な遅れの分布は、手持ちのデータによって異なります。基本的には、感染日から
R<sub>t</sub>
推定に使用したいイベント日までの遅れを記述できるものである必要があります。もし発症日を使っている場合、これは単に潜伏期間の分布となります。報告日を使用している場合は、感染から報告までの遅れの分布が必要です。この分布はなかなか直接知ることができないため、**EpiNow2**
では複数の遅れの分布をつなぎ合わせることができます。この場合、感染から症状発現までの遅れ（例えば潜伏期間、これは既知であることが多いです）と、症状発現から報告までの遅れ（これは自分でデータから推定できる場合が多いです）です。

例のラインリストではすべての症例について発症日がわかっているので、データ（例えば症状の発現日など）を感染日に結びつけるためには、潜伏期間の分布が必要になります。この分布は、データから推定するか、既存文献から値を引用することができます。

エボラ出血熱の潜伏期間を平均9.1日、標準偏差7.3日、最大値を30日とする文献からの推定値（[引用論文](https://www.nejm.org/doi/full/10.1056/nejmoa1411100)）は、以下のように規定されます：

```{r epidemic_models_incubation_literature, eval=F}
incubation_period_lit <- list(
  mean = log(9.1),
  mean_sd = log(0.1),
  sd = log(7.3),
  sd_sd = log(0.1),
  max = 30
)
```

**EpiNow2**
では、これらの遅れの分布が対数（**log**）スケールで提供される必要があり、そのため、各値に
`log`
がついていることに注意してください（紛らわしいことに、自然スケールで提供されなければならない
`max` パラメータを除く）。`mean_sd` と `sd_sd`
は、平均値と標準偏差の推定値の標準偏差を定義します。上記のケースではこれらは知られていないため、かなり恣意的な値である0.1を選択しました。

今回のｂ分析ではその代わりに、`bootstrapped_dist_fit`
関数を用いて、ラインリストから潜伏期間の分布を推定しました。

```{r epidemic_models_incubation_estimate, eval=F}
## 潜伏期間の推定
incubation_period <- bootstrapped_dist_fit(
  linelist$date_onset - linelist$date_infection,
  dist = "lognormal",
  max_value = 100,
  bootstraps = 1
)
```

もう一つ必要な分布は、世代時間です。感染時刻**と**感染伝播のリンクに関するデータがあるので、感染者と被感染者のペアの感染時刻の遅れを計算することで、ラインリストからこの分布を推定することができます。これには
**epicontacts** パッケージにある `get_pairwise`
という便利な関数を使います。この関数を使うと、感染ペア間のラインリスト上の2組の特性の違いを計算することができます。epicontacts
オブジェクトを作成します（詳しくは [Transmission chains]
のページを参照してください）：

```{r epidemic_models_epicontacts, eval=F}
## コンタクトの作成
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## epicontacts オブジェクトの作成
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

次に、`get_pairwise`
で計算した感染ペア間の感染時刻の差をガンマ分布にあてはめました：

```{r epidemic_models_generation_estimate, eval=F}
## ガンマ分布に従う世代時間の推定
generation_time <- bootstrapped_dist_fit(
  get_pairwise(epic, "date_infection"),
  dist = "gamma",
  max_value = 20,
  bootstraps = 1
)
```

#### **EpiNow2 の実行** {.unnumbered}

あとはラインリストから日々のインシデンスを計算するだけですが、**dplyr**
関数の `group_by()` と `n()` で簡単にできます。**EpiNow2** では、列名が
`date` と `confirm` でなければならないことに注意してください。

```{r epidemic_models_cases, eval=F}
## 発症日からインシデンスを得る
cases <- linelist %>%
  group_by(date = date_onset) %>%
  summarise(confirm = n())
```

そして、`epinow` 関数を使って R<sub>t</sub>
を推定することができます。入力に関して、いくつかの注意点を挙げます：

-   `delays`
    の引数には、任意の数の「連鎖した」遅れの分布を与えることができます。`delay_opts`
    関数内で `incubation_period` オブジェクトと一緒に入れるだけです。
-   `return_output` は、出力ファイルに保存されるのではなく、R
    の中で貸せされるようになっています。
-   `verbose` は、進捗状況の読み上げを指定します。
-   `horizon` は、将来のインシデンスを何日分予測するかを示します。
-   `stan`
    の因数に追加のオプションを渡して、推定を実行する期間を指定します。`samples`
    数と `chains`
    数を増やすと、不確実性の特徴をよく表したより正確な推定値が得られますが、実行には時間がかかります。

```{r epidemic_models_run_epinow, eval=F}
## epinow を走らせる
epinow_res <- epinow(
  reported_cases = cases,
  generation_time = generation_time,
  delays = delay_opts(incubation_period),
  return_output = TRUE,
  verbose = TRUE,
  horizon = 21,
  stan = stan_opts(samples = 750, chains = 4)
)
```

#### アウトプットの分析 {.unnumbered}

コードの実行が終了すると、以下のように簡単にサマリーをプロットすることができます。画像をスクロールすると、全体を見ることができます。

```{r out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F }
## サマリーフィギュアのプロット
plot(epinow_res)
```

また、様々なサマリー統計量を見ることもできます：

```{r epidemic_models_epinow_summary,}
## サマリーテーブル
epinow_res$summary
```

さらなる分析やカスタムプロットのために、`$estimates$summarised`.
を介して要約された毎日の推定値にアクセスすることができます。これをデフォルトの
`data.table` から、**dplyr** で使いやすいように `tibble` に変換します。

```{r epidemic_models_to_tibble, eval=F}
## サマリーを抽出して、tibble に変換
estimates <- as_tibble(epinow_res$estimates$summarised)
estimates
```

```{r epidemic_models_tibble_show,  echo = F}
## アウトプットの表示
estimates <- as_tibble(epinow_res$estimates$summarised)
DT::datatable(
  estimates,
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap'
)
```

例として、倍化時間と R<sub>t</sub>
をプロットしてみましょう。極端に高い倍化時間をプロットしないように、R<sub>t</sub>
が1を大きく上回っている流行の最初の数か月だけを見ています。

`log(2)/growth_rate` という計算式を用いて、推定された成長率（growth
rate）から倍化時間を算出しています。

```{r epidemic_models_plot_epinow_cusotom, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## 中央値プロットのために横型のデータフレームを作ります
df_wide <- estimates %>%
  filter(
    variable %in% c("growth_rate", "R"),
    date < as.Date("2014-09-01")
  ) %>%
  ## 成長率を倍化時間に変換
  mutate(
    across(
      c(median, lower_90:upper_90),
      ~ case_when(
        variable == "growth_rate" ~ log(2)/.x,
        TRUE ~ .x
      )
    ),
    ## 変形を反映した変数名の変更
    variable = replace(variable, variable == "growth_rate", "doubling_time")
  )

## 分位値プロットのために縦長のデータフレームを作る
df_long <- df_wide %>%
  ## ここでは、マッチした分位値を利用します（例：lower_90 から upper_90）
  pivot_longer(
    lower_90:upper_90,
    names_to = c(".value", "quantile"),
    names_pattern = "(.+)_(.+)"
  )

## プロットする
ggplot() +
  geom_ribbon(
    data = df_long,
    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = date, y = median)
  ) +
  ## label_parsedを使用して、添え字ラベルを許可する
  facet_wrap(
    ~ variable,
    ncol = 1,
    scales = "free_y",
    labeller = as_labeller(c(R = "R[t]", doubling_time = "Doubling~time"), label_parsed),
    strip.position = 'left'
  ) +
  ## 分位値の透明度を手動で定義する
  scale_alpha_manual(
    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = NULL,
    alpha = "Credibel\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.background = element_blank(),
    strip.placement = 'outside'
  )

```

<!-- ======================================================= -->

### EpiEstim {.unnumbered}

**EpiEstim**
を走らせるために、日々のインシデンスのデータを提供し、発症間隔（一次症例と二次症例の症状発現までの遅れの分布）を指定する必要があります。

インシデンスデータは、ベクター、データフレーム、またはオリジナルの
**incidence** パッケージから得られた `incidence`
オブジェクトとして、**EpiEstim**
に提供できます。輸入感染例とローカルで感染した例を区別することもできます：詳細は
`?estimate_R` のドキュメントを参照してください。

ここでは **incidence2** を使って、インプットを作成します。**incidence2**
パッケージの例については [Epidemic curves]
のページを参照してください。**incidence2** パッケージには `estimateR()`
が期待するインプットとは完全に一致しないアップデートがあったため、いくつかの小さな追加手順が必要となります。incidence
オブジェクトは日付とそれぞれのケースカウントをもつ tibble
で構成されています。**tidyr** の `complete()`
を使用して、すべての日付が含まれていることを確認し（症例がない日も含む）、後のステップで`estimate_R()`
で期待されるものと一致するように列を `rename()` します。

```{r epidemic_models_epiestim_incidence,}
## 発症日からインシデンスを得る
cases <- incidence2::incidence(linelist, date_index = date_onset) %>% # 日ごとにケースカウントを得る
  tidyr::complete(date_index = seq.Date(                              # すべての日付が表示されていることを確認
    from = min(date_index, na.rm = T),
    to = max(date_index, na.rm=T),
    by = "day"),
    fill = list(count = 0)) %>%                                       # NA カウントを0に変換する
  rename(I = count,                                                   # estimateRで期待されるな目に変更
         dates = date_index)
```

このパッケージにはは発症間隔を指定するためのいくつかのオプションがあり、その詳細はドキュメントの
`?estimate_R` に記載されています。ここではそのうちの2つを取り上げます。

#### 文献から引用した発症間隔の推定値の使用 {.unnumbered}

オプションの `method = "parametric_si"` を使用すると、関数 `make_config`
で作成した `config`
オブジェクトに発症間隔の平均値と標準偏差を手動で指定することができます。ここでは、[この論文](https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0)で定義されている平均値12.0、標準偏差5.2を使用しています。

```{r epidemic_models_epiestim_config,}
## config の作成
config_lit <- make_config(
  mean_si = 12.0,
  std_si = 5.2
)
```

そして、`estimate_R` 関数で R<sub>t</sub> の推定をすることができます：

```{r epidemic_models_epiestim_lit,  warning = FALSE}
epiestim_res_lit <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_lit
)
```

あとはアウトプットのサマリーをプロットします：

```{r epidemic_models_epiestim_lit_plot,  warning = FALSE}
plot(epiestim_res_lit)
```

#### データから推定した発症間隔の推定値の使用 {.unnumbered}

症状の発症日と感染伝播のリンクデータがあるので、感染者と被感染者のペアの発症日の遅れを計算することで、ラインリストから発症間隔を推定することもできます。**EpiNow2**
のセクションで行ったように、**epicontacts** パッケージの `get_pairwise`
関数を使います。この関数は感染ペア間のラインリスト上の2組の特性の違いを計算することができます。まず
epicontacts オブジェクトを作成します（詳細は [Transmission chains]
のページを参照）：

```{r epidemic_models_epicontacts_epiestim, eval=F}
## コンタクトの作成
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## epicontacts オブジェクトの作成
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

次に、`get_pairwise`
を用いて感染ペア間の発症日の差をガンマ分布に当てはめます。*離散化された*分布が必要とされるため、このフィッティング手順には
**epitrix** パッケージの便利な `fit_disc_gamma` を使用します。

```{r epidemic_models_incubation_estimate_epiestim,  warning = FALSE}
## ガンマ分布に従う発症間隔の推定
serial_interval <- fit_disc_gamma(get_pairwise(epic, "date_onset"))
```

We then pass this information to the `config` object, run **EpiEstim**
again and plot the results:

```{r epidemic_models_epiestim_emp,  warning = FALSE}
## config の作成
config_emp <- make_config(
  mean_si = serial_interval$mu,
  std_si = serial_interval$sd
)

## epiestim を走らせる
epiestim_res_emp <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_emp
)

## アウトプットをプロットする
plot(epiestim_res_emp)
```

#### 推定時間枠の設定 {.unnumbered}

These default options will provide a weekly sliding estimate and might
act as a warning that you are estimating R<sub>t</sub> too early in the
outbreak for a precise estimate. You can change this by setting a later
start date for the estimation as shown below. Unfortunately,
**EpiEstim** only provides a very clunky way of specifying these
estimations times, in that you have to provide a vector of **integers**
referring to the start and end dates for each time window.

```{r epidemic_models_epiestim_config_late,}

## define a vector of dates starting on June 1st
start_dates <- seq.Date(
  as.Date("2014-06-01"),
  max(cases$dates) - 7,
  by = 1
) %>%
  ## subtract the starting date to convert to numeric
  `-`(min(cases$dates)) %>%
  ## convert to integer
  as.integer()

## add six days for a one week sliding window
end_dates <- start_dates + 6
  
## make config
config_partial <- make_config(
  mean_si = 12.0,
  std_si = 5.2,
  t_start = start_dates,
  t_end = end_dates
)
```

Now we re-run **EpiEstim** and can see that the estimates only start
from June:

```{r epidemic_models_epiestim_config_late_run,}

## run epiestim
epiestim_res_partial <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_partial
)

## plot outputs
plot(epiestim_res_partial)

```

#### Analysing outputs {.unnumbered}

The main outputs can be accessed via `$R`. As an example, we will create
a plot of R<sub>t</sub> and a measure of "transmission potential" given
by the product of R<sub>t</sub> and the number of cases reported on that
day; this represents the expected number of cases in the next generation
of infection.

```{r epidemic_models_epiestim_plot_full, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## make wide dataframe for median
df_wide <- epiestim_res_lit$R %>%
  rename_all(clean_labels) %>%
  rename(
    lower_95_r = quantile_0_025_r,
    lower_90_r = quantile_0_05_r,
    lower_50_r = quantile_0_25_r,
    upper_50_r = quantile_0_75_r,
    upper_90_r = quantile_0_95_r,
    upper_95_r = quantile_0_975_r,
    ) %>%
  mutate(
    ## extract the median date from t_start and t_end
    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],
    var = "R[t]"
  ) %>%
  ## merge in daily incidence data
  left_join(cases, "dates") %>%
  ## calculate risk across all r estimates
  mutate(
    across(
      lower_95_r:upper_95_r,
      ~ .x*I,
      .names = "{str_replace(.col, '_r', '_risk')}"
    )
  ) %>%
  ## seperate r estimates and risk estimates
  pivot_longer(
    contains("median"),
    names_to = c(".value", "variable"),
    names_pattern = "(.+)_(.+)"
  ) %>%
  ## assign factor levels
  mutate(variable = factor(variable, c("risk", "r")))

## make long dataframe from quantiles
df_long <- df_wide %>%
  select(-variable, -median) %>%
  ## seperate r/risk estimates and quantile levels
  pivot_longer(
    contains(c("lower", "upper")),
    names_to = c(".value", "quantile", "variable"),
    names_pattern = "(.+)_(.+)_(.+)"
  ) %>%
  mutate(variable = factor(variable, c("risk", "r")))

## make plot
ggplot() +
  geom_ribbon(
    data = df_long,
    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = dates, y = median),
    alpha = 0.2
  ) +
  ## use label_parsed to allow subscript label
  facet_wrap(
    ~ variable,
    ncol = 1,
    scales = "free_y",
    labeller = as_labeller(c(r = "R[t]", risk = "Transmission~potential"), label_parsed),
    strip.position = 'left'
  ) +
  ## manually define quantile transparency
  scale_alpha_manual(
    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = NULL,
    alpha = "Credible\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.background = element_blank(),
    strip.placement = 'outside'
  )
  
```

<!-- ======================================================= -->

## Projecting incidence

### EpiNow2 {.unnumbered}

Besides estimating R<sub>t</sub>, **EpiNow2** also supports forecasting
of R<sub>t</sub> and projections of case numbers by integration with the
**EpiSoon** package under the hood. All you need to do is specify the
`horizon` argument in your `epinow` function call, indicating how many
days you want to project into the future; see the **EpiNow2** section
under the "Estimating R<sub>t</sub>" for details on how to get
**EpiNow2** up and running. In this section, we will just plot the
outputs from that analysis, stored in the `epinow_res` object.

```{r epidemic_models_episoon, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## define minimum date for plot
min_date <- as.Date("2015-03-01")

## extract summarised estimates
estimates <-  as_tibble(epinow_res$estimates$summarised)

## extract raw data on case incidence
observations <- as_tibble(epinow_res$estimates$observations) %>%
  filter(date > min_date)

## extract forecasted estimates of case numbers
df_wide <- estimates %>%
  filter(
    variable == "reported_cases",
    type == "forecast",
    date > min_date
  )

## convert to even longer format for quantile plotting
df_long <- df_wide %>%
  ## here we match matching quantiles (e.g. lower_90 to upper_90)
  pivot_longer(
    lower_90:upper_90,
    names_to = c(".value", "quantile"),
    names_pattern = "(.+)_(.+)"
  )

## make plot
ggplot() +
  geom_histogram(
    data = observations,
    aes(x = date, y = confirm),
    stat = 'identity',
    binwidth = 1
  ) +
  geom_ribbon(
    data = df_long,
    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = date, y = median)
  ) +
  geom_vline(xintercept = min(df_long$date), linetype = 2) +
  ## manually define quantile transparency
  scale_alpha_manual(
    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = "Daily reported cases",
    alpha = "Credible\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14)

```

### projections {.unnumbered}

The **projections** package developed by RECON makes it very easy to
make short term incidence forecasts, requiring only knowledge of the
effective reproduction number R<sub>t</sub> and the serial interval.
Here we will cover how to use serial interval estimates from the
literature and how to use our own estimates from the linelist.

#### Using serial interval estimates from the literature {.unnumbered}

**projections** requires a discretised serial interval distribution of
the class `distcrete` from the package **distcrete**. We will use a
gamma distribution with a mean of 12.0 and and standard deviation of 5.2
defined in [this
paper](https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0).
To convert these values into the shape and scale parameters required for
a gamma distribution, we will use the function `gamma_mucv2shapescale`
from the **epitrix** package.

```{r epidemic_models_projections_distcrete,}

## get shape and scale parameters from the mean mu and the coefficient of
## variation (e.g. the ratio of the standard deviation to the mean)
shapescale <- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)

## make distcrete object
serial_interval_lit <- distcrete::distcrete(
  name = "gamma",
  interval = 1,
  shape = shapescale$shape,
  scale = shapescale$scale
)

```

Here is a quick check to make sure the serial interval looks correct. We
access the density of the gamma distribution we have just defined by
`$d`, which is equivalent to calling `dgamma`:

```{r epidemic_models_projections_distcrete_plot,}

## check to make sure the serial interval looks correct
qplot(
  x = 0:50, y = serial_interval_lit$d(0:50), geom = "area",
  xlab = "Serial interval", ylab = "Density"
)

```

#### Using serial interval estimates from the data {.unnumbered}

As we have data on dates of symptom onset *and* transmission links, we
can also estimate the serial interval from the linelist by calculating
the delay between onset dates of infector-infectee pairs. As we did in
the **EpiNow2** section, we will use the `get_pairwise` function from
the **epicontacts** package, which allows us to calculate pairwise
differences of linelist properties between transmission pairs. We first
create an epicontacts object (see [Transmission chains] page for further
details):

```{r epidemic_models_epicontacts_projections, eval=F}
## generate contacts
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## generate epicontacts object
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

We then fit the difference in onset dates between transmission pairs,
calculated using `get_pairwise`, to a gamma distribution. We use the
handy `fit_disc_gamma` from the **epitrix** package for this fitting
procedure, as we require a *discretised* distribution.

```{r epidemic_models_incubation_estimate_projections,  warning = FALSE}
## estimate gamma serial interval
serial_interval <- fit_disc_gamma(get_pairwise(epic, "date_onset"))

## inspect estimate
serial_interval[c("mu", "sd")]
```

#### Projecting incidence {.unnumbered}

To project future incidence, we still need to provide historical
incidence in the form of an `incidence` object, as well as a sample of
plausible R<sub>t</sub> values. We will generate these values using the
R<sub>t</sub> estimates generated by **EpiEstim** in the previous
section (under "Estimating R<sub>t</sub>") and stored in the
`epiestim_res_emp` object. In the code below, we extract the mean and
standard deviation estimates of R<sub>t</sub> for the last time window
of the outbreak (using the `tail` function to access the last element in
a vector), and simulate 1000 values from a gamma distribution using
`rgamma`. You can also provide your own vector of R<sub>t</sub> values
that you want to use for forward projections.

```{r epidemic_models_projection_setup,  warning = FALSE}

## create incidence object from dates of onset
inc <- incidence::incidence(linelist$date_onset)

## extract plausible r values from most recent estimate
mean_r <- tail(epiestim_res_emp$R$`Mean(R)`, 1)
sd_r <- tail(epiestim_res_emp$R$`Std(R)`, 1)
shapescale <- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)
plausible_r <- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)

## check distribution
qplot(x = plausible_r, geom = "histogram", xlab = expression(R[t]), ylab = "Counts")

```

We then use the `project()` function to make the actual forecast. We
specify how many days we want to project for via the `n_days` arguments,
and specify the number of simulations using the `n_sim` argument.

```{r epidemic_models_make_projection,}

## make projection
proj <- project(
  x = inc,
  R = plausible_r,
  si = serial_interval$distribution,
  n_days = 21,
  n_sim = 1000
)

```

We can then handily plot the incidence and projections using the
`plot()` and `add_projections()` functions. We can easily subset the
`incidence` object to only show the most recent cases by using the
square bracket operator.

```{r epidemic_models_plot_projection, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## plot incidence and projections
plot(inc[inc$dates > as.Date("2015-03-01")]) %>%
  add_projections(proj)

```

You can also easily extract the raw estimates of daily case numbers by
converting the output to a dataframe.

```{r epidemic_models_projection_df, eval=F, warning = FALSE}
## convert to data frame for raw data
proj_df <- as.data.frame(proj)
proj_df
```

```{r epidemic_models_projection_dt,  echo = F}

## convert to data frame for raw data
proj_df <- as.data.frame(proj)

## data table output
DT::datatable(
  proj_df[1:11],
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap'
)

```

<!-- ======================================================= -->

## Resources

-   [Here is the
    paper](https://www.sciencedirect.com/science/article/pii/S1755436519300350)
    describing the methodology implemented in **EpiEstim**.
-   [Here is the
    paper](https://wellcomeopenresearch.org/articles/5-112/v1)
    describing the methodology implemented in **EpiNow2**.
-   [Here is a
    paper](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008409)
    describing various methodological and practical considerations for
    estimating R<sub>t</sub>.

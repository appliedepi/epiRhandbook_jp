# 移動平均

```{r, out.width=c("100%"), echo=F}
knitr::include_graphics(here::here("images", "moving_avg_epicurve.png"))
```

このページでは、移動平均を計算し、可視化する方法として、以下の２つを説明します:

1)  **slider** パッケージを利用した計算\
2)  `ggplot()` 内のコマンドとして、**tidyquant** パッケージを利用した計算

<!-- ======================================================= -->

## 準備

### パッケージをロードする {.unnumbered}

以下にある一連のコードは、本ページの分析に必要なパッケージのロードについて示しています。このハンドブックでは、**pacman** の `p_load()` の利用を強調しています。 `p_load()` を利用することで、必要に応じてパッケージをインストールし、ロードすることが可能となります。 R の基本仕様である `library()` でインストール済みのパッケージをロードすることもできます。 R のパッケージに関する更なる情報は [R basics] のページを参照してください。

```{r}
pacman::p_load(
  tidyverse,      # データマネージメントと可視化のため
  slider,         # 移動平均の計算のため
  tidyquant       # ggplot内の移動平均の計算のため
)
```

### データのインポート {.unnumbered}

シミュレーションしたエボラ出血熱の流行から得られた症例のデータセットを取り込みます。説明とともに作業をしたい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'> をクリックして「クリーン」なラインリストをダウンロードしてください（ .rds 　ファイルとして）。**rio** パッケージの `import()` 関数を使用してデータをインポートします（.xlsx、.csv、.rds など、様々な種類のファイルを扱うことができます - 詳細は [Import and export] のページをご覧ください）。

```{r, echo=F}
# ラインリストをRに取り込む
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# ラインリストのインポート
linelist <- import("linelist_cleaned.xlsx")
```

ラインリストの最初の50行を以下に表示します。

```{r, message=FALSE, echo=F}
# ラインリストのデータをテーブルとして表示する
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## **slider を利用した計算**

**プロットする前にデータフレームを使って移動平均を計算するには、この方法を使用します。**

**slider** パッケージには rolling regressions（移動平均）や累積和、rolling averages（データの時期をずらして回帰する手法）などを計算するために、いくつかの "sliding window" 関数を提供します。これはデータフレームを行（row）のベクターとして扱い、データフレーム上の行ごとの反復計算が可能になります。

ここで、いくつかの代表的な関数を提示します：

-   `slide_dbl()` - sliding window を用いた*数値型*（つまり、"\_dbl"）の列を介して行う演算処理

    -   `slide_sum()` - `slide_dbl()`の rolling sum のショートカット関数\
    -   `slide_mean()` - `slide_dbl()`のrolling average のショートカット関数

-   `slide_index_dbl()` - ウィンドウの進行をインデックス化するための別の列を使用し、数値型の列に rolling window を適用する（一部の日付が存在しないデータセットで、日付によるローリングをする場合に便利）

    -   `slide_index_sum()` - インデックスありの rolling sum のショートカット関数\
    -   `slide_index_mean()` - インデックスありの rolling mean のショートカット関数

**slider** パッケージはほかにも様々な機能があり、このページの Resources セクションで紹介しています。ここでは、最も一般的な機能について簡単に説明します。

**実引数**

-   `.x`, デフォルトでは第1引数となります。反復処理を行い、関数を適用するベクトルを指定します。\

-   `.i =` **slider** 機能の "index" バージョンのために、"index" をロールするための列を用意します（[以下のセクションを参照](#roll_index)）\

-   `.f =`, デフォルトでは2番目の引数となり、以下のどちらかを指定します：

    -   括弧なしで書かれた関数（例えば `mean` など）\
    -   関数に変換される数式。例えば、`~ .x - mean(.x)` の場合は、現在の値からウィンドウの平均値を引いた結果を返します

-   さらなる詳細はこの [reference material](https://davisvaughan.github.io/slider/reference/slide.html) を参照してください。

**ウィンドウサイズ**

`.before`、`.after` のいずれか、または両方の引数を使用して、ウィンドウサイズを指定します：

-   `.before =` - 整数を提供\
-   `.after =` - 整数を提供\
-   `.complete =` - 完全なウィンドウ（範囲を指定する必要のない場合）に対してのみの計算を行いたい場合は `TRUE` に設定してください

例えば、現在の値とその前の6日間の値を含む7日間のウィンドウを表示するためには、`.before = 6` というように使います。中央値を基準としたウィンドウにするためには、`.before =` と `.after =` の両方に同じ値を指定します。

デフォルトでは、`.complete =` FALSE となっており、完全な行のウィンドウが存在しない場合、関数は利用可能な行を使用して計算を行います。TRUE に設定すると、完全なウィンドウでのみ計算が実施されるように制限することになります。

**ウィンドウの拡張**

累積演算を行うためには、`.before =` 引数を `Inf` に設定します。これにより、現在の値とそれより前の全ての値に対して計算が行われます。

### 日付によるローリング {#roll_index .unnumbered}

応用疫学でのローリング計算の最も一般的な使用例は、ある指標を*時系列*でみることでしょう。例えば、毎日の症例数をもとにした発生数（incidence）の測定などです。

全ての日付に値がある時系列のデータがある場合、[Time series and outbreak detection](#timeseries_moving) ページで紹介されているように、`slide_dbl()` を使用してもよいでしょう。

しかし、応用疫学分野では、イベントが記録されていない日付が欠損していることがあります。このような場合には、**slider** 関数の "index" バージョンを使用するのがベストです。

### インデックス化されたデータ {.unnumbered}

以下では、感染者のラインリストに `slide_index_dbl()` を使った例を示します。ここでは、移動7日間発生数（7日間のウィンドウを使用したケースの合計）を計算することを目的とします。もし移動平均の例を探しているのであれば、[grouped rolling](#roll_slider_group) のセクションを参照してください。

まず、`daily_counts` というデータセットを作成し、**dplyr** の `count()` から計算された `linelist` の毎日の症例数を反映させましょう。

```{r}
# デーリーカウントのデータセットを作成
daily_counts <- linelist %>% 
  count(date_hospitalisation, name = "new_cases")
```

ここに、`daily_counts` のデータフレームがあります - `nrow(daily_counts)` 行があり、各日は1行で表されていますが、*特に流行の初期には存在しない日もあります（その日に入院した症例はいませんでした）*。

```{r, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 6, scrollX=T) )
```

`slide_dbl()` にような標準的なローリング関数は、7*日間*ではなく7*行*のウィンドウを使用するという認識を持つことが重要です。そのため、データに入っていない日付がある場合、いくつかのウィンドウは実際には7日間よりも長くなります！

`slide_index_dbl()` を使うと、「スマート」なローリングウィンドウを実現することができます。"index" とは、この関数がローリングウィンドウの "index" として*別の列*を使うことを意味します。ウィンドウは単にデータフレームの行に基づいているわけではないのです。

インデックス列が日付の場合、ウィンドウの範囲を `.before =` や `.after =` にして、**lubridate** `days()` や `months()` の単位で指定することができます。このようにすると、関数のおかげでウィンドウに存在しない欠損日（`NA` 値として）も含まれることになります。

それでは、比較をしてみましょう。以下では、通常の7日間のローリングした発生数とインデックスウィンドウを利用した7日間のローリングした発生数を計算します。

```{r}
rolling <- daily_counts %>% 
  mutate(                                # 新しい列を作る
    # slide_dbl() を使う
    ###################
    reg_7day = slide_dbl(
      new_cases,                         # 新しいケースを計算する
      .f = ~sum(.x, na.rm = T),          # 欠損値が除外された sum() 関数
      .before = 6),                      # ウィンドウは当行と6つ前の行
    
    # slide_index_dbl() を使う
    #########################
    indexed_7day = slide_index_dbl(
        new_cases,                       # 新しいケースを計算する
        .i = date_hospitalisation,       # インデックス化された date_onset 
        .f = ~sum(.x, na.rm = TRUE),     # 欠損値が除外された sum() 関数
        .before = days(6))               # ウィンドウは当日と6つ前の日
    )

```

最初の7行の通常列では、*それぞれの行が7日以内ではないにもかかわらず*、カウントが増加していることを確認してください！隣接する「インデックス化」された列では、データがない日にちが考慮されているため、少なくともケースの差が大きい流行のこの時期においては、7日間の合計値はかなり低くなっています。

```{r, echo=F}
DT::datatable(rolling, rownames = FALSE, options = list(pageLength = 12, scrollX=T) )
```

では、`ggplot()` を用いて、これらのデータをプロットしてみましょう。

```{r}
ggplot(data = rolling)+
  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)
```

<!-- ### Rolling by month {.unnumbered}   -->

<!-- If you want to calculate statistics by month (e.g. sum, mean, max) you can do this with **dplyr** as described in the [Grouping data] page. Simply create a "month" column, group the data, and run your calculations with `summarise()`.   -->

<!-- If however, you want to calculate rolling statistics over several months (e.g a 2-month rolling window), you can use the `slide_period()` function from **slider**.   -->

<!-- ```{r} -->

<!-- monthly_mean = function(data){ -->

<!--   summarise(data, mean = mean(new_cases, na.rm=T)) -->

<!-- } -->

<!-- linelist %>%  -->

<!--   count(date_hospitalisation, name = "new_cases") %>%  -->

<!--   mutate( -->

<!--     slide_period_dfr( -->

<!--       new_cases,  -->

<!--       .i = date_hospitalisation, -->

<!--       .period = "month", -->

<!--       .f = monthly_mean))  #~mean(.x, na.rm=T))) -->

<!--       #values_col = new_cases, -->

<!--       #index_col = date_hospitalisation -->

<!--     )) -->

<!-- ``` -->

### グループ別のローリング {#roll_slider_group .unnumbered}

If you group your data prior to using a **slider** function, the sliding windows will be applied by group. Be careful to arrange your rows in the desired order *by group*.

Each time a new group begins, the sliding window will re-start. Therefore, one nuance to be aware of is that if your data are grouped *and* you have set `.complete = TRUE`, you will have empty values at each transition between groups. As the function moved downward through the rows, every transition in the grouping column will re-start the accrual of the minimum window size to allow a calculation.

See handbook page on [Grouping data] for details on grouping data.

Below, we count linelist cases by date *and* by hospital. Then we arrange the rows in ascending order, first ordering by hospital and then within that by date. Next we set `group_by()`. Then we can create our new rolling average.

```{r}
grouped_roll <- linelist %>%

  count(hospital, date_hospitalisation, name = "new_cases") %>% 

  arrange(hospital, date_hospitalisation) %>%   # arrange rows by hospital and then by date
  
  group_by(hospital) %>%              # group by hospital 
    
  mutate(                             # rolling average  
    mean_7day_hosp = slide_index_dbl(
      .x = new_cases,                 # the count of cases per hospital-day
      .i = date_hospitalisation,      # index on date of admission
      .f = mean,                      # use mean()                   
      .before = days(6)               # use the day and the 6 days prior
      )
  )

```

Here is the new dataset:

```{r, echo=F}
DT::datatable(grouped_roll, rownames = FALSE, options = list(pageLength = 12, scrollX=T) )
```

We can now plot the moving averages, displaying the data by group by specifying `~ hospital` to `facet_wrap()` in `ggplot()`. For fun, we plot two geometries - a `geom_col()` showing the daily case counts and a `geom_line()` showing the 7-day moving average.

```{r, warning=F, message=F}
ggplot(data = grouped_roll)+
  geom_col(                       # plot daly case counts as grey bars
    mapping = aes(
      x = date_hospitalisation,
      y = new_cases),
    fill = "grey",
    width = 1)+
  geom_line(                      # plot rolling average as line colored by hospital
    mapping = aes(
      x = date_hospitalisation,
      y = mean_7day_hosp,
      color = hospital),
    size = 1)+
  facet_wrap(~hospital, ncol = 2)+ # create mini-plots per hospital
  theme_classic()+                 # simplify background  
  theme(legend.position = "none")+ # remove legend
  labs(                            # add plot labels
    title = "7-day rolling average of daily case incidence",
    x = "Date of admission",
    y = "Case incidence")
```

[***DANGER:*** If you get an error saying *"slide() was deprecated in tsibble 0.9.0 and is now defunct. Please use slider::slide() instead."*, it means that the `slide()` function from the **tsibble** package is masking the `slide()` function from **slider** package. Fix this by specifying the package in the command, such as `slider::slide_dbl()`.]{style="color: red;"}

<!-- You can group the data prior to using a **slider** function. For example, if you want to calculate the same 7-day rolling sum as above, but by hospital. above rolling mean delay from symptom onset to hospital admission (column `days_onset_hosp`).   -->

<!-- You can group the data by the month of symptom onset using **lubridate**'s `floor_date()` as described in the [Grouping data] page. Then, use `slide_index_dbl()` as before but set your window extent using `months()` (also from **lubridate**).  -->

<!-- f you want a rolling average by *months*, you can use **lubridate** to group the data by month, and then apply `slide_index_dbl()` as below shown for a three-month rolling average:   -->

<!-- ```{r} -->

<!-- months_delay <- linelist %>% -->

<!--   arrange(date_onset) %>%    # drop rows missing date of onset -->

<!--   group_by(hospital) %>%  -->

<!--   #group_by(month_onset = floor_date(date_onset, "month")) %>% # create and group by month of onset  -->

<!--   mutate( -->

<!--     delay_7d = slide_index_dbl( -->

<!--       days_onset_hosp,                  # calculate avg based on value in new_cases column -->

<!--       .i = date_onset,                 # index column is date_onset, so non-present dates are included in 7day window  -->

<!--       .f = ~mean(.x, na.rm = TRUE),     # function is mean() with missing values removed -->

<!--       .before = days(7)), -->

<!--     delay_month = slide_index_dbl( -->

<!--       days_onset_hosp,                  # calculate avg based on value in new_cases column -->

<!--       .i = date_onset,                 # index column is date_onset, so non-present dates are included in 7day window  -->

<!--       .f = ~mean(.x, na.rm = TRUE),     # function is mean() with missing values removed -->

<!--       .before = months(1)))               # window is the month and the prior month -->

<!-- # window is the month and the prior month -->

<!-- ``` -->

<!-- ```{r} -->

<!-- ggplot(data = months_delay, mapping = aes(x = month_onset))+ -->

<!--   geom_line(mapping = aes(y = )) -->

<!-- ``` -->

<!-- ======================================================= -->

## Calculate with **tidyquant** within `ggplot()`

The package **tidyquant** offers another approach to calculating moving averages - this time from *within* a `ggplot()` command itself.

Below the `linelist` data are counted by date of onset, and this is plotted as a faded line (`alpha` \< 1). Overlaid on top is a line created with `geom_ma()` from the package **tidyquant**, with a set window of 7 days (`n = 7`) with specified color and thickness.

By default `geom_ma()` uses a simple moving average (`ma_fun = "SMA"`), but other types can be specified, such as:

-   "EMA" - exponential moving average (more weight to recent observations)\
-   "WMA" - weighted moving average (`wts` are used to weight observations in the moving average)\
-   Others can be found in the function documentation

```{r}
linelist %>% 
  count(date_onset) %>%                 # count cases per day
  drop_na(date_onset) %>%               # remove cases missing onset date
  ggplot(aes(x = date_onset, y = n))+   # start ggplot
    geom_line(                          # plot raw values
      size = 1,
      alpha = 0.2                       # semi-transparent line
      )+             
    tidyquant::geom_ma(                 # plot moving average
      n = 7,           
      size = 1,
      color = "blue")+ 
  theme_minimal()                       # simple background
```

See this [vignette](https://cran.r-project.org/web/packages/tidyquant/vignettes/TQ04-charting-with-tidyquant.html) for more details on the options available within **tidyquant**.

<!-- ## Rolling regression  -->

<!-- ```{r} -->

<!-- a <- linelist %>% -->

<!--   separate(time_admission, into = c("hour", "minute"), sep = ":") %>%  -->

<!--   count(days_onset_hosp, hour) %>%  -->

<!--   mutate(reg_admit_hour = slide(., ~lm(days_onset_hosp ~ hour), .before = 3, .complete = T)) %>%  -->

<!--   mutate(coeff = reg_admit_hour[[1]]) -->

<!-- ggplot()+ -->

<!--   geom_point(aes(x = hour, y = days_onset_hosp)) -->

<!-- ``` -->

<!-- ```{r} -->

<!-- linelist %>%  -->

<!--   mutate( -->

<!--   ) -->

<!-- ``` -->

<!-- ======================================================= -->

## Resources

See the helpful online [vignette for the **slider** package](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)

The **slider** [github page](https://github.com/DavisVaughan/slider)

A **slider** [vignette](https://davisvaughan.github.io/slider/articles/slider.html)

[tidyquant vignette](https://cran.r-project.org/web/packages/tidyquant/vignettes/TQ04-charting-with-tidyquant.html)

If your use case requires that you "skip over" weekends and even holidays, you might like **almanac** package.

---
editor_options: 
  markdown: 
    wrap: 72
---

# 調査データ分析

<!-- ======================================================= -->

## 概要

このページでは、調査データ分析のためのいくつかのパッケージの使用方法を説明します。

ほとんどの調査用Rパッケージは、重み付け分析を行うために[**survey**パッケージ](https://cran.r-project.org/web/packages/survey/index.html)に依存しています。ここでは、[**srvyr**](https://cran.r-project.org/web/packages/srvyr/index.html)（Tidyverseスタイルのコーディングを可能にする**survey**のラッパー）および[**gtsummary**](https://cran.r-project.org/web/packages/gtsummary/index.html)（出版準備の整った表を可能にする**survey**のラッパー）と同様に**survey**を使用します。オリジナルの**survey**パッケージでは、Tidyverseスタイルのコーディングはできませんが、survey-weighted
generalised linear
modelを使用できるという利点があります（これは後日このページに追加されます）。また、[**sitrep**](https://github.com/R4EPI/sitrep)パッケージの関数を使用して、サンプリングウェイトを作成するデモを行います（注：このパッケージは現在CRANにはまだありませんが、githubからインストールできます）。

このページのほとんどは、[「R4Epis」プロジェクト](https://r4epis.netlify.app/)で行われた作業に基づいています。詳細なコードとR-markdownテンプレートについては、[「R4Epis」のgithubページ](https://github.com/R4EPI/sitrep)を参照してください。**Survey**パッケージベースのコードの一部は、[EPIETケーススタディ](https://github.com/EPIET/RapidAssessmentSurveys)の初期バージョンに基づいています。

現在、このページではサンプルサイズの計算やサンプリングについては触れていません。簡単に利用できるサンプルサイズ計算機については、[OpenEpi](https://www.openepi.com/Menu/OE_Menu.htm)を参照してください。ハンドブックの[GIS
basics](https://epirhandbook.com/gis-basics.html)ページには、いずれ空間的ランダムサンプリングのセクションが設けられ、このページには、サンプルサイズの計算だけでなく、サンプリングフレームのセクションが設けられる予定です。

1.  調査データ
2.  観察期間
3.  重み付け
4.  調査デザイン対象
5.  記述的分析
6.  重み付けされた割合
7.  重み付けされた比率

<!-- ======================================================= -->

## 準備

### パッケージ {.unnumbered}

このコードチャンクは、分析に必要なパッケージのロードを示しています。このハンドブックでは
**pacman** の
`p_load()`を強調しています。`p_load()`は必要に応じてパッケージをインストールし、使用するためにパッケージを読み込みます。また、**base**
Rから`library()`でパッケージを読み込むこともできます。Rのパッケージについては[R
basics]のページを参照してください。\
ここでは、**pacman**の`p_load_gh()`関数を使って、まだCRANで公開されていないgithubのパッケージをインストールしてロードするデモも行っています。

```{r}

## CRANからパッケージを読み込む
pacman::p_load(rio,          # ファイルのインポート
               here,         # ファイルの場所
               tidyverse,    # データ管理 + ggplot2のグラフ
               tsibble,      # 時系列データセットを扱う
               survey,       # 調査関数
               srvyr,        # Surveyパッケージのdplyrラッパー
               gtsummary,    # 表作成のためのsurveyパッケージ
               apyramid,     # 年齢ピラミッド作成のためのパッケージ
               patchwork,    # ggplotを組み合わせるためのパッケージ
               ggforce       # 沖積図・サンキーダイアグラム
               ) 

## load packages from github
pacman::p_load_gh(
     "R4EPI/sitrep"          # 観察期間 / 重み付け関数
)

```

### データの読み込み {.unnumbered}

本節で使用する例のデータセットです。

-   架空の死亡率調査データ
-   調査対象地域の架空の人口数
-   架空の死亡率調査データのデータ辞書

これらは、MSF
OCA倫理審査委員会が事前に承認した調査に基づいています。架空のデータセットは、[「R4Epis」プロジェクト](https://r4epis.netlify.app/)の一環として作成されました。これはすべて、[Open
Data
Kit](https://opendatakit.org/)をベースにしたデータ収集ソフトウェアである[KoboToolbox](https://www.kobotoolbox.org/)を使って収集したデータに基づいています。

Koboでは、収集したデータだけでなく、そのデータセットのデータ辞書もエクスポートすることができます。データのクリーニングが容易になり，変数や疑問を調べるのに便利なので，この方法を強くお勧めします。

[**ヒント：**Koboのデータ辞書では、調査票の"name"欄に変数名が記載されています。各変数の可能な値は、選択肢シートで指定されます。Choicesタブでは、"name"には短縮された値が、"label::english"および
"label::french"列には適切な長さの値が表示されます。**Epidict**パッケージの`msf_dict_survey()`関数を使って、Kobo辞書のExcelファイルをインポートすると、これが再フォーマットされるので、再コーディングに簡単に使えるようになります。
]{style="color: darkgreen;"}

[**注意：**サンプルデータセットは、単なるエクスポートとは異なります（Koboでは、異なる調査レベルを個別にエクスポートします）
-
異なるレベルをマージするには、以下の調査データのセクションを参照してください。]{style="color: orange;"}

データセットは **rio**パッケージの
`import()`関数を使ってインポートされます。データをインポートするさまざまな方法については、[インポートおよびエクスポート](https://epirhandbook.com/import-and-export.html)のページを参照してください。

```{r echo = FALSE}
# 調査データをRにインポートする
survey_data <- rio::import(here::here("data", "surveys", "survey_data.xlsx"))

# 辞書をRにインポートする
survey_dict <- rio::import(here::here("data", "surveys", "survey_dict.xlsx")) 

# 母集団をRにインポートする
population <- rio::import(here::here("data", "surveys", "population.xlsx"))
```

```{r eval = FALSE}
# 調査データをインポートする
survey_data <- rio::import("survey_data.xlsx")

# 辞書をRにインポートする
survey_dict <- rio::import("survey_dict.xlsx") 
```

調査の最初の10行を以下に示します。

```{r, message = FALSE, echo = FALSE}
# 表として調査データを表示する
DT::datatable(head(survey_data, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

また、適切な重みを作成するために、サンプリング集団のデータをインポートしたいと考えます。このデータはさまざまな形式で作成できますが、以下のようにすることをお勧めします（エクセルに入力するだけでもよいです）。

```{r read_data_pop_show, eval = FALSE}
# 母集団データをインポートする
population <- rio::import("population.xlsx")
```

調査の最初の10行を以下に示します。

```{r message=FALSE, echo=F}
# 表として調査データを表示する
DT::datatable(head(population, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

クラスター調査の場合は、クラスターレベルで調査の重みを加えることができます。このデータを上記のように入力することができます。また、カウント数が少ない場合は、以下のように入力して2つの列を作ることもできます。いずれにしても、調査データと一致するクラスター識別子の列と、各クラスターの世帯数の列が必要になります。

```{r cluster_counts}

## 各クラスタの世帯数を定義する
cluster_counts <- tibble(cluster = c("village_1", "village_2", "village_3", "village_4", 
                                     "village_5", "village_6", "village_7", "village_8",
                                     "village_9", "village_10"), 
                         households = c(700, 400, 600, 500, 300, 
                                        800, 700, 400, 500, 500))

```

### データクリーニング {.unnumbered}

日付列が適切な形式であることを以下で確認しています。他にもいくつかの方法がありますが（詳しくは[「日付の扱い方」](https://epirhandbook.com/working-with-dates.html)のページをご覧ください）、辞書を使って日付を定義するのが手っ取り早くて簡単です。

また、**epikit**の`age_categories()`関数を使って、年齢グループの変数を作成します（詳細は[データクリーニング](https://epirhandbook.com/cleaning-data-and-core-functions.html#num_cats)のハンドブックセクションを参照）。さらに、各クラスターがどの地区にあるかを定義する文字変数を作成します。

最後に、YES/NO変数をすべてTRUE/FALSE変数に再コード化します。このようにしなければ、これらの変数は**調査**比率関数で使用できません。

```{r cleaning}

## 辞書から日付変数名を選択する 
DATEVARS <- survey_dict %>% 
  filter(type == "date") %>% 
  filter(name %in% names(survey_data)) %>% 
  ## filter to match the column names of your data
  pull(name) # select date vars
  
## 日付を変更する 
survey_data <- survey_data %>%
  mutate(across(all_of(DATEVARS), as.Date))


## 年齢が月単位のものを年の変数に加える（12で割る）
survey_data <- survey_data %>% 
  mutate(age_years = if_else(is.na(age_years), 
                             age_months / 12, 
                             age_years))

## 年齢層変数の定義する
survey_data <- survey_data %>% 
     mutate(age_group = age_categories(age_years, 
                                    breakers = c(0, 3, 15, 30, 45)
                                    ))


## 別の変数のグループを基にした文字列変数の作成する
survey_data <- survey_data %>% 
  mutate(health_district = case_when(
    cluster_number %in% c(1:5) ~ "district_a", 
    TRUE ~ "district_b"
  ))


## 辞書からyes/noの変数名を選択する 
YNVARS <- survey_dict %>% 
  filter(type == "yn") %>% 
  filter(name %in% names(survey_data)) %>% 
  ## filter to match the column names of your data
  pull(name) # select yn vars
  
## 日付を変更する
survey_data <- survey_data %>%
  mutate(across(all_of(YNVARS), 
                str_detect, 
                pattern = "yes"))

```

<!-- ======================================================= -->

## 調査データ

アンケート調査には、さまざまなサンプリングデザインがあります。ここでは、
層化、クラスター、層化とクラスターのコードを紹介します。

上記のように、（調査の作成方法にもよりますが）各レベルのデータは、Koboから別のデータセットとしてエクスポートされます。この例では、世帯が1つのレベルで、その世帯内の個人が1つのレベルです。

この2つのレベルは、一意の識別子で結ばれています。Koboのデータセットの場合、この変数は世帯レベルでは"\_index"であり、個人レベルでは"\_parent_index"と一致します。これにより、一致する個人ごとに世帯の新しい行が作成されます。詳細はハンドブックの[結合](https://epirhandbook.com/joining-data.html)の項を参照してください。

```{r merge_data_levels, eval = FALSE}

## 個人データと世帯データを結合し、完全なデータセットを作成する
survey_data <- left_join(survey_data_hh, 
                         survey_data_indiv,
                         by = c("_index" = "_parent_index"))


## 2つのレベルの内訳を組み合わせて、特有の識別子を作成する
survey_data <- survey_data %>% 
     mutate(uid = str_glue("{index}_{index_y}"))

```

<!-- ======================================================= -->

## 観察期間

死亡率調査では、対象期間の適切な死亡率を算出するために、各個人がその場所にどのくらいの期間いたのかを知りたいです。これはすべての調査に当てはまるわけではありませんが、特に死亡率調査の場合、移動する人々や避難している人々の間で頻繁に行われるため、重要です。

これは、リコール期間（質問に答える際に参加者に報告を求める期間）としても知られています。この期間を利用して、対象期間外の死亡が報告された場合など、不適切な日付を欠損に設定することができます。

```{r recall_period}

## リコール期間の開始／終了の設定する
## データセットの日付変数に変更可能 
## (例：到着日＆質問日)
survey_data <- survey_data %>% 
  mutate(recall_start = as.Date("2018-01-01"), 
         recall_end   = as.Date("2018-05-01")
  )


# ルールに基づいて不適切な日付をNAに設定する 
## 例：開始前の到着、終了後の出発
survey_data <- survey_data %>%
      mutate(
           arrived_date = if_else(arrived_date < recall_start, 
                                 as.Date(NA),
                                  arrived_date),
           birthday_date = if_else(birthday_date < recall_start,
                                  as.Date(NA),
                                  birthday_date),
           left_date = if_else(left_date > recall_end,
                              as.Date(NA),
                               left_date),
           death_date = if_else(death_date > recall_end,
                               as.Date(NA),
                               death_date)
           )

```

次に、日付変数を使って、各個人の開始日と終了日を定義します。**sitrep**の`find_start_date()`関数を使って、日付の原因を調べ、それを使って日数（person-time）を計算します。

開始日：リコール期間内の最も早い到着イベント、リコール期間の開始日（事前に定義する）、または該当する場合はリコール開始後の日付（到着や出産など）

終了日：リコール期間内の最も早い適切な出発イベント、リコール期間の終了日のいずれか、または該当する場合はリコール終了前の日付（出発、死亡など）

```{r observation_time}

## 開始日、終了日、原因のための新しい変数を作成する
survey_data <- survey_data %>% 
     ## 調査で入力された最も古い日付を選択する
     ## 出生、世帯の到着、キャンプの到着から 
     find_start_date("birthday_date",
                  "arrived_date",
                  period_start = "recall_start",
                  period_end   = "recall_end",
                  datecol      = "startdate",
                  datereason   = "startcause" 
                 ) %>%
     ## 調査で入力された最も古い日付を選択する
     ## キャンプでの出発、死亡、調査の終了から
     find_end_date("left_date",
                "death_date",
                period_start = "recall_start",
                period_end   = "recall_end",
                datecol      = "enddate",
                datereason   = "endcause" 
               )


## 開始／終了時に存在していたものを表示（出生／死亡を除く）
survey_data <- survey_data %>% 
     mutate(
       ## リコール期間の開始日を記入する（空欄の場合） 
       startdate = if_else(is.na(startdate), recall_start, startdate), 
       ## リコール期間と等しい場合、開始原因を"Present at start"に設定する 
       ## 出生日と同じでなければ 
       startcause = if_else(startdate == recall_start & startcause != "birthday_date",
                              "Present at start", startcause), 
       ## リコール期間の終了日を記入する（空欄の場合） 
       enddate = if_else(is.na(enddate), recall_end, enddate), 
       ## リコールに等しい場合は、最終原因を"Present at end"に設定する
       ## 死亡日と同じでなければ
       endcause = if_else(enddate == recall_end & endcause != "death_date", 
                            "Present at end", endcause))


## 観察期間を日単位で設定する
survey_data <- survey_data %>% 
  mutate(obstime = as.numeric(enddate - startdate))

```

<!-- ======================================================= -->

## 重み付け

調査の重み付けをする前に、誤った観測値を削除することが重要です。例えば、負の観察期間を持つ観察値がある場合、それらをチェックする必要があります（**sitrep**の`assert_positive_timespan()`関数でこれを行うことができます）。もう1つは、空の行を削除するか（例えば`drop_na(uid)`で）、重複した行を削除するかです（詳細はハンドブックの[De-duplication]のセクションを参照してください）。同意のないものもドロップする必要があります。

この例では、除外したいケースをフィルタリングして、別のデータフレームに保存します。これにより、調査から除外されたケースを説明することができます。次に、**dplyr**の`anti_join()`関数を使用して、調査データからこれらの除外されたケースを削除します。

[**危険：**体重の変数や、調査計画に関連する変数（年齢、性別、層やクラスターの変数など）に欠損値があってはいけません。]{style="color: red;"}

```{r remove_unused_data}

## ドロップしたケースを保存しておけば、それを説明することができる（例：非同意
## もしくは、誤った村／クラスター)
dropped <- survey_data %>% 
  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == "other")

## ドロップされたケースを使用して、調査データセットから未使用の行を削除する
survey_data <- anti_join(survey_data, dropped, by = names(dropped))

```

前述のように、3つの異なる調査デザイン（層化、クラスター、層化クラスター）について、重みを追加する方法を示します。これらの研究デザインには、原住民および/または調査対象のクラスタに関する情報が必要です。この例では、層化クラスターコードを使用しますが、研究デザインに最も適したものを使用してください。

```{r survey_weights}

# 層化 ------------------------------------------------------------------------
# "surv_weight_strata"という変数を作成する
# 年齢層別、性別、健康地区の各個人の重みを含んでいる
survey_data <- add_weights_strata(x = survey_data,
                                         p = population,
                                         surv_weight = "surv_weight_strata",
                                         surv_weight_ID = "surv_weight_ID_strata",
                                         age_group, sex, health_district)

## クラスター------------------------------------------------------------------

# 1世帯あたりのインタビュー対象者の人数を得る
# 世帯（親）インデックス変数のカウントを持つ変数を追加する
survey_data <- survey_data %>%
  add_count(index, name = "interviewed")


## クラスターの重みを作成する
survey_data <- add_weights_cluster(x = survey_data,
                                          cl = cluster_counts,
                                          eligible = member_number,
                                          interviewed = interviewed,
                                          cluster_x = village_name,
                                          cluster_cl = cluster,
                                          household_x = index,
                                          household_cl = households,
                                          surv_weight = "surv_weight_cluster",
                                          surv_weight_ID = "surv_weight_ID_cluster",
                                          ignore_cluster = FALSE,
                                          ignore_household = FALSE)


# 層化クラスター --------------------------------------------------------------
# クラスターと層の調査の重みを作成する
survey_data <- survey_data %>%
  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)

```

<!-- ======================================================= -->

## 調査デザイン対象

調査デザインに合わせて調査対象を作成します。データフレームと同様に、重量比率などの計算に使用します。必要な変数がすべて作成されていることを確認してから行います。

単純無作為、層化、クラスター、層化クラスターの4つのオプションがありますが、使用しないものはコメントアウトしてください。

このテンプレートでは、2つの異なる層（健康地区AとB）に調査をクラスター化したと仮定します。したがって、全体の推定値を得るためには、クラスターと層の重みを組み合わせる必要があります。

前述したように、これを行うために2つのパッケージが用意されています。古典的なものは**survey**で、それからtidyverseに適したオブジェクトや関数を作る**srvyr**というラッパーパッケージがあります。両方ともデモを行いますが、本章のコードのほとんどは**srvyr**ベースのオブジェクトを使用することに注意してください。1つの例外は、**gtsummary**パッケージが**survey**オブジェクトしか受け付けないことです。

### Surveyパッケージ

**Survey**パッケージでは、**base**
Rコーディングを効果的に使用するため、パイプ (`%>%)` やその他の
**dplyr**構文を使用することはできません。**Survey**パッケージでは、`svydesign()`関数を使用して、適切なクラスタ、重み、層を持つ調査オブジェクトを定義します。

[**注意：**変数の前にチルダ（\~）を使う必要があります。これは、パッケージが数式に基づいて変数を割り当てる**base**
Rの構文を使用しているためです。 ]{style="color: black;"}

```{r survey_design}

# 単純無作為 ------------------------------------------------------------------
base_survey_design_simple <- svydesign(ids = ~1, # 1 for no cluster ids
                   weights = NULL,               # No weight added
                   strata = NULL,                # sampling was simple (no strata)
                   data = survey_data            # have to specify the dataset
                  )

## 層化 -----------------------------------------------------------------------
base_survey_design_strata <- svydesign(ids = ~1,  # 1 for no cluster ids
                   weights = ~surv_weight_strata, # weight variable created above
                   strata = ~health_district,     # sampling was stratified by district
                   data = survey_data             # have to specify the dataset
                  )

# クラスター ------------------------------------------------------------------
base_survey_design_cluster <- svydesign(ids = ~village_name, # cluster ids
                   weights = ~surv_weight_cluster, # weight variable created above
                   strata = NULL,                 # sampling was simple (no strata)
                   data = survey_data              # have to specify the dataset
                  )

# 層化クラスター --------------------------------------------------------------
base_survey_design <- svydesign(ids = ~village_name,      # cluster ids
                   weights = ~surv_weight_cluster_strata, # weight variable created above
                   strata = ~health_district,             # sampling was stratified by district
                   data = survey_data                     # have to specify the dataset
                  )
```

### **Srvyr**パッケージ

**Srvyr**パッケージでは、`as_survey_design()`関数を使うことができます。`as_survey_design()`関数は、上記と同じ引数を持ちますが、パイプ(`%>%`)を使うことができるので、チルダ(`~`)を使う必要はありません。

```{r survey_design_srvyr}
## 単純無作為 ------------------------------------------------------------------
survey_design_simple <- survey_data %>% 
  as_survey_design(ids = 1, # 1 for no cluster ids 
                   weights = NULL, # No weight added
                   strata = NULL # sampling was simple (no strata)
                  )
## 層化 ------------------------------------------------------------------------
survey_design_strata <- survey_data %>%
  as_survey_design(ids = 1, # 1 for no cluster ids
                   weights = surv_weight_strata, # weight variable created above
                   strata = health_district # sampling was stratified by district
                  )
## クラスター ------------------------------------------------------------------
survey_design_cluster <- survey_data %>%
  as_survey_design(ids = village_name, # cluster ids
                   weights = surv_weight_cluster, # weight variable created above
                   strata = NULL # sampling was simple (no strata)
                  )

## 層化クラスター --------------------------------------------------------------
survey_design <- survey_data %>%
  as_survey_design(ids = village_name, # cluster ids
                   weights = surv_weight_cluster_strata, # weight variable created above
                   strata = health_district # sampling was stratified by district
                  )
```

<!-- ======================================================= -->

## 記述的分析

基本的な記述的分析と視覚化は、ハンドブックの他の章で広範囲にカバーされているので、ここでは触れません。詳細は、[記述表](https://epirhandbook.com/descriptive-tables.html)、[統計検定](https://epirhandbook.com/simple-statistical-tests.html)、[プレゼンテーションのための表](https://epirhandbook.com/tables-for-presentation.html)、[ggplotの基本](https://epirhandbook.com/ggplot-basics.html)、[Rのマークダウンレポート](https://epirhandbook.com/r-markdown-reports.html)の章を参照してください。

このセクションでは、サンプルの偏りを調査し、それを視覚化する方法に焦点を当てます。また、沖積図やサンキーダイアグラムを使って、調査環境における人口の流れを視覚化することも検討します。

一般的には、以下のような記述的な分析を含めることを検討すべきです。

-   対象となるクラスター、世帯、個人の最終的な数\
-   除外された人の数とその理由
-   クラスターあたりの世帯数と世帯あたりの個人数の中央値（範囲）

### サンプリングバイアス

各年齢層の割合を、サンプルと母集団の間で比較します。これは、潜在的なサンプリングバイアスを明らかにするために重要です。同様に、これを繰り返して性別による分布を調べることもできます。

これらのp値は単なる指標であり、ソース集団と比較した研究サンプルの分布の記述的な議論（または下記の年齢ピラミッドによる視覚化）は、二項検定自体よりも重要であることに注意してください。これは、サンプルサイズを大きくすると、データを重み付けした後では無関係な差になることが多いからです。

```{r descriptive_sampling_bias, warning = FALSE}

## 調査対象者の人数と割合
ag <- survey_data %>% 
  group_by(age_group) %>% 
  drop_na(age_group) %>% 
  tally() %>% 
  mutate(proportion = n / sum(n), 
         n_total = sum(n))

## 対象集団の人数と割合
propcount <- population %>% 
  group_by(age_group) %>%
    tally(population) %>%
    mutate(proportion = n / sum(n))

## 2つの表の列を結合し、年齢別にグループ化し、二項検定を行って、
## n/totalが母集団の比率と有意に異なるかどうかを調べる
  ## ここでは、2つのデータセットの列の最後にテキストを追加している
left_join(ag, propcount, by = "age_group", suffix = c("", "_pop")) %>%
  group_by(age_group) %>%
  ## broom::tidy(binom.test())は、二項検定からデータフレームを作成し、
  ## 変数p.value, parameter, conf.low, conf.high, method, and alternativeを追加する
  ## ここではp.valueのみを使用する
  ## 信頼区間を報告したい場合は、他の列を含めることができる
  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%
  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame
  mutate(proportion_pop = proportion_pop * 100) %>%
  ## 偽陽性を補正するためにp値を調整する 
  ## （複数の年齢層をテストしたことによる）
  ## これは、多くの年齢カテゴリーがある場合にのみ違いが生じる
  mutate(p.value = p.adjust(p.value, method = "holm")) %>%
                      
  ## 0.001を超えるp値のみ示す(0.001未満は<0.001として示す)
  mutate(p.value = ifelse(p.value < 0.001, 
                          "<0.001", 
                          as.character(round(p.value, 3)))) %>% 
  
  ## 列の名前を適切に変更する
  select(
    "Age group" = age_group,
    "Study population (n)" = n,
    "Study population (%)" = proportion,
    "Source population (n)" = n_pop,
    "Source population (%)" = proportion_pop,
    "P-value" = p.value
  )
```

### 人口統計ピラミッド

人口統計（または年齢-性別）ピラミッドは、調査対象者の分布を視覚化する簡単な方法です。また、調査の層別に年齢と性別の[記述表](https://epirhandbook.com/descriptive-tables.html)を作成することも検討する価値があります。ここでは、上で作成した調査設計オブジェクトを使用して、加重比例が可能な**apyramid**パッケージを使用して説明します。[人口統計ピラミッド](https://epirhandbook.com/demographic-pyramids-and-likert-scales.html)を作成するための他のオプションについては、ハンドブックのその章で詳しく説明しています。また、`plot_age_pyramid()`という**sitrep**のラッパー関数を使用して、比率のプロットを作成するための数行のコーディングを省きます。

上のサンプリング・バイアスのセクションで見た差の正式な二項検定のように、ここでは、我々の標本化された母集団が元の母集団と実質的に異なるかどうか、そして重み付けがこの差を修正するかどうかを可視化することに興味があります。これを行うために、**ggplot**の可視化を並べて表示するために**patchwork**パッケージを使用します。詳細はハンドブックの[ggplot
tips](https://epirhandbook.com/ggplot-tips.html?q=patch#combine-plots)章のプロットの結合のセクションを参照してください。私たちは、ソース集団、重み付けされていない調査集団、重み付けされた調査集団を視覚化します。また、調査の各層ごとに視覚化することも考えられます。ここでの例では、`stack_by = "health_district"`という引数を使用します（詳細は`?plot_age_pyramid`を参照してください）。

[**注意：**ピラミッドでは、x軸とy軸が反転します。
]{style="color: black;"}

```{r weighted_age_pyramid, warning = FALSE, message = FALSE, fig.show = "hold", fig.width = 15}

## x軸の範囲とラベルを定義する ---------------------------------------------
## (これらの数値をグラフの値として更新する)
max_prop <- 35      # 表示させたい比率の上限を選ぶ 
step <- 5           # 表示させたいラベル間のスペースを選ぶ

## この部分では、上記の数値を使って、軸の区切りのベクトルを定義する
breaks <- c(
    seq(max_prop/100 * -1, 0 - step/100, step/100), 
    0, 
    seq(0 + step / 100, max_prop/100, step/100)
    )

## この部分では、上記の数値を使って、軸の範囲のベクトルを定義する
limits <- c(max_prop/100 * -1, max_prop/100)

##この部分では、上記の数値を使って、軸のラベルのベクトルを定義する
labels <-  c(
      seq(max_prop, step, -step), 
      0, 
      seq(step, max_prop, step)
    )


## プロットを個別に作成する  --------------------------------------------------

## 対象集団をプロットする
## 注:これは全体の人口を対象にして集計する必要がある（例：健康地区を除く）
source_population <- population %>%
  ## 年齢と性別がfactorであることを確認する
  mutate(age_group = factor(age_group, 
                            levels = c("0-2", 
                                       "3-14", 
                                       "15-29",
                                       "30-44", 
                                       "45+")), 
         sex = factor(sex)) %>% 
  group_by(age_group, sex) %>% 
  ## 各健康地区のカウントを足し合わせる
  summarise(population = sum(population)) %>% 
  ## グループ化を解除して全体の比率を算出する
  ungroup() %>% 
  mutate(proportion = population / sum(population)) %>% 
  ## ピラミッドをプロットする
  age_pyramid(
            age_group = age_group, 
            split_by = sex, 
            count = proportion, 
            proportional = TRUE) +
  ## Y軸のラベルのみを表示（それ以外は3つのプロットすべてに繰り返される）
  labs(title = "Source population", 
       y = "", 
       x = "Age group (years)") + 
  ## すべてのプロットのX軸を同一にする 
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)
  
  
## 重み付けされていないサンプル集団をプロットする
sample_population <- plot_age_pyramid(survey_data, 
                 age_group = "age_group", 
                 split_by = "sex",
                 proportion = TRUE) + 
  ## X軸のラベルのみを表示（それ以外は3つのプロットすべてに繰り返される）
  labs(title = "Unweighted sample population", 
       y = "Proportion (%)", 
       x = "") + 
  ## すべてのプロットのX軸を同一にする 
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)


## 重み付けされたサンプル人口をプロットする
weighted_population <- survey_design %>% 
  ## make sure the variables are factors
  mutate(age_group = factor(age_group), 
         sex = factor(sex)) %>%
  plot_age_pyramid(
    age_group = "age_group",
    split_by = "sex", 
    proportion = TRUE) +
  ## X軸のラベルのみを表示（それ以外は3つのプロットすべてに繰り返される）
  labs(title = "Weighted sample population", 
       y = "", 
       x = "")  + 
  ## すべてのプロットのX軸を同一にする 
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)

## 3つのプロットを組み合わせる  ----------------------------------------------------
## 隣接する3つのプロットを「＋」で結合する
source_population + sample_population + weighted_population + 
  ## 凡例を1つだけ表示し、テーマを定義する 
  ## テーマをplot_layout()と組み合わせるための「&」の使用法に注意する
  plot_layout(guides = "collect") & 
  theme(legend.position = "bottom",                    # move legend to bottom
        legend.title = element_blank(),                # remove title
        text = element_text(size = 18),                # change text size
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # turn x-axis text
       )
```

### 沖積図・サンキーダイアグラム

個人個人の出発地点とアウトカムを視覚化することは、概要を把握するのに非常に役立ちます。移動する人口には非常に分かりやすいアプリケーションがありますが、コホートや、個人の状態に遷移があるその他の状況など、数多くのアプリケーションがあります。これらのダイアグラムには、沖積図、サンキー、パラレルセットなど、いくつかの異なる名称があり、詳細はハンドブックの[「ダイアグラムとチャート」](https://epirhandbook.com/diagrams-and-charts.html#alluvialsankey-diagrams)の章に記載されています。

```{r visualise_population_flow}

## データの要約
flow_table <- survey_data %>%
  count(startcause, endcause, sex) %>%  # get counts 
  gather_set_data(x = c("startcause", "endcause")) %>%     # change format for plotting
  mutate(x = fct_relevel(x, c("startcause", "endcause")),  # set startcause as first level
         x = fct_recode(x, 
                        "Start \n cause" = "startcause",   # add line break (\n) after start
                        "End \n cause"   = "endcause")
        )


## データセットをプロットする
  ## x軸は開始原因と終了原因
  ## gather_set_dataでは、可能な組み合わせごとにIDを生成する
  ## yで分割すると、開始と終了の組み合わせが可能となる
  ## 値をnとすると、数となる（比率に変更することも可能）
ggplot(flow_table, aes(x, id = id, split = y, value = n)) +
  ## 性別での色分け 
  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +
  ## ラベルボックスをグレーにする
  geom_parallel_sets_axes(axis.width = 0.15, fill = "grey80", color = "grey80") +
  ## 文字の色や角度の変更する（調整が必要）
  geom_parallel_sets_labels(color = "black", angle = 0, size = 5) +
  ## y軸とx軸の調整（おそらく垂直方向のスペースが必要）
  scale_x_discrete(name = NULL, expand = c(0, 0.2)) + 
  ## 軸ラベルを削除する
  theme(
    title = element_text(size = 26),
    text = element_text(size = 26),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.text.y = element_blank(),
    panel.background = element_blank(),
    legend.position = "bottom",                    # move legend to bottom
    legend.title = element_blank(),                # remove title
  )

```

<!-- ======================================================= -->

## 重み付けされた割合

このセクションでは、重み付けされたカウント数と割合の表を、関連する信頼区間とデザイン効果とともに作成する方法を詳しく説明します。**Survey**、**srvyr**、**sitrep**、**gtsummary**の各パッケージの関数を使った4つの異なるオプションがあります。標準的な疫学スタイルの表を作成するための最小限のコーディングには、**srvyr**コードのラッパーである**sitrep**関数をお勧めしますが、これはまだCRANに掲載されておらず、将来変更される可能性があることに注意してください。それ以外では、**srvyr**がTidyverseのワークフローに最もうまく適合するのに対し、**survey**コードが長期的に最も安定していると思われます。**gtsummary**関数は多くの可能性を秘めていますが、この記事を書いている時点では実験的で不完全なもののようです。

### **Survey**パッケージ

**Survey**から`svyciprop()`関数を使用して、重み付けされた割合とそれに伴う95%信頼区間を得ることができます。適切なデザイン効果は、`svyprop()`関数ではなく、`svymean()`を使用して抽出することができます。`svyprop()`は、0と1(またはTRUE/FALSE)の間の変数しか受け付けませんので、カテゴリー変数は使えないことに注意する必要があります。

[**注：survey**由来の関数は、**srvyr**デザイン・オブジェクトも受け入れますが、ここでは一貫性を保つために**survey**デザイン・オブジェクトを使用しています。]{style="color: black;"}

```{r survey_props}

## 重み付けされたカウントを生成する
svytable(~died, base_survey_design)

## 重みのあるプロポーションを作る
svyciprop(~died, base_survey_design, na.rm = T)

## デザイン効果を得る
svymean(~died, base_survey_design, na.rm = T, deff = T) %>% 
  deff()

```

上記のような**surbey**の関数を組み合わせて、以下のように独自に定義した`svy_prop`という関数を作ることができます。この関数と**purrr**パッケージの`map()`を使って、複数の変数を反復処理し、表を作成することができます。**purrr**の詳細については、ハンドブックの[「反復」](https://epirhandbook.com/iteration-loops-and-lists.html)の章を参照してください。

```{r survey_prop_fun}
# 加重カウント、割合、信頼区間、デザイン効果を計算する関数を定義する
# xは引用符で囲まれた変数
# designは調査のデザイン対象

svy_prop <- function(design, x) {
  
  ## 興味のある変数を計算式に入れる 
  form <- as.formula(paste0( "~" , x))
  ## svytableからカウントのTRUE列だけを残す
  weighted_counts <- svytable(form, design)[[2]]
  ## 割合を計算する（100倍にして％を算出）
  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100
  ## 信頼区間を抽出し、乗算してパーセンテージを求める
  weighted_confint <- confint(weighted_props) * 100
  ## svymeanを使ってデザイン効果を計算し、TRUEの列だけを残す
  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]
  
  ## 1つのデータフレームにまとめる
  full_table <- cbind(
    "Variable"        = x,
    "Count"           = weighted_counts,
    "Proportion"      = weighted_props,
    weighted_confint, 
    "Design effect"   = design_eff
    )
  
  ## テーブルをデータフレームとして返す
  full_table <- data.frame(full_table, 
             ## remove the variable names from rows (is a separate column now)
             row.names = NULL)
  
  ## 数値を数字に戻す
  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])
  
  ## データフレームを返す
  full_table
}

## 複数の変数を反復してテーブルを作成する 
purrr::map(
  ## 関心のある変数を定義する
  c("left", "died", "arrived"), 
  ## 使用する機能とその機能を実現するための引数の状態（デザイン）
  svy_prop, design = base_survey_design) %>% 
  ## リストを単一のデータフレームにまとめる
  bind_rows() %>% 
  ## 四捨五入する
  mutate(across(where(is.numeric), round, digits = 1))

```

### **Srvyr**パッケージ

**Srvyr**では、**dplyr**の構文を使って表を作成することができます。`survey_mean()`関数が使用され、割合引数が指定されていること、また、デザイン効果の計算にも同じ関数が使用されていることに注意してください。これは、**srvyr**が、上のセクションで使われている**survey**パッケージ関数の`svyciprop()`と`svymean()`の両方を内包しているからです。

[**注：srvyr**を使ってカテゴリー変数から割合を求めることはできないようです。もしこれが必要であれば、**sitrep**を使って以下のセクションをチェックしてください。
]{style="color: black;"}

```{r srvyr_prop}

## srvyrデザイン・オブジェクトの使用
survey_design %>% 
  summarise(
    ## 重み付けされたカウントを生成する
    counts = survey_total(died), 
    ## 重み付けされた割合と信頼区間の生成する 
    ## 100倍にしてパーセンテージを算出する
    props = survey_mean(died, 
                        proportion = TRUE, 
                        vartype = "ci") * 100, 
    ## デザイン効果を生成する
    deff = survey_mean(died, deff = TRUE)) %>% 
  ## 興味のある行だけを残す
  ## (標準誤差をドロップして、割合計算を繰り返す)
  select(counts, props, props_low, props_upp, deff_deff)

```

ここでも**purrr**パッケージを使って、複数の変数を反復処理する関数を書くことができます。**purrr**の詳細については、ハンドブックの[「反復」](https://epirhandbook.com/iteration-loops-and-lists.html)の章を参照してください。

```{r srvyr_prop_fun}

# 加重カウント、割合、信頼区間、デザイン効果を計算する関数の定義する
# designは調査のデザイン対象
# xは引用符で囲まれた変数


srvyr_prop <- function(design, x) {
  
  summarise(
    ## 調査デザインオブジェクトの使用する
    design, 
    ## 重み付けされたカウントを生成する 
    counts = survey_total(.data[[x]]), 
    ## 重み付けされた割合と信頼区間の生成する
    ## 100倍にしてパーセンテージを求める 
    props = survey_mean(.data[[x]], 
                        proportion = TRUE, 
                        vartype = "ci") * 100, 
    ## デザイン効果を生み出す 
    deff = survey_mean(.data[[x]], deff = TRUE)) %>% 
  ## 変数名の追加する
  mutate(variable = x) %>% 
  ## 興味のある行だけを残す
  ## (標準誤差をドロップして、割合計算を繰り返す)
  select(variable, counts, props, props_low, props_upp, deff_deff)
  
}
  

## 複数の変数を反復してテーブルを作成する 
purrr::map(
  ## 関心のある変数を定義する
  c("left", "died", "arrived"), 
  ## 使用する機能とその機能を実現するための引数の状態（デザイン）
  ~srvyr_prop(.x, design = survey_design)) %>% 
  ## リストを単一のデータフレームにまとめる
  bind_rows()
  

```

### **Sitrep**パッケージ

**Sitrep**の`tab_survey()`関数は、**srvyr**のラッパーであり、最小限のコーディングで重み付けされた表を作成することができます。また、カテゴリカル変数の加重割合を計算することもできます。

```{r sitrep_props}

## 調査デザインオブジェクトの使用する
survey_design %>% 
  ## 興味のある変数の名前を引用せずに渡す
  tab_survey(arrived, left, died, education_level,
             deff = TRUE,   # デザイン効果の算出する
             pretty = TRUE  # 割合と95%信頼区間を統合する
             )

```

### **Gtsummary**パッケージ

**Gtsummary**には、信頼区間やデザイン効果を追加するための組み込み関数がまだないようです。ここでは、信頼区間を追加するための関数を定義し、`tbl_svysummary()`関数を使って作成した**gtsummary**テーブルに信頼区間を追加する方法を示します。

```{r gtsummary_table}


confidence_intervals <- function(data, variable, by, ...) {
  
  ## 信頼区間を抽出し、乗算してパーセンテージを求める
  props <- svyciprop(as.formula(paste0( "~" , variable)),
              data, na.rm = TRUE)
  
  ## 信頼区間を抽出する
  as.numeric(confint(props) * 100) %>% ## 数値化してパーセンテージを乗算する
    round(., digits = 1) %>%           ## 1桁に四捨五入する
    c(.) %>%                           ## 行列から数値を抽出する
    paste0(., collapse = "-")          ## 1つの文字列にまとめる
}

## surveyパッケージデザインオブジェクトを使用する
tbl_svysummary(base_survey_design, 
               include = c(arrived, left, died),   ## 含めたい変数を定義する
               statistic = list(everything() ~ c("{n} ({p}%)"))) %>% ## 興味のある統計量を定義する
  add_n() %>%  ## 重み付けされた総数を加える
  add_stat(fns = everything() ~ confidence_intervals) %>% ## 信頼区間を加える
  ## カラムのヘッダーを変更する
  modify_header(
    list(
      n ~ "**Weighted total (N)**",
      stat_0 ~ "**Weighted Count**",
      add_stat_1 ~ "**95%CI**"
    )
    )

```

<!-- ======================================================= -->

## 重み付けされた比率

同様に、（死亡率のような）重み付けされた比率については、**survey**や**srvyr**パッケージを使うことができます。さらに、複数の変数を反復処理する関数（上記のものと同様）を書くこともできます。上記のように**gtsummary**のための関数を作ることもできますが、現在のところ内蔵の機能はありません。

### **Survey**パッケージ

```{r survey_ratio}

ratio <- svyratio(~died, 
         denominator = ~obstime, 
         design = base_survey_design)

ci <- confint(ratio)

cbind(
  ratio$ratio * 10000, 
  ci * 10000
)

```

### **Srvyr**パッケージ

```{r srvyr_ratio}

survey_design %>% 
  ## 観察期間を考慮した調査比率 
  summarise(
    mortality = survey_ratio(
      as.numeric(died) * 10000, 
      obstime, 
      vartype = "ci")
    )

```

<!-- ======================================================= -->

## リソース

[UCLA統計ページ](https://stats.idre.ucla.edu/r/seminars/survey-data-analysis-with-r/)

[アンケートデータを無料で分析](http://asdfree.com/)

[srvyrパッケージ](http://gdfe.co/srvyr/)

[gtsummaryパッケージ](http://www.danieldsjoberg.com/gtsummary/reference/index.html)

[EPIET調査のケーススタディ](https://github.com/EPIET/RapidAssessmentSurveys)

# 反復、ループ、リスト {\# iteration}

疫学者は、しばしば、国、地区、年齢階級などに層別化されたサブグループを対象として同じ分析を繰り返す必要に迫られます。このほかにも、非常にたくさんの場面で*反復処理*が必要となります。以下では、より速く、より正確に、より短く、このような反復処理をコードする方法を示します。

このページでは、反復処理を行うための2つの方法、すなわち、*for ループ*を使用する方法と **purrr** パッケージを使用する方法を紹介します。

1)  一連の入力に対してコードを反復する *for ループ* は、他のプログラミング言語に比べて R ではあまり一般的ではありません。しかし、ここでは学習の一貫として参考までに紹介します。

2)  **purrr** パッケージは、反復処理に対する **tidyverse** パッケージ群の中の反復処理を行うためのパッケージであり、多くの入力（値、列、データセットなど）に対して関数を "マッピング" することで機能します。

反復処理のコードの紹介の中で、以下のような内容にも触れます。

-   複数のファイルのインポート／エクスポート
-   複数の管轄区ごとの流行曲線の作成
-   データフレーム内の複数の列に対する T 検定の実行

また、**purrr** [セクション](#iter_purrr)では、`リスト`の作成と処理の例をいくつか紹介します。

## 準備

### パッケージの読み込み {.unnumbered}

次のコードチャンクは、分析に必要なパッケージの読み込みを示しています。このハンドブックでは，**pacman**の`p_load()`を用いています。`p_load()`は，必要に応じてパッケージをインストールし，*そして*パッケージの読み込みまで行ってくれます。R の **base** パッケージ内の `library()` を用いても、パッケージの読み込みを行うことが出来ます。パッケージの詳細については [R の基本]のページを参照してください。 

```{r}
pacman::p_load(
     rio,         # インポート／エクスポートのためのパッケージ
     here,        # ファイルの場所の指定のためのパッケージ
     purrr,       # 反復処理のためのパッケージ
     tidyverse    # データ管理と視覚化のためのパッケージ
)
```

### データのインポート {.unnumbered}

エボラ出血熱のシミュレーション症例のデータセットをインポートします。同じように行いたい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>クリックして"クリーニングされた（cleaned）" linelist をダウンロードしてください</a>（.rds ファイル）。データをインポートする際には、**rio** パッケージの `import()` 関数を使用します（.xlsx, .csv, .rds などの多くのファイルを扱うことができます - 詳細は [Import and export] ページをご覧ください）。

```{r, echo=F}
# linelist を R にインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# linelist をインポートする
linelist <- import("linelist_cleaned.rds")
```

linelist の始めの50行が示されています。

```{r, message=FALSE, echo=F}
# linelist データをテーブルとして表示する
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

<!-- ======================================================= -->

## *for ループ*

### R における *for ループ* {#iter_loops .unnumbered}

*for ループ*は R ではあまり取り沙汰されることがないですが、他のプログラミング言語では一般的な方法です。初心者の場合、特に自分で関数を書くことに慣れていないときには、反復処理ごとに何が起こっているのかを正確に把握し、"探索"したりや"デバッグ"を行ったりすることが容易になるため、学習や練習に役立ちます。

*for ループ*を飛ばして、**purrr** パッケージのマッピングされた関数を使用して反復処理を行う方法へ移動しても構いません。（[以下のセクション](#iter_purrr)を参照）。

### 中心となる要素 {.unnumbered}

*for ループ*は 3 つの主要な部分から成り立っています。

1) 繰り返し実行するアイテムの**シーケンス**。
2) シーケンス内の各アイテムに対して実行される**オペレーション** 
3) 結果を格納する**コンテナ** (オプション)

基本的な構文は以下の通りです。基本的な構文は、`for (アイテム in シーケンス) {アイテムを用いたオペレーションの指示}`です。括弧と中括弧に注意してください。結果は、コンソールに出力したり、コンテナに格納したりすることができます。

簡単な *for ループ*の例を以下に示します。

```{r}
for (num in c(1,2,3,4,5)) {  # シーケンスの定義 (1 から 5 の数) と "{" によるループの開始
  print(num + 2)             # オペレーション (それぞれのシーケンス内の数に 2 を足して表示してください)
}                            # "}" によるループの終了                            
                             # この例ではコンテナは示していません
```

### シーケンス {.unnumbered}

これは、*for ループ*において "for" で示されている部分です。オペレーションはシーケンス内の各アイテムに対して ("for" each item) 実行されます。シーケンスには、一連の値（管轄区名、疾患名、列名、リスト要素など）や、一連の連続した数値（1, 2, 3, 4, 5 など）を指定することができます。以下に説明するように、それぞれに実用性があります。

シーケンス文の基本構造は，`アイテム in ベクトル`です．

- "アイテム"の部分には任意の文字や単語を書くことができます（例："i", "num", "hosp", "district" など）。この"アイテム"の値は、ループを繰り返すたびにベクトル内の各値に順番に変化していきます。
- *ベクトル*には、文字列や列名、あるいは数字列などを用いることが出来ます。ループを繰り返すたびに順番に変化していく値であり、これらの値は、"アイテム"を用いたオペレーションの指示により、"for ループ"の中で使用されます。

**例: 文字列のシーケンス**

この例では、あらかじめ定義された病院名の文字ベクトル内の各値に対してループを実行します。

```{r}
# 病院名のベクトルを作成する
hospital_names <- unique(linelist$hospital)
hospital_names # 表示する
```

ここでは、`hospital_names` の値を、`hosp` という用語を使って示しています。ループの最初の繰り返しでは、`hosp` の値は `hospital_names[[1]]` となります。2回目のループでは`hospital_names[[2]]`となります。といった具合になります。

```{r, eval=F}
# 文字列シーケンスに対する 'for ループ'

for (hosp in hospital_names){       # シーケンス
  
       # オペレーションがここに来ます
  }
```

**例: 列名のシーケンス**

これは、上記の文字列のバリエーションで、既存の R オブジェクトの名前（例えば、データフレームの列名など）を抽出してベクトルとするものです。便利なことに，*for ループ*のオペレーションコードでは，列名を用いて元のデータフレームを*インデックス*（サブセット）することが出来ます。

下の例では、シーケンスとして `linelist` データフレームの `names()`（列名）を指定しています。"アイテム"の名前は `col` で、ループが繰り返すのに従って各列名を表していきます。

例として、*for ループ*の中に、シーケンスの各値に対して実行されるオペレーションを加えます。このコードでは、シーケンスの値（列名）を使って、`linelist` を順番に*インデックス*（サブセット）しています。[R の基本]の章で説明したように、2 重ブランケット `[[ ]]` は、サブセットするのに用いられます。ループにより指定された列は `is.na()`、次に `sum()` に渡され、列内の欠損値の数が算出されます。結果は各列に対して1 つの数値がコンソールに表示されます。

列名を用いてインデックスする場合の注意点 - 列自体を指定したいときには、 *単に "col" と書いてはいけません！* `col` は、単に列の名前を表しています。列内の値全体を指定するには、`linelist[[col]]` と書いて列名を `linelist` の *index* として使用する必要があります。

```{r}
for (col in names(linelist)){        # linelist内の各列に対するループ; 列名は "col" で表されている
  
  # オペレーションコードの例 - 各列の欠損地の数を表示してください 
  print(sum(is.na(linelist[[col]])))  # linelist は "col" の現在の値によってインデックスされている
     
}
```

**数のシーケンス**

この方法では、シーケンスは連続した数字の列となります。したがって、"アイテム"の値は文字値（"Central Hospital "や "date_onset "など）ではなく、数字となります。これは、データフレームをループする際に便利で、*for ループ*内で "item" の番号を使うことで、データフレームを*行番号*でインデックスすることができます。

例えば、データフレーム内のすべての行をループして、ある情報を抽出したいとします。この場合、"アイテム"は行番号になります。この場合、"アイテム"は `i` と書かれることが多いです。

*for ループ*の処理は、言葉で説明すると、「1からデータフレームの行のトータル数までの数からなるシーケンス内のすべてのアイテムに対して、Xを行う」となります。ループの最初の繰り返しでは、"アイテム" `i` の値は 1 です。2 回目の繰り返しでは、`i` は 2 になります。

このシーケンスをコードにすると、次のようになります: `for (i in 1:nrow(linelist)) {オペレーションのコード}`。`i` は"アイテム"を表し、`1:nrow(linelist)` は、1 から `linelist` のトータルの行数までの連続した数字からなるシーケンスを表しています。

```{r, eval=F}
for (i in 1:nrow(linelist)) {  # データフレームに対して使用
  # オペレーションのコードがここに来ます
}  
```

シーケンスを数字にしたいが、（データフレームではなく）ベクトルから始める場合には、ショートカットの `seq_along()` を使うことで，ベクトルの各要素に対する数字のシーケンスを得ることが出来ます。例えば，`for (i in seq_along(hospital_names) {オペレーションのコード}`とします。

以下のコードによって数字を得ることが出来、その数字がそれぞれのループの中における `i` の値になります。

```{r}
seq_along(hospital_names)  # 名前のついているベクトルに対して使用
```

シーケンスに数字を使うと、ループの出力を格納する*コンテナ*のインデックスとして、`i` 番号を簡単に使用できるという利点があります。これについては、以下のオペレーションのセクションで例を示しています。

### オペレーション {.unnumbered}

これは、*for ループ*の中の中括弧 `{ }` の中に記述されているコードです。このコードが、*シーケンス*内の各"アイテム"ごとに実行される必要があります。したがって、"アイテム"によって変化するコードのすべての部分が、実際に変化するように正しくコードされているかどうか注意する必要があります。例えば、インデックスには `[[ ]]` を使うことを忘れないでください。

以下の例では、`linelist` の各行を繰り返し処理します。各行の `gender` と `age` の値が貼り合わせ、コンテナの文字ベクトルである `cases_demographics` に格納する作業を行います。また、`[[i]]` を使ってインデックスすることで、ループの出力を"コンテナ"ベクトルの正しい位置に保存しているところもポイントです。

```{r}
# 結果を格納するコンテナを作成する - 文字ベクトル
cases_demographics <- vector(mode = "character", length = nrow(linelist))

# for ループ
for (i in 1:nrow(linelist)){
  
  # オペレーション
  # ブラケットをインデックスに用いることで、linelist の i 行の値を取り出す
  row_gender  <- linelist$gender[[i]]
  row_age     <- linelist$age_years[[i]]    # インデックスを忘れずに！
     
  # genderとageを貼り合わせ、コンテナのベクトルにおけるインデックスされた場所に格納する
  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = ",") 

}  # ループの終了


# 最初の 10 行を示す
head(cases_demographics, 10)
```

### コンテナ {.unnumbered}

*for ループ* の結果をコンソールに表示したり、RStudio プロットペインに出力したりすることがあります。また、後で使用するために出力を"コンテナ"に保存しておきたい場合もあります。出力を保存するコンテナとして、ベクトル、データフレーム、あるいはリストなどを使用することが出来ます。

結果を保存するコンテナは、*for ループ*を開始する*前に*作成するのが最も効率的です。実際には，空のベクトル、データフレーム、またはリストを作成することになります。これらは，ベクトルやリストであれば，関数 `vector()` で，データフレームであれば，関数 `matrix()` や 関数 `data.frame()` で作成することができます．

**空のベクトル**

`vector()` を使用します。また、挿入するオブジェクトのクラスに従って、`mode =` を指定します（"double"（数を格納する場合）, "character", または "logical"）。また、事前に `length =` を設定する必要があります。これは、*for ループ*のシーケンスの長さになります。

例えば、各病院の入院までの時間の中央値を格納したいとします。その場合、"double" を使用し、予想される出力数（データセット内の病院の数）を length として設定します。

```{r}
delays <- vector(
  mode = "double",                            # 数字を格納します
  length = length(unique(linelist$hospital))) # データセット内の病院の数
```

**空のデータフレーム**

次のように行と列の数を指定することで、空のデータフレームを作ることができます。

```{r, eval=F}
delays <- data.frame(matrix(ncol = 2, nrow = 3))
```

**空のリストEmpty list**

*for ループ*で作成したプロットをリストに格納したい場合もあるでしょう。リストはベクトルに似ていますが、リストは中に異なるクラスの R オブジェクトを格納することが出来ます。リストのアイテムは、数値、データフレーム、ベクトル、そして別のリストである可能性もあります。

実際に空のリストを作成するには，上記と同じ `vector()` コマンドを用いますが、`mode = "list"` とする必要があります。長さは好きなように指定してください。

```{r, eval=F}
plots <- vector(mode = "list", length = 16)
```

### 表示 {.unnumbered}

なお，*for ループ*内で表示することを指示するには、関数 `print()` で明示する必要があります。

以下の例では、シーケンスは文字ベクトルであり、これを使用して病院ごとに linelist をサブセットしています。結果はコンテナには保存されず、`print()` 関数によってコンソールに出力されています。

```{r}
for (hosp in hospital_names){ 
     hospital_cases <- linelist %>% filter(hospital == hosp)
     print(nrow(hospital_cases))
}
```

### for ループの動作確認 {.unnumbered}

ループがきちんと動作するか確認するために、`i <- 10` や `hosp <- "Central Hospital"` など、"アイテム"を一時的に代入するコマンドを実行します。これを*ループの外*で行い、その後、オペレーションコードのみ（中括弧内のコード）を実行して、期待通りの結果が得られるかどうかを確認します。

### プロットをループする {.unnumbered}

3つの要素（コンテナ、シーケンス、オペレーション）を全部使って、各病院の流行曲線をプロットしてみましょう（[Epidemic curve]のページを参照）。

以下のように **incidence2** パッケージを使って、性別ごとの*全て*の症例を示した epicurve を作ることができます。

```{r, warning=F, message=F}
# 'incidence' のオブジェクトを作成する
outbreak <- incidence2::incidence(   
     x = linelist,                   # データフレーム - linelist全体
     date_index = date_onset,        # 日付の列
     interval = "week",              # 週ごとに集計
     groups = gender,                # 性別によるグルーピング
     na_as_group = TRUE)             # 性別の欠損値は欠損のグループとして扱う

# 流行曲線をプロットする
plot(outbreak,                       # incidence のオブジェクト名
     fill = "gender",                # 性別ごとにバーの色を変更
     color = "black",                # バーの外枠の色指定
     title = "Outbreak of ALL cases" # タイトル
     )
```

各病院の症例について個別のプロットを作成するには、この流行曲線のコードを *for ループ*の中に入れます。

まず、病院名の入ったベクトル `hospital_names` を保存します。この *for ループ*は、これら病院の名前ごとに一度だけ実行されます: `for (hosp in hospital_names)`. *for ループ*が繰り返されるたびに、ベクトル内のそれぞれの病院名が `hosp` として表現され、ループ内で使用されます。

ループ内では、通常通り R のコードを書くことができますが、"アイテム"（この場合は `hosp`）の値が変化することに注意してください。このループ内では:

- 列 `hospital` が `hosp` の現在の値と等しくなるように、`linelist` に `filter()` を適用する。
- incidence オブジェクトは、フィルタリングされた linelistに対して作成される。
- 現在の病院についてのプロットには、`hosp` を用いたタイトルが自動生成されます。
- 現在の病院についてのプロットは、一時的に保存されたのちに、表示されます。
- ループは次に進み、`hospital_names` 内の次の病院に対して同じことが繰り返されます。

```{r, out.width='50%', message = F}
# 病院名のベクトルを作成する
hospital_names <- unique(linelist$hospital)

# hospital_names 内のそれぞれの病院名（"hosp"）に対して、流行曲線を作成し表示する
for (hosp in hospital_names) {
     
     # 現在の病院に対して incidence オブジェクトを作成する
     outbreak_hosp <- incidence2::incidence(
          x = linelist %>% filter(hospital == hosp),   # 現在の病院名によって linelist をフィルタリングする
          date_index = date_onset,
          interval = "week", 
          groups = gender,
          na_as_group = TRUE
     )
     
     # プロットを作成し保存する。タイトルは現在の病院名に合わせて自動生成される。
     plot_hosp <- plot(
       outbreak_hosp,
       fill = "gender",
       color = "black",
       title = stringr::str_glue("Epidemic of cases admitted to {hosp}")
     )
     
     # 現在の病院のプロットを表示する
     print(plot_hosp)
     
} # hospital_names 内の全ての病院名に対してオペレーションが行われたら for ループを終了する 
```

### ループの進行状況を確認する {.unnumbered}

反復回数の多いループは、実行終了までに何分、何時間もかかることがあります。そのため，進捗状況を R のコンソールに表示すると便利です．以下の `if` 文をループのオペレーション*の中に*配置することで、100番目の数字ごとに結果を表示することができます。コード内で用いる際には、`i`が自分の作成したループ内の"アイテム"となるように適宜変更してください。

```{r, eval=F}
# 進捗を 100 回の反復処理のたびに示すループ
for (i in seq_len(nrow(linelist))){

  # print progress
  if(i %% 100==0){    # 演算子 %% は剰余を示す
    print(i)

}
```

<!-- ======================================================= -->

## **purrr** とリスト {#iter_purrr}

反復処理のもう一つの方法として、**purrr** パッケージを用いるものがあります。これは **tidyverse** 内の反復処理を行うパッケージです。

同じタスクを何度も実行しなければならない場合、多くの入力に対して使用可能な解決策を作成することは非常に有意義です。例えば、複数の管轄区域のプロットを作成したり、多くのファイルをインポートして結合したりする場合などです。

**purrr**には他にもいくつかの利点があります。パイプ `%>%` と一緒に使用できること、通常の *for ループ*よりもエラー処理に優れていること、そして構文が非常にすっきりとしてシンプルであること、などが挙げられます。もし *for ループ*を使っているのであれば、**purrr**を使うことでより明確で簡潔にコードを書くことができるでしょう。

覚えておくべきなのは、**purrr**は*関数型のプログラミングツール*であるということです。つまり、繰り返し適用されるオペレーションは、*関数*内に示す必要があります。自分で関数を書く方法については、[Writing functions]のページを参照してください。

**purrr**はまた、多くの場合*リスト*と*ベクトル*に対して働きます - なので、リスト/ベクトルの各要素に関数を適用すると考えてください!

### パッケージの読み込み {.unnumbered}

**purrr** は **tidyverse** の一部なので、別々にパッケージをインストール/読み込む必要はありません。

```{r}
pacman::p_load(
     rio,            # インポート/エクスポート
     here,           # ファイルパス
     tidyverse,      # データの管理と視覚化
     writexl,        # 複数のシートからなるエクセルファイルを作成
     readxl          # 複数のシートからなるエクセルファイルをインポート
)
```

### `map()` {.unnumbered}

**purrr**の中核となる関数の 1 つが `map()` で、これは与えられたリストやベクトルの各入力要素に関数を「マッピング」（適用）するものです。

基本的な構文は、`map(.x = シーケンス, .f = 関数, その他の引数)`です。もう少し詳しく説明すると:

- `.x =` は、`.f` 関数が繰り返し適用される *入力* であり、例えば、管轄区名のベクトル、データフレームの列、またはデータフレームのリストです。
- `.f =` は、入力 `.x` の各要素に対して適用される *関数* です。これは、既に存在する `print()` のような関数でも、自分で定義したカスタム関数でも構いません。関数は、チルダ `~` の後に書かれることが多いです（詳細は後述）。

構文についての注意点です:

- 関数がそれ以上の引数を指定する必要がない場合は、括弧やチルダを使わずに書くことができます（例: `.f = mean`）。全ての反復処理において同じ値になる引数がある場合、`map()` の中、かつ `.f =` の外で指定します（例: `map(.x = my_list, .f = mean, na.rm = T)` の `na.rm = T`）。
- `.x` (または単に`.`)は、反復処理の `.x` 値の代用値として、`.f =` 関数*の中*で使用することができます。
- 関数をより細かく設定するには、チルダ構文（`~`）を使用してください - 関数を、括弧を用いて通常通り書いてください（例: `map(.x = my_list, .f = ~mean(., na.rm = T))`）。特に、引数の値が反復処理ごとに変化する場合や、値が `.x` 自体である場合には、この構文を使用してください（以下の例を参照）。

**`map()` を用いた際の出力は*リスト*になります** - リストはベクトルに似ていますが、構成要素が異なります。すなわち、`map()`によって生成されるリストには、多くのデータフレーム、多くのベクトル、多くの単一の値、あるいは多くのリストが含まれる可能性があります。以下に説明するように、他のタイプの出力を生成する `map()` の代替関数があります (例えば、データフレームを生成する `map_dfr()`、文字ベクトルを生成する `map_chr()`、数字ベクトルを生成する `map_dbl()` など)。

#### 例 - エクセルシートをインポートし、結合する {#iter_combined .unnumbered}

**疫学者の一般的なタスクで説明しましょう:** - *症例データの入った Excel ワークブックをインポートしたいが、データがワークブック内の異なる名前のシートに分かれているとします。どうすれば効率的にシートをインポートして 1 つのデータフレームにまとめることができるでしょうか？

以下のような Excel ワークブックが送られてきたとします。各シートには、それぞれの病院の症例が含まれています。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "hospital_linelists_excel_sheets.png"))
```

ここでは、`map()` を使った方法を紹介します。

1) 関数 `import()` を、各 Excel シートごとに実行するように `map()` する。
2) インポートされたデータフレームを `bind_rows()` を用いて 1 つにまとめる。
3) 各行の元のシート名を保存し、最終的なデータフレームの新しい列にこの情報を保存する。

まず、シート名を抽出して保存する必要があります。**readxl** というパッケージの関数 `excel_sheets()` に Excel ワークブックのファイルパスを渡して、シート名を抽出します。抽出されたシート名は、`sheet_names` という文字ベクトルに格納されます。

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")
```

これが名前です:

```{r}
sheet_names
```

これで名前のベクトルができたので、`map()` を用いて関数 `import()` に 1 つずつ名前を渡すことができます。この例では、`sheet_names` が `.x` であり、`import()` が `.f` となります。

[インポートとエクスポート]のページで説明したように、Excel のワークブックで使用する場合、`import()` 内に、インポートするシートを指定する引数 `which =` を用いることが出来ます。`.f` 関数 `import()` 内で、`which = .x` と指定していますが、ベクトル `sheet_names` を繰り返すたびに値が変化することが分かります - 最初は "Central Hospital" 、次に "Military Hospital" となります。

注意点としては、`map()` を使用しているので、各 Excel シートのデータは、リスト内のデータフレームとして別々に保存されます。各リスト要素（データフレーム）に適切な*名前*を付けるために、`sheet_names` を `map()` に渡す前に、**purrr** の `set_names()` に渡しています。

出力されたリストは `combined` という名前で保存されます。

```{r, echo=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x))
```

```{r, eval=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import("hospital_linelists.xlsx", which = .x))
```

出力を確認すると、各 Excel シートのデータが名前付きでリストに保存されていることがわかります。これでいいのですが、まだ完成ではありません。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_list.png"))
```

最後に、似たような構造のデータフレームのリストを受け取り、それらを 1 つのデータフレームに結合する関数 `bind_rows()` (**dplyr** より)を使用します。リスト要素である *names* から新しい列を作成するには、`.id =` を使用して、新しい列に必要な名前を指定します。

以下が一連のコマンドの流れです。

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x)) %>% 
  bind_rows(.id = "origin_sheet")
```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")  # シート名を抽出する
 
combined <- sheet_names %>%                                     # シート名から開始
  purrr::set_names() %>%                                        # 名前を指定
  map(.f = ~import("hospital_linelists.xlsx", which = .x)) %>%  # 反復処理を行い、インポートし、リストに保存する
  bind_rows(.id = "origin_sheet") # データフレームのリストを結合し、新しい列に元データを保存する  
```

これで元のシートが保存された列を含むデータフレームができました。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_df.png"))
```

`map()`には様々なバリエーションがあります。例えば、`map_dfr()` はリストではなく、データフレームを返します。そのため、上記のタスクに使用する場合、行を結合する必要はありません。しかし、各症例がどのシート（病院）から来たのかを把握することはできません。

他には、`map_chr()` や `map_dbl()` があります。これらは 2 つの理由から非常に便利な関数だと言えます。第一に、反復関数の出力を自動的に（リストではなく）ベクトルに変換してくれます。第二に、データがどのような形式で返ってくるかを指定することが出来ます - `map_chr()` では文字ベクトル、`map_dbl()` では数字ベクトルとしてデータが戻ってきます。これらについては、後ほど詳しくみてみましょう！

関数 `map_at()` と `map_if()` は、反復処理を行う際にも非常に便利です。インデックス/名前のベクトル（`map_at()` の場合）や、論理的テスト（`map_if()` の場合）を適用するだけで、リストのどの要素を反復処理するかを指定することが出来ます。

例えば、病院のデータの最初のシートを読みたくない場合を考えてみましょう。ここでは、`map()` の代わりに `map_at()` を使用し、`.at =` の引数に `c(-1)` を指定します。これは、`.x` の最初の要素を使用*しない*ことを意味します。また、`.at =` に正の数のベクトルや名前を指定して、使用する要素を指定することもできます。

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # 最初のシートは除く
     map_at(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x),
            .at = c(-1))
```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # 最初のシートは除く
     map_at(.f = ~import( "hospital_linelists.xlsx", which = .x),
            .at = c(-1))
```

最初のシート名は出力リストの要素として表示されますが、これは単なる文字名（データフレームではない）であることに注意してください。行を結合する前に、この要素を削除する必要があります。リストの要素を削除したり変更したりする方法については、後のセクションで説明します。

### データセットを分割しエクスポートする {.unnumbered}

以下では、データセットをパーツに分割し、`map()` の繰り返しを使って、各パーツを個別の Excel シート、または個別の CSV ファイルとしてエクスポートする方法を例示します。

#### データの分割 {.unnumbered}

例えば、コンプリートケースである `linelist` をデータフレームがあるとします。各病院ごとに個別の linelist を作成し、それぞれを個別の CSV ファイルとしてエクスポートしたいとします。次のような手順で行います:

`group_split()`（**dplyr** より）を使用して、`linelist` データフレームを列 `hospital` 内の値で分割します。出力は、すなわち、病院のサブセット別のデータフレームを含むリストを出力します。

```{r}
linelist_split <- linelist %>% 
     group_split(hospital)
```

`View(linelist_split)`を実行すると、このリストには 6 つのデータフレーム（"tibbles"）があり、それぞれが 1 つの病院の症例を表していることがわかります。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split.png"))
```

ただし、リスト内のデータフレームには、デフォルトでは名前が付いていないことに注意してください！それぞれのデータフレームに名前を付けて，CSVファイルを保存するときにその名前を使うようにしたいと思います。

名前を抽出するための方法として、**dplyr** の `pull()` を使って、リストの各データフレームから `hospital` 列を抽出する方法があります。次に、エラーの無いように、値を文字に変換してから、`unique()` を使って、データフレームの名前を得ます。これらのステップはすべて、`map()` を介して各データフレームに適用されます。

```{r}
names(linelist_split) <- linelist_split %>%   # リストされたデータフレームの名前を指定する 
     # それぞれのデータフレームに以下の関数を適用することで、名前を抽出する: 
     map(.f = ~pull(.x, hospital)) %>%        # hospital 列を取り出す
     map(.f = ~as.character(.x)) %>%          # 取り出した値を、念のため、文字に変換する
     map(.f = ~unique(.x))                    # 病院名を抽出する
```

これで，リストの各要素に名前を付けることが出来ました。これらの名前は `names(linelist_split)` で確認することが出来ます。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split_named.png"))
```

```{r}
names(linelist_split)
```

##### 2 つ以上の `group_split()` 列 {.unnumbered}

例えば、病院と性別の組み合わせで linelist のサブセットを作成するなど、*複数の列により条件づけて* linelist を分割したい場合は、リストの要素に名前を付ける際に異なる方法が必要になります。まず、**dplyr** の `group_keys()` を使って、病院・性別の全ての組み合わせに対する"グループキー"を作成します（これは、データフレームとして作成されます）。次に、以下のように、`unite()`を使ってグループキーを値に結合し、変数の組み合わせ名を`linelist_split`に割り当てます。

```{r}
# linelistを固有の病院と性別の組み合わせによって分割する
linelist_split <- linelist %>% 
     group_split(hospital, gender)

# グループキーをデータフレームとして抽出する
groupings <- linelist %>% 
     group_by(hospital, gender) %>%       
     group_keys()

groupings      # 固有のグループを表示する 
```

次に、グループ化されたものをダッシュで区切って結合し、それを `linelist_split` のリスト要素の名前として割り当てます。これには、`NA` を "Missing" に置き換え、**dplyr**の `unite()` を使って列の値をダッシュで区切って結合し、無名のベクトルに変換して、`linelist_split`の名前として使えるようにするという、追加の処理が必要になります。

```{r, eval=F}
# 一つの名前の値に結合する 
names(linelist_split) <- groupings %>% 
     mutate(across(everything(), replace_na, "Missing")) %>%  # 全ての列においてNAを "Missing" に置き換える
     unite("combined", sep = "-") %>%                         # 全ての列の値を一つに結合する
     setNames(NULL) %>% 
     as_vector() %>% 
     as.list()
```

#### エクセルシートとして出力する {.unnumbered}

**writexl** パッケージの `write_xlsx()` 関数に名前付きリストである `linelist_split` を 与えることで、病院のラインリストを、*シートごとに1つのラインリストを持つエクセルワークブック*として出力することが出来ます。この関数は、複数のシートからなるエクセルワークブックを保存する機能があります。リストの要素名がシート名として自動的に適用されます。

```{r, eval=F}
linelist_split %>% 
     writexl::write_xlsx(path = here("data", "hospital_linelists.xlsx"))
```

エクセルファイルを開くと、それぞれの病院が一つのシートに保存されているのが分かると思います。

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_sheets.png"))
```

#### CSVファイルとして出力する {.unnumbered}

少し複雑になりますが、それぞれの病院固有のラインリストを、別々のCSVファイルとして出力することもできます。ファイルの名前は病院ごとに異なる名前として出力されます。

再度、 `map()` を使用します: 上に示したように、リストの要素名のベクトルを受け取り、`map()`を使って、リスト `linelist_split` 内の同じ名前を持つデータフレームに **rio** パッケージの `export()`（[Import and export] ページを参照）を繰り返し適用します。また、この名前は、固有のファイル名を作るのに使用します。以下にその方法を示します:

-   文字名ベクターを `.x` として `map()` に与えることから始めます\

-   `.f` 関数は `export()` になります。書き込むデータフレームとファイルパスを指定する必要があります。\

-   入力された`.x` (病院名)は `.f`  *の中において* リスト`linelist_split` の固有の値を抽出し指標とするために使用されます。こうすることで、一つのデータフレームとして `export()` に適用することが出来ます。\

-   例えば、 "Military Hospital" に対して `map()` が適用される場合は、`linelist_split[[.x]]` は実際には `linelist_split[["Military Hospital"]]` のことであり、 `linelist_split` の二つ目の要素が返されます。これは、Military Hospitalの全てのケースにおいて適用されます。\

-   `export()` に適用されるファイルパスは、 `str_glue()` を使用し、流動的に設定されます([Characters and strings] ページを参照):

    -   ファイルパスの起点を得、"データ"のフォルダを特定するために `here()` が用いられます。(`str_glue()` 内で使用されている二重引用符を邪魔しないように、一重引用符を使用していることに注意してください。\

-   それから、 `/` と再び `.x` を記載し、ファイルが特定できるように現在使用中の病院名をファイル名にあてがいます。\

-   最後に、 `export()` によってCSVファイルが作成されるように拡張子 ".csv" を記します。

```{r, eval=F, message = F, warning=F}
names(linelist_split) %>%
     map(.f = ~export(linelist_split[[.x]], file = str_glue("{here('data')}/{.x}.csv")))
```

これで、それぞれのファイルがRプロジェクト "Epi_R\_handbook" の "data" フォルダ内に保存されました！

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_csv.png"))
```

### Custom functions {.unnumbered}

You may want to create your own function to provide to `map()`.

Let's say we want to create epidemic curves for each hospital's cases. To do this using **purrr**, our `.f` function can be `ggplot()` and extensions with `+` as usual. As the output of `map()` is always a list, the plots are stored in a list. Because they are plots, they can be extracted and plotted with the `ggarrange()` function from the **ggpubr** package ([documentation](https://rpkgs.datanovia.com/ggpubr/reference/ggarrange.html)).

```{r, message = F, warning=F}

# load package for plotting elements from list
pacman::p_load(ggpubr)

# map across the vector of 6 hospital "names" (created earlier)
# use the ggplot function specified
# output is a list with 6 ggplots

hospital_names <- unique(linelist$hospital)

my_plots <- map(
  .x = hospital_names,
  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +
                geom_histogram(aes(x = date_onset)) +
                labs(title = .x)
)

# print the ggplots (they are stored in a list)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

If this `map()` code looks too messy, you can achieve the same result by saving your specific `ggplot()` command as a custom user-defined function, for example we can name it `make_epicurve())`. This function is then used within the `map()`. `.x` will be iteratively replaced by the hospital name, and used as `hosp_name` in the `make_epicurve()` function. See the page on [Writing functions].

```{r, eval=F}
# Create function
make_epicurve <- function(hosp_name){
  
  ggplot(data = linelist %>% filter(hospital == hosp_name)) +
    geom_histogram(aes(x = date_onset)) +
    theme_classic()+
    labs(title = hosp_name)
  
}
```

```{r, eval=F}
# mapping
my_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))

# print the ggplots (they are stored in a list)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

### Mapping a function across columns {.unnumbered}

Another common use-case is to map a function across many columns. Below, we `map()` the function `t.test()` across numeric columns in the data frame `linelist`, comparing the numeric values by gender.

Recall from the page on [Simple statistical tests] that `t.test()` can take inputs in a formula format, such as `t.test(numeric column ~ binary column)`. In this example, we do the following:

-   The numeric columns of interest are selected from `linelist` - these become the `.x` inputs to `map()`\

-   The function `t.test()` is supplied as the `.f` function, which is applied to each numeric column\

-   Within the parentheses of `t.test()`:

    -   the first `~` precedes the `.f` that `map()` will iterate over `.x`\
    -   the `.x` represents the current column being supplied to the function `t.test()`\
    -   the second `~` is part of the t-test equation described above\
    -   the `t.test()` function expects a binary column on the right-hand side of the equation. We supply the vector `linelist$gender` independently and statically (note that it is not included in `select()`).

`map()` returns a list, so the output is a list of t-test results - one list element for each numeric column analysed.

```{r}
# Results are saved as a list
t.test_results <- linelist %>% 
  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # keep only some numeric columns to map across
  map(.f = ~t.test(.x ~ linelist$gender))        # t.test function, with equation NUMERIC ~ CATEGORICAL
```

Here is what the list `t.test_results` looks like when opened (Viewed) in RStudio. We have highlighted parts that are important for the examples in this page.

-   You can see at the top that the whole list is named `t.test_results` and has five elements. Those five elements are named `age`, `wt_km`, `ht_cm`, `ct_blood`, `temp` after each variable that was used in a t-test with `gender` from the `linelist`.\
-   Each of those five elements are themselves lists, with elements within them such as `p.value` and `conf.int`. Some of these elements like `p.value` are single numbers, whereas some such as `estimate` consist of two or more elements (`mean in group f` and `mean in group m`).

```{r, out.height="150%", echo=F}
knitr::include_graphics(here::here("images", "purrr_ttest.png"))
```

Note: Remember that if you want to apply a function to only certain columns in a data frame, you can also simply use `mutate()` and `across()`, as explained in the [Cleaning data and core functions] page. Below is an example of applying `as.character()` to only the "age" columns. Note the placement of the parentheses and commas.

```{r, eval=F}
# convert columns with column name containing "age" to class Character
linelist <- linelist %>% 
  mutate(across(.cols = contains("age"), .fns = as.character))  
```

### Extract from lists {.unnumbered}

As `map()` produces an output of class List, we will spend some time discussing how to extract data from lists using accompanying **purrr** functions. To demonstrate this, we will use the list `t.test_results` from the previous section. This is a list of 5 lists - each of the 5 lists contains the results of a t-test between a column from `linelist` data frame and its binary column `gender`. See the image in the section above for a visual of the list structure.

#### Names of elements {.unnumbered}

To extract the names of the elements themselves, simply use `names()` from **base** R. In this case, we use `names()` on `t.test_results` to return the names of each sub-list, which are the names of the 5 variables that had t-tests performed.

```{r}
names(t.test_results)
```

#### Elements by name or position {.unnumbered}

To extract list elements by name or by position you can use brackets `[[ ]]` as described in the [R basics] page. Below we use double brackets to index the list `t.tests_results` and display the first element which is the results of the t-test on `age`.

```{r}
t.test_results[[1]] # first element by position
t.test_results[[1]]["p.value"] # return element named "p.value" from first element  
```

However, below we will demonstrate use of the simple and flexible **purrr** functions `map()` and `pluck()` to achieve the same outcomes.

#### `pluck()` {.unnumbered}

`pluck()` pulls out elements by name or by position. For example - to extract the t-test results for age, you can use `pluck()` like this:

```{r}
t.test_results %>% 
  pluck("age")        # alternatively, use pluck(1)
```

Index deeper levels by specifying the further levels with commas. The below extracts the element named "p.value" from the list `age` within the list `t.test_results`. You can also use numbers instead of character names.

```{r}
t.test_results %>% 
  pluck("age", "p.value")
```

You can extract such inner elements from *all* first-level elements by using `map()` to run the `pluck()` function across each first-level element. For example, the below code extracts the "p.value" elements from all lists within `t.test_results`. The list of t-test results is the `.x` iterated across, `pluck()` is the `.f` function being iterated, and the value "p-value" is provided to the function.

```{r}
t.test_results %>%
  map(pluck, "p.value")   # return every p-value
```

As another alternative, `map()` offers a shorthand where you can write the element name in quotes, and it will pluck it out. If you use `map()` the output will be a list, whereas if you use `map_chr()` it will be a named character vector and if you use `map_dbl()` it will be a named numeric vector.

```{r}
t.test_results %>% 
  map_dbl("p.value")   # return p-values as a named numeric vector
```

You can read more about `pluck()` in it's **purrr** [documentation](https://purrr.tidyverse.org/reference/pluck.html). It has a sibling function `chuck()` that will return an error instead of NULL if an element does not exist.

### Convert list to data frame {.unnumbered}

This is a complex topic - see the Resources section for more complete tutorials. Nevertheless, we will demonstrate converting the list of t-test results into a data frame. We will create a data frame with columns for the variable, its p-value, and the means from the two groups (male and female).

Here are some of the new approaches and functions that will be used:

-   The function `tibble()` will be used to create a tibble (like a data frame)

    -   We surround the `tibble()` function with curly brackets `{ }` to prevent the entire `t.test_results` from being stored as the first tibble column\

-   Within `tibble()`, each column is created explicitly, similar to the syntax of `mutate()`:

    -   The `.` represents `t.test_results`
    -   To create a column with the t-test variable names (the names of each list element) we use `names()` as described above\
    -   To create a column with the p-values we use `map_dbl()` as described above to pull the `p.value` elements and convert them to a numeric vector

```{r}
t.test_results %>% {
  tibble(
    variables = names(.),
    p         = map_dbl(., "p.value"))
  }
```

But now let's add columns containing the means for each group (males and females).

We would need to extract the element `estimate`, but this actually contains *two* elements within it (`mean in group f` and `mean in group m`). So, it cannot be simplified into a vector with `map_chr()` or `map_dbl()`. Instead, we use `map()`, which used within `tibble()` will create *a column of class list within the tibble*! Yes, this is possible!

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate"))}
```

Once you have this list column, there are several **tidyr** functions (part of **tidyverse**) that help you "rectangle" or "un-nest" these "nested list" columns. Read more about them [here](), or by running `vignette("rectangle")`. In brief:

-   `unnest_wider()` - gives each element of a list-column its own column\
-   `unnest_longer()` - gives each element of a list-column its own row
-   `hoist()` - acts like `unnest_wider()` but you specify which elements to unnest

Below, we pass the tibble to `unnest_wider()` specifying the tibble's `means` column (which is a nested list). The result is that `means` is replaced by two new columns, each reflecting the two elements that were previously in each `means` cell.

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate")
    )} %>% 
  unnest_wider(means)
```

### Discard, keep, and compact lists {.unnumbered}

Because working with **purrr** so often involves lists, we will briefly explore some **purrr** functions to modify lists. See the Resources section for more complete tutorials on **purrr** functions.

-   `list_modify()` has many uses, one of which can be to remove a list element\
-   `keep()` retains the elements specified to `.p =`, or where a function supplied to `.p =` evaluates to TRUE\
-   `discard()` removes the elements specified to `.p`, or where a function supplied to `.p =` evaluates to TRUE\
-   `compact()` removes all empty elements

Here are some examples using the `combined` list created in the section above on [using map() to import and combine multiple files](#iter_combined) (it contains 6 case linelist data frames):

Elements can be removed by name with `list_modify()` and setting the name equal to `NULL`.

```{r, eval=F}
combined %>% 
  list_modify("Central Hospital" = NULL)   # remove list element by name
```

You can also remove elements by criteria, by providing a "predicate" equation to `.p =` (an equation that evaluates to either TRUE or FALSE). Place a tilde `~` before the function and use `.x` to represent the list element. Using `keep()` the list elements that evaluate to TRUE will be kept. Inversely, if using `discard()` the list elements that evaluate to TRUE will be removed.

```{r, eval=F}
# keep only list elements with more than 500 rows
combined %>% 
  keep(.p = ~nrow(.x) > 500)  
```

In the below example, list elements are discarded if their class are not data frames.

```{r, eval=F}
# Discard list elements that are not data frames
combined %>% 
  discard(.p = ~class(.x) != "data.frame")
```

Your predicate function can also reference elements/columns within each list item. For example, below, list elements where the mean of column `ct_blood` is over 25 are discarded.

```{r, eval=F}
# keep only list elements where ct_blood column mean is over 25
combined %>% 
  discard(.p = ~mean(.x$ct_blood) > 25)  
```

This command would remove all empty list elements:

```{r, eval=F}
# Remove all empty list elements
combined %>% 
  compact()
```

### `pmap()` {.unnumbered}

THIS SECTION IS UNDER CONSTRUCTION

## Apply functions

The "apply" family of functions is a **base** R alternative to **purrr** for iterative operations. You can read more about them [here](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family).

<!-- ======================================================= -->

## Resources

[for loops with Data Carpentry](https://datacarpentry.org/semester-biology/materials/for-loops-R/)

The [R for Data Science page on iteration](https://r4ds.had.co.nz/iteration.html#iteration)

[Vignette on write/read Excel files](https://martinctc.github.io/blog/vignette-write-and-read-multiple-excel-files-with-purrr/)

A purrr [tutorial](https://jennybc.github.io/purrr-tutorial/index.html) by jennybc

Another purrr [tutorial](http://www.rebeccabarter.com/blog/2019-08-19_purrr/) by Rebecca Barter

A purrr [tutorial](http://zevross.com/blog/2019/06/11/the-power-of-three-purrr-poseful-iteration-in-r-with-map-pmap-and-imap/) on map, pmap, and imap

[purrr cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/purrr-cheatsheet-thumbs.png)

[purrr tips and tricks](https://www.hvitfeldt.me/blog/purrr-tips-and-tricks/)

[keep and discard](https://hookedondata.org/going-off-the-map/#keep-and-discard)

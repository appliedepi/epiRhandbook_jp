
# ダイアグラムとチャート { #diagrams }  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "flow_chart.png"))
knitr::include_graphics(here::here("images", "sankey_diagram.png"))
```

このページでは、以下のものを制作するためのコードについて説明します。 

* **DiagrammeR** と DOT 言語を使ったフローダイアグラム  
* Alluvial/Sankey diagrams
* イベントタイムライン

<!-- * DAGs (Directed Acyclic Graphs)   -->
<!-- * GANTT charts   -->


<!-- ======================================================= -->
## 準備 { }

### パッケージを読み込む {.unnumbered}  

このコードチャンクは、分析に必要なパッケージの読み込みを示しています。
このハンドブックでは、**pacman** の `p_load()` を使うことを強調しています。
`p_load()` は、必要に応じてパッケージをインストールし、<u>そして</u>使用するためにパッケージを読み込みます。
base R から `library()` を使用してインストール済みパッケージを読み込むこともできます。
R のパッケージについての詳細は [**base** R] のページを参照してください。 

```{r}
pacman::p_load(
  DiagrammeR,     # フロー図
  networkD3,      # alluvial/Sankey 図
  tidyverse)      # データ管理と図作成
```

### データをインポート {.unnumbered}  

このページではほとんどデータセットを必要としません。しかし、サンキーダイアグラム（Sankey diagram） のセクションでは、シミュレーションによるエボラ出血熱のケースの linelist を使用します。この部分を試してみたい方は、<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>クリックして「きれいな」 linelist をダウンロードしてください</a>（.rdsファイルとして）。データを **rio** パッケージの `import()` 関数を使ってインポートします（.xlsx, .csv, .rds など多くのファイルタイプを扱うことができます。詳細は [Import and export] ページをご覧ください）。 


```{r, echo=F}
# linelist を R へインポート
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# linelist をインポート
linelist <- import("linelist_cleaned.rds")
```

linelist の最初の50行が以下のように表示されます。

```{r, message=FALSE, echo=F}
# linelist を表として表示
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
## フロー図 { }

R パッケージの **DiagrammeR** を使って、チャートやフローチャートを作成することができます。グラフは静的なものもあれば、データセットの変化に基づいて動的に調整することもできます。 


**Tools**  

"Graphviz" のダイアグラムを作成するには、関数 `grViz()` を用います。この関数は、図を作成するための指示<u>を含む</u>文字列の入力を受け付けます。この文字列の中には、[DOT](https://graphviz.org/doc/info/lang.html) と呼ばれる別の言語で書かれた命令が含まれていますが、基本を学ぶのはとても簡単です。 

**基本的な構造**

1) 命令を開く `grViz("` 
2) グラフの方向性と名前を指定し、大括弧を開く 例：`digraph my_flow_chart {`
3) グラフ文(レイアウト、ランク方向)  
4) Node 文（ノードを作成）
5) Edge 文（ノード間のリンクを与える）
6) 命令を閉じる `}"`  

### 簡単な例 {.unnumbered}

以下に2つの簡単な例を示します。 

とても小さな例です。 

```{r out.width='50%'}
# A minimal plot
DiagrammeR::grViz("digraph {
  
graph[layout = dot, rankdir = LR]

a
b
c

a -> b -> c
}")
```

もう少し応用の効く公衆衛生の文脈での例です。 

```{r out.width='50%'}
grViz("                           # すべての指示は大きな文字列の中にあります。
digraph surveillance_diagram {    # digraph は directional graph という意味で、その後にグラフ名が入ります。
  
  # graph statement
  #################
  graph [layout = dot,
         rankdir = TB,
         overlap = true,
         fontsize = 10]
  
  # nodes
  #######
  node [shape = circle,           # shape = circle
       fixedsize = true
       width = 1.3]               # circle の大きさ
  
  １番目                          # node の名称
  ２番目
  ３番目

  # edges
  #######
  １番目   -> ２番目 [label = 'ケース移送']
  ２番目   -> ３番目 [label = 'ケース移送']
}
")
```

### 文法  {.unnumbered}

**基本的な構文**

ノード名、またはエッジ文は、スペース、セミコロン、または改行で区切ることができます。 

**ランクの方向**

graph 文の `rankdir` 引数を調整することで、プロットを左から右へと移動させることができます。デフォルトは TB (top-to-bottom)ですが、LR (left-to-right)、RL、BT のいずれかを指定できます。 

**ノード名**

ノード名は、上の例のように単一の単語で構いません。複数の単語や特殊文字（括弧やダッシュなど）を使用する場合は、ノード名を一重引用符（' '）で囲みます。ノード名を短くして、以下のように大括弧[ ]で囲んで<u>ラベル</u>を割り当てる方が簡単な場合があります。ノード名の中に改行を入れたい場合は、ラベルを介して行う必要があります。以下のように、一重引用符で囲んだノードラベルの中に `\n` を使用してください。 

**サブグループ**

エッジ文の中で、サブグループはエッジの両側に波括弧（{ }）で作成できます。エッジは括弧内のすべてのノードに適用されます。これは省略可能です。 

**レイアウト**  

* dot (`rankdir` を TB, LR, RL, BT のいずれかに設定 )
* neato
* twopi
* circo

**ノード - 属性値**  

* `label` (テキスト、半角スペースを含む場合はシングルクォートで囲む)  
* `fillcolor` (多数の色が使用可能)  
* `fontcolor`  
* `alpha` (透明度 0-1)  
* `shape` (ellipse, oval, diamond, egg, plaintext, point, square, triangle)  
* `style`  
* `sides`  
* `peripheries`  
* `fixedsize` (h x w)  
* `height`  
* `width`  
* `distortion`  
* `penwidth` （境界線の太さ）
* `x` (displacement left/right)  
* `y` (displacement up/down)  
* `fontname`  
* `fontsize`  
* `icon`  

**エッジ - 属性値**  

* `arrowsize`  
* `arrowhead` (normal, box, crow, curve, diamond, dot, inv, none, tee, vee)  
* `arrowtail`  
* `dir` (direction, )  
* `style` (dashed, ...)  
* `color`  
* `alpha`  
* `headport` （矢印の前のテキスト）
* `tailport` （矢印の後のテキスト）
* `fontname`  
* `fontsize`  
* `fontcolor`  
* `penwidth` （矢の太さ）
* `minlen` （長さの最長値）

**色名**: 16進数の値または 'X11' の色名、[X11の詳細はこちら](http://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html)を参照してください。

### 複雑な例 {.unnumbered}

以下の例は surveillance_diagram を発展させたもので、複雑なノード名、グループ化されたエッジ、色、スタイルを追加しています。

```
DiagrammeR::grViz("               # すべての指示は大きな文字列の中にあります。
digraph surveillance_diagram {    # digraph は directional graph という意味で、その後にグラフ名が入ります。
  
  # graph 文
  #################
  graph [layout = dot,
         rankdir = TB,            # layout top-to-bottom
         fontsize = 10]
  

  # ノード (円)
  #################
  node [shape = circle,           # shape = circle
       fixedsize = true
       width = 1.3]                      
  
  Primary   [label = '第一\n施設'] 
  Secondary [label = '第二\n施設'] 
  Tertiary  [label = '第三\n施設'] 
  SC        [label = 'Surveillance\nCoordination',
             fontcolor = darkgreen] 
  
  # エッジ
  #######
  Primary   -> Secondary [label = ' 症例移送',
                          fontcolor = red,
                          color = red]
  Secondary -> Tertiary [label = ' 症例移送',
                          fontcolor = red,
                          color = red]
  
  # エッジのグループ
  {Primary Secondary Tertiary} -> SC [label = '症例報告',
                                      fontcolor = darkgreen,
                                      color = darkgreen,
                                      style = dashed]
}
")
```


```{r out.width='50%', echo=F}
DiagrammeR::grViz("               # すべての指示は大きな文字列の中にあります。
digraph surveillance_diagram {    # digraph は directional graph という意味で、その後にグラフ名が入ります。
  
  # graph 文
  #################
  graph [layout = dot,
         rankdir = TB,            # layout top-to-bottom
         fontsize = 10]
  

  # ノード (円)
  #################
  node [shape = circle,           # shape = circle
       fixedsize = true
       width = 1.3]                      
  
  Primary   [label = '第一\n施設'] 
  Secondary [label = '第二\n施設'] 
  Tertiary  [label = '第三\n施設'] 
  SC        [label = 'サーベイランス\nCoordination',
             fontcolor = darkgreen] 
  
  # エッジ
  #######
  Primary   -> Secondary [label = '症例移送',
                          fontcolor = red,
                          color = red]
  Secondary -> Tertiary [label = '症例移送',
                          fontcolor = red,
                          color = red]
  
  # エッジグループ
  {Primary Secondary Tertiary} -> SC [label = '症例報告',
                                      fontcolor = darkgreen,
                                      color = darkgreen,
                                      style = dashed]
}
")
```

**サブグラフのクラスター**

ノードをボックス型のクラスターにまとめるには、同じ名前のサブグラフ（`subgraph name {}`）の中にノードを入れます。各サブグラフをバウンディングボックス内で識別するには、以下の4つのボックスで示すように、サブグラフの名前を "cluster" で始めます。 


```
DiagrammeR::grViz("             # すべての指示は大きな文字列の中にあります。
digraph surveillance_diagram {  # digraph は directional graph という意味で、その後にグラフ名が入ります。
  
  # graph 文
  #################
  graph [layout = dot,
         rankdir = TB,            
         overlap = true,
         fontsize = 10]
  

  # ノード (円)
  #################
  node [shape = circle,                  # shape = circle
       fixedsize = true
       width = 1.3]                      # width of circles
  
  subgraph cluster_passive {
    Primary   [label = '第一\n施設] 
    Secondary [label = '第二\n施設'] 
    Tertiary  [label = '第三\n施設'] 
    SC        [label = 'サーベイランス\nCoordination',
               fontcolor = darkgreen] 
  }
  
  # ノード (ボックス)
  ###############
  node [shape = box,                     # node shape
        fontname = Helvetica]            # text font in node
  
  subgraph cluster_active {
    Active [label = 'Active\nサーベイランス'] 
    HCF_active [label = 'HCF\nActive Search']
  }
  
  subgraph cluster_EBD {
    EBS [label = 'イベントベース\nサーベイランス (EBS)'] 
    社会メディア
    ラジオ
  }
  
  subgraph cluster_CBS {
    CBS [label = '地域参加型\nサーベイランス (CBS)']
    RECOs
  }

  
  # エッジ
  #######
  {Primary Secondary Tertiary} -> SC [label = '症例報告']

  Primary   -> Secondary [label = 'ケース移送',
                          fontcolor = red]
  Secondary -> Tertiary [label = 'ケース移送',
                          fontcolor = red]
  
  HCF_active -> Active
  
  {社会メディア ラジオ} -> EBS
  
  RECOs -> CBS
}
")

```


```{r out.width='120%', echo=F}
DiagrammeR::grViz("             # すべての指示は大きな文字列の中にあります。
digraph surveillance_diagram {  # digraph は directional graph という意味で、その後にグラフ名が入ります。
  
  # graph 文
  #################
  graph [layout = dot,
         rankdir = TB,            
         overlap = true,
         fontsize = 10]
  

  # ノード (円)
  #################
  node [shape = circle,                  # shape = circle
       fixedsize = true
       width = 1.3]                      # width of circles
  
  subgraph cluster_passive {
    Primary   [label = '第一\n施設'] 
    Secondary [label = '第二\n施設'] 
    Tertiary  [label = '第三\n施設'] 
    SC        [label = 'サーベイランス\nCoordination',
               fontcolor = darkgreen] 
  }
  
  # ノード (ボックス)
  ###############
  node [shape = box,                     # node shape
        fontname = Helvetica]            # text font in node
  
  subgraph cluster_active {
    Active [label = 'Active\nサーベイランス'] 
    HCF_active [label = 'HCF\nActive Search']
  }
  
  subgraph cluster_EBD {
    EBS [label = 'イベントベース\nサーベイランス (EBS)'] 
    社会メディア
    ラジオ
  }
  
  subgraph cluster_CBS {
    CBS [label = '地域参加型\nサーベイランス (CBS)']
    RECOs
  }

  
  # エッジ
  #######
  {Primary Secondary Tertiary} -> SC [label = 'case reporting']

  Primary   -> Secondary [label = 'ケース移送',
                          fontcolor = red]
  Secondary -> Tertiary [label = 'ケース移送',
                          fontcolor = red]
  
  HCF_active -> Active
  
  {社会メディア ラジオ} -> EBS
  
  RECOs -> CBS
}
")

```

**ノードの形状**

以下の例は、[このチュートリアル](http://rich-iannone.github.io/DiagrammeR/) から借用したもので、適用されたノード形状と、連続するエッジ接続の略記法を示しています。 

```{r out.width='75%'}
DiagrammeR::grViz("digraph {

graph [layout = dot, rankdir = LR]

# ノードのグローバルなスタイルを定義します。必要に応じてボックス内でこれらを上書きすることができます。
node [shape = rectangle, style = filled, fillcolor = Linen]

data1 [label = 'データ 1', shape = folder, fillcolor = Beige]
data2 [label = 'データ 2', shape = folder, fillcolor = Beige]
process [label =  'データ \n 処理']
statistical [label = '統計 \n 解析']
results [label= '結果']

# ノードIDを持つエッジ定義
{data1 data2}  -> process -> statistical -> results
}")
```

### 出力 {.unnumbered}

出力の取り扱いと保存方法  

* 出力結果は RStudio のビューアに表示されます。デフォルトでは右下に Files, Plots, Packages, Help と並んで表示されます。 
* エクスポートするには、Veiwer から "Save as image” または “Copy to clipboard” します。画像は指定したサイズに調整されます。 

### パラメータ化された図形 {.unnumbered}

以下は、このチュートリアルからの引用です。https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/  

「パラメータ化された図形: Rで図形を設計することの大きな利点は、Rの値をフローチャートに直接読み込んで、図形を分析に直結させることができることです。例えば、プロセスの各段階の後に値を削除するフィルタリングプロセスを作成したとすると、プロセスの各段階の後にデータセットに残っている値の数を図に表示することができます。これを実現するには、図の中で @@X 記号を直接使用し、プロットのフッターで [X]: を使用して参照します（Xは一意の数値インデックス）。"  

パラメタライズに興味をお持ちの方は、このチュートリアルをご覧ください。 

<!-- And below is some example code from this tutorial. -->

<!-- ```{r, eval=F} -->
<!-- # Define some sample data -->
<!-- data <- list(a=1000, b=800, c=600, d=400) -->


<!-- DiagrammeR::grViz(" -->
<!-- digraph graph2 { -->

<!-- graph [layout = dot] -->

<!-- # node definitions with substituted label text -->
<!-- node [shape = rectangle, width = 4, fillcolor = Biege] -->
<!-- a [label = '@@1'] -->
<!-- b [label = '@@2'] -->
<!-- c [label = '@@3'] -->
<!-- d [label = '@@4'] -->

<!-- a -> b -> c -> d -->

<!-- } -->

<!-- [1]:  paste0('Raw Data (n = ', data$a, ')') -->
<!-- [2]: paste0('Remove Errors (n = ', data$b, ')') -->
<!-- [3]: paste0('Identify Potential Customers (n = ', data$c, ')') -->
<!-- [4]: paste0('Select Top Priorities (n = ', data$d, ')') -->
<!-- ") -->

<!-- ``` -->



<!-- ### CONSORT diagram  {.unnumbered} -->

<!-- THIS SECTION IS UNDER CONSTRUCTION   -->

<!-- https://scriptsandstatistics.wordpress.com/2017/12/22/how-to-draw-a-consort-flow-diagram-using-r-and-graphviz/ -->

<!-- Note above is out of date via DiagrammeR -->




<!-- ======================================================= -->
## 沖積図/サンキー・ダイアグラム { }

### パッケージを読み込み {.unnumbered}

このコードチャンクは、解析に必要なパッケージの読み込みを示しています。
このハンドブックでは、**pacman** の `p_load()` を使うことを強調しています。
`p_load()` は、必要に応じてパッケージをインストールし、<u>そして</u>使用するためにパッケージを読み込みます。
base R から `library()` を使用してインストール済みパッケージを読み込むこともできます。
R パッケージの詳細については [R basics] のページを参照してください。 

ここでは、図を作成するために **networkD3** パッケージを読み込み、データ準備の手順として **tidyverse** も読み込んでいます。 

```{r}
pacman::p_load(
  networkD3,
  tidyverse)
```

### データセットからプロット {.unnumbered}

データセット内の接続をプロットします。以下では、このパッケージを `linelist` というケースで使ってみます。こちらは[オンラインチュートリアル](https://www.r-graph-gallery.com/321-introduction-to-interactive-sankey-diagram-2.html)です。   

まず、年齢区分と病院の組み合わせごとに、ケース数を取得します。わかりやすくするために、年齢区分が欠落している値は削除しました。また、`hospital` 列と `age_cat` 列のラベルをそれぞれ `source` と `target` に変更します。これらは沖積図 (alluvial diagram) の2つの面になります。 

```{r}
# 病院と年齢区分で集計
links <- linelist %>% 
  drop_na(age_cat) %>% 
  select(hospital, age_cat) %>%
  count(hospital, age_cat) %>% 
  rename(source = hospital,
         target = age_cat)
```

データセットは次のようになります。 

```{r message=FALSE, echo=F}
DT::datatable(links, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

次に、すべてのダイアグラム・ノードのデータフレームを、`name` という列で作成します。これは、`hospital` と `age_cat` のすべての値で構成されています。また、ID列をラベルではなく数字に変更します。 

```{r}
# ユニークなノード名
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
  )

nodes  # 表示
```

次に、上述の `count()` で作成した `links` データフレームを編集します。
2つの数値列 `IDsource` と `IDtarget` を追加します。これらはノード間のリンクを実際に反映/作成します。
これらの列にはソースノードとターゲットノードの行番号（位置）が入ります。
ポジション番号が（1ではなく）0から始まるように、1が引かれます。 

訳注 The は Then か

```{r}
# 名前ではなく数値にマッチング
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
```

リンクのデータセットは以下のようになります。

```{r message=FALSE, echo=F}
DT::datatable(links, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

では、`sankeyNetwork()` でサンキーダイアグラムをプロットしてみましょう。
コンソールで `?sankeyNetwork` を実行すると、各引数についての詳細を見ることができます。
なお、`iterations = 0` を設定しないと、ノードの順番が期待通りにならないことがあります。

```{r}

# plot
######
p <- sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "IDsource",
  Target = "IDtarget",
  Value = "n",
  NodeID = "name",
  units = "TWh",
  fontSize = 12,
  nodeWidth = 30,
  iterations = 0)        # ノードの順序をデータ順にする
p
```

ここでは、患者のアウトカムも含まれている例を示します。
なお、データ準備の段階で、age と hospital、またこれとは別に hospital と outcome の間のケースの数を計算し、`bind_rows()` で両者のカウントを結合しています。 

```{r}
# 病院と年齢区分で集計
age_hosp_links <- linelist %>% 
  drop_na(age_cat) %>% 
  select(hospital, age_cat) %>%
  count(hospital, age_cat) %>% 
  rename(source = age_cat,          # re-name
         target = hospital)

hosp_out_links <- linelist %>% 
    drop_na(age_cat) %>% 
    select(hospital, outcome) %>% 
    count(hospital, outcome) %>% 
    rename(source = hospital,       # re-name
           target = outcome)

# リンクを結合
links <- bind_rows(age_hosp_links, hosp_out_links)

# ユニークなノード名
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
  )

# ID番号を生成
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1

# プロット
######
p <- sankeyNetwork(Links = links,
                   Nodes = nodes,
                   Source = "IDsource",
                   Target = "IDtarget",
                   Value = "n",
                   NodeID = "name",
                   units = "TWh",
                   fontSize = 12,
                   nodeWidth = 30,
                   iterations = 0)
p

```

https://www.displayr.com/sankey-diagrams-r/

<!-- ======================================================= -->

## イベントのタイムライン { }

特定のイベントを表示するタイムラインを作るには、`vistime` パッケージを使います。

こちらの [vignette](https://cran.r-project.org/web/packages/vistime/vignettes/vistime-vignette.html#ex.-2-project-planning) をご覧ください。

```{r}
# パッケージを読み込み
pacman::p_load(vistime,  # タイムラインを作成
               plotly    # インタラクティブな可視化
               )
```

```{r, echo=F}
# 参照: https://cran.r-project.org/web/packages/vistime/vignettes/vistime-vignette.html#ex.-2-project-planning

data <- read.csv(text="event, group, start, end, color
                       Event 1, Group A,2020-01-22,2020-01-22, #90caf9
                       Event 1, Group B,2020-01-23,2020-01-23, #90caf9
                       Event 1, Group C,2020-01-23,2020-01-23, #1565c0
                       Event 1, Group D,2020-01-25,2020-01-25, #f44336
                       Event 1, Group E,2020-01-25,2020-01-25, #90caf9
                       Event 1, Group F,2020-01-26,2020-01-26, #8d6e63
                       Event 1, Group G,2020-01-27,2020-01-27, #1565c0
                       Event 1, Group H,2020-01-27,2020-01-27, #90caf9
                       Event 1, Group I,2020-01-27,2020-01-27,#90a4ae
                       Event 2, Group A,2020-01-28,2020-01-28,#fc8d62
                       Event 2, Group C,2020-01-28,2020-01-28, #6a3d9a
                       Event 2, Group J,2020-01-28,2020-01-28, #90caf9
                       Event 2, Group J,2020-01-28,2020-01-28, #fc8d62
                       Event 2, Group J,2020-01-28,2020-01-28, #1565c0
")
```

ここでは、まずイベントのデータセットをご紹介します。 

```{r message=FALSE, echo=F}
DT::datatable(data, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```



```{r}
p <- vistime(data)    # vistime を適用  

library(plotly)

# step 1: リストに変換  
pp <- plotly_build(p)

# step 2: マーカーの大きさ  
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "markers") pp$x$data[[i]]$marker$size <- 10
}

# step 3: テキストの大きさ  
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "text") pp$x$data[[i]]$textfont$size <- 10
}


# step 4: テキストの位置  
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "text") pp$x$data[[i]]$textposition <- "right"
}

# 表示  
pp

```



<!-- ======================================================= -->
## DAGs { }

前述のように **DiagammeR** パッケージとDOT言語を使って手動でDAGを構築することができます。 

また、**ggdag** や **daggity** などのパッケージもあります。

[DAGの紹介 ggdag vignette](https://cran.r-project.org/web/packages/ggdag/vignettes/intro-to-dags.html)

[Causal inference with dags in R](https://www.r-bloggers.com/2019/08/causal-inference-with-dags-in-r/#:~:text=In%20a%20DAG%20all%20the,for%20drawing%20analyzing%20DAGs.)



<!-- ======================================================= -->
## リソース { }


DOT言語に関する上記の内容の多くは、[このサイト](https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/)  のチュートリアルから引用しています。 

より詳細な [DiagammeRに関するチュートリアル](http://rich-iannone.github.io/DiagrammeR/)

[Sankey diagrams](https://www.displayr.com/sankey-diagrams-r/)




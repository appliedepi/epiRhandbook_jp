
# 日付の操作 {#dates}


```{r, out.width=c('50%'), fig.align='center', echo=F, message=F}
knitr::include_graphics(here::here("images", "Dates_500x500.png"))
```


R で日付を扱うときは、他のオブジェクトクラスを扱うときよりも注意が必要です。ここでは、この作業を楽にするためのツールや例を紹介します。幸いなことに、日付データは練習すれば簡単に扱えるようになりますし、**lubridate**のような便利なパッケージもあります。  

R に生データをインポートすると、日付を文字オブジェクトとして解釈することがあります。つまり、時系列の作成や時間間隔の計算など、一般的な日付操作には使用できません。さらに日付には様々な書式があるため、R に日付のどの部分が何を表しているのか（月、日、時間など）を伝える必要があります。 

R の日付は独自のオブジェクトクラスである `Date` クラスです。また、日付と時刻両方を持つオブジェクトを格納するクラスもあるので、注意が必要です。日付と時刻のオブジェクトは、正式には `POSIXt`, `POSIXct`, `POSIXlt` クラスと呼ばれます（これらの違いは重要ではありません）。これらは非公式に <u>datetime</u> クラスと呼ばれています。

* カラムに日付が含まれている場合、それを R に伝えることが重要です。  
* 日付はオブジェクトクラスであり、扱うのが難しい場合があります。  
* ここでは、日付の列を Date クラスに変換するいくつかの方法を紹介します。  


<!-- ======================================================= -->
## 準備

### パッケージの読み込み {.unnumbered}  

このコードチャンクは、このページに必要なパッケージのロードを示しています。このハンドブックでは **pacman** の `p_load()` を利用しています。これは必要に応じてパッケージをインストールする <u>と同時に</u>、パッケージをロードします。また、インストールされているパッケージを **base** R の `library()` でロードすることもできます。R のパッケージについては、[R の基礎知識](#basics)のページを参照してください。  

```{r dates_packages, warning=F, message=F}
# パッケージがインストールされているか確認し、必要に応じてインストールし、パッケージをロードする

pacman::p_load(
  lubridate,  # 日付の扱いと変換のための一般的なパッケージ  
  linelist,   # 厄介な日付を「推測」する関数を持つ
  aweek,      # 日付を週に、週を日付に変換する別のオプション
  zoo,        # 日付と時間に関する追加の関数
  tidyverse,  # データマネジメントと可視化  
  rio)        # データのインポートとエクスポート
```

### データのインポート {.unnumbered}  

エボラ出血熱のシミュレーションで得られた症例のデータセットをインポートします。データをダウンロードしてステップ・バイ・ステップで作業を進めたい場合は、[ハンドブックとデータのダウンロード](#data_used)ページを参照してください。ここではファイルが作業ディレクトリにあると仮定し、ファイルパスにはサブフォルダを指定しません。  

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")

```



<!-- ======================================================= -->
## 現在の日付  

コンピュータにおける「システム」の現在の日付や日時を取得するには、**base** R を使って次のように行います。  

```{r}
# システムの日付を取得（DATE クラス）
Sys.Date()

# システム時刻の取得（DATETIME クラス）
Sys.time()
```


**lubridate** パッケージでは、それぞれを `today()` と `now()` で返すこともできます。 `date()` は現在の日付と時刻を、曜日と月名とともに返します。  
  
  

<!-- ======================================================= -->
## Date クラスに変換  

データセットを R にインポートすると、日付列の値が「1989/12/30」、「05/06/2014」、「13 Jan 2020」のようになることがあります。このような場合、R はこれらの値を文字として扱っていると思われます。R には、これらの値が日付であること、そして日付のフォーマット（どの部分が日で、どの部分が月で、どの部分が年であるかなど）を <u>伝える</u>必要があります。  

そうして、これらの値を Date クラスに変換します。これは内部的には、日付を数値（「起点日」の 1970 年 1 月 1 日からの日数）として保存しています。日付を数値として扱うことはあまりありませんが、これにより日付を連続変数として扱い、日付間の距離を計算するなどの特殊な操作が可能になります。  

デフォルトでは、Date クラスの値は YYYY-MM-DD で表示されます。この後、日付の値の表示を変更する方法について説明します。  

以下では、列を character クラスから Date クラスに変換する2つのアプローチを紹介します。  


<span style="color: darkgreen;">**_ヒント：_** `class(linelist$date_onset)` のように、**base** R 関数の `class()` で現在のクラスを確認することができます。</span>  

  

### **base** R {.unnumbered}  

`as.Date()` （大文字の"D"に注意）は、オブジェクトやカラムを Date クラスに変換する標準的な **base** R の関数です。  

`as.Date()` を使用するには、以下が必要です：

* *生の文字の日付の**既存の**形式を指定します*。または、日付を数値として提供する場合は、元の日付を指定します（Excel の日付に関するセクションを参照）。  
* 文字列として使用する場合、すべての日付値は同じ正確なフォーマットでなければなりません（そうでない場合は、**linelist** パッケージの `guess_dates()` をお試しください）。  

**まず**、**base** R の `class()` でカラムのクラスを確認してください。クラスがわからない場合（例えば "POSIXct"と表示される場合など）は、まず `as.character()` で character クラスに変換し、その後 Date クラスに変換するのが最も簡単です。  

**次に**、`as.Date()` 関数の中で、`format =` 引数を使って、日付を構成する文字の <u>現在の</u>フォーマット、つまり、どの文字が月、日、年を表すのか、どのように分けられているのかをRに伝えます。Rの標準的な日付フォーマット（"YYYY-MM-DD" または "YYYY/MM/DD"）を既に使用している場合は、`format =` 引数は必要ありません。  

`format = `には、以下の特別な "strptime" の略語を使用して、 <u>現在の</u>日付フォーマットを表す文字列（引用符で囲む）を指定します。例えば、"24/04/1968" のように、現在の日付が "DD/MM/YYYY"のフォーマットである場合、`format = "%d/%m/%Y"` を使用して値を日付に変換します。**書式を引用符で囲む必要があります。また、スラッシュやダッシュも忘れずに！**  

```{r eval=F}
# Date クラスに変換
linelist <- linelist %>% 
  mutate(date_onset = as.Date(date_of_onset, format = "%d/%m/%Y"))
```

strptime の略語のほとんどを以下に示します。完全なリストは、`?strptime` を実行して見ることができます。  

%d = 月の日にち (5, 17, 28, 等)  
%j = 年の日にち  (ユリウス通日 001-366)  
%a = 曜日の省略形 (Mon, Tue, Wed, 等)  
%A = 完全な曜日表示 (Monday, Tuesday, 等)
%w = 曜日番号 (0-6, 日曜日が0)  
%u = 曜日番号 (1-7, 月曜日が1)  
%W = 週の番号 (00-53, 月曜日が週の始まり)  
%U = 週の番号 (01-53, 日曜日が週の始まり)  
%m = 月の番号 (e.g. 01, 02, 03, 04)  
%b = 月の省略形 (Jan, Feb, 等)  
%B = 完全な月表示 (January, February, 等)  
%y = 2桁の年  (例: 89)  
%Y = 4桁の年  (例: 1989)  
%h = 時間 (24時間表示)  
%m = 分  
%s = 秒  
%z = GMT（グリニッジ標準時）からのオフセット  
%Z = タイムゾーン (character型)  

<span style="color: darkgreen;">**_ヒント：_** `as.Date()` の `format =` 引数は、R に日付のフォーマットを伝える <u>のではなく</u>、コマンドを実行する <u>前</u>に、日付のパーツを識別する方法を伝えています。</span>  

<span style="color: darkgreen;">**_ヒント：_** `format = ` の引数には、その日付に存在する <u>セパレータ</u>（e.g. /, -, またはスペース）を使用してください。</span>  

Date クラスに値を入れると、R はデフォルトで YYYY-MM-DD というフォーマットで表示します。



### **lubridate** {.unnumbered}  

character オブジェクトを日付に変換するには、**lubridate** パッケージを使用すると簡単です。これは **base** R よりも簡単で一貫性のある、日付と時刻を扱うために設計された**tidyverse**のパッケージです。これにより、**lubridate** は日付と時刻のゴールドスタンダードとされ、常に推奨されています。

**lubridate** パッケージは、文字オブジェクトを日付に変換するためのヘルパー関数をいくつか提供しています。このヘルパー関数は、文字オブジェクトを直観的に、かつ `as.Date()` でフォーマットを指定するよりも柔軟な形式で変換することができます。これらの関数は、柔軟な日付フォーマットに特化していますが、さまざまなセパレータや日付の同義語（例：01 vs Jan vs January）を使用できます。これらの名前は、日付フォーマットの略語に由来しています。 


```{r, }
# lubridate のインストールとロード
pacman::p_load(lubridate)
```

`ymd()`関数は、**年、月、日**の順に与えられた日付の値を柔軟に変換します。  

```{r}
# 年月日のフォーマットで日付を読み込み
ymd("2020-10-11")
ymd("20201011")
```

`mdy()`関数は、**月、日、年**の順に与えられた日付の値を柔軟に変換します。  

```{r}
# 月日年のフォーマットで日付を読み込み
mdy("10/11/2020")
mdy("Oct 11 20")
```

`dmy()`関数は、**日、月、年**の順に与えられた日付の値を柔軟に変換します。  

```{r}
# 日月年のフォーマットで日付を読み込み
dmy("11 10 2020")
dmy("11 October 2020")
```

<!-- `as.character()` と `as.Date()` コマンドはオプションとして以下のように組み合わせる   -->

<!-- ```{r eval=F} -->
<!-- linelist_cleaned$date_of_onset <- as.Date(as.character(linelist_cleaned$date_of_onset), format = "%d/%m/%Y") -->
<!-- ``` -->

パイプを使用して文字列から日付への変換を **lubridate** で行うと、以下のようになります：

```{r, eval=F}
linelist <- linelist %>%
  mutate(date_onset = lubridate::dmy(date_onset))
```

完成したら、`class()`を実行して、カラムのクラスを確認します。  

```{r, eval=F}
# カラムのクラスを確認
class(linelist$date_onset)  
```


Date クラスに値を入れると、デフォルトで YYYY-MM-DD という標準的なフォーマットで表示されます。  

上記の関数は、4 桁表示の年で最もうまく機能します。2 桁表示の年は、lubridate が世紀として推測するため、予想外の結果になることがあります。  

2 桁の年を 4 桁の年（すべて同じ世紀）に変換するには、characterクラスに変換した後、 **stringr** パッケージの `str_glue()` を用いて、既存の数字とプレフィックスを組み合わせ（[文字と文字列](#characters_strings)を参照）、その後日付に変換します。  

```{r}
two_digit_years <- c("15", "15", "16", "17")
str_glue("20{two_digit_years}")
```



### カラムの結合 {.unnumbered}  

複数の数値列を一つの日付列にまとめるには、**lubridate** 関数の `make_date()` と `make_datetime()` を利用します。例えば、データフレーム `linelist` に 数値列 `onset_day`, `onset_month`, `onset_year` があるとします。  

```{r, eval=F}
linelist <- linelist %>% 
  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))
```




<!-- ======================================================= -->
## Excelにおける日付

内部的には、多くのソフトウェアが日付を数字として保存します。R は 1970 年 1 月 1 日を起点として日付を格納します。したがって、`as.numeric(as.Date("1970-01-01))` を実行すると `0` が得られます。 

Microsoft Excel では、お使いの OS に応じて、1899年12月30日（Windows）または 1904 年 1 月 1 日（Mac）を起点とする日付が保存されます。詳しくは [Microsoft guidance](https://docs.microsoft.com/en-us/office/troubleshoot/excel/1900-and-1904-date-system) をご覧ください。  

Excel の日付はこのように、文字ではなく数値として R にインポートされることがよくあります。エクセルからインポートしたデータセットで、日付が "41369" のような数字や文字として表示されている場合は `as.Date()` （または **lubridate** の `as_date()` 関数）を使って変換しますが、上記のように**フォーマットを指定する代わりに、Excel での起点日**を引数 `origin = ` に指定します。  

これは、エクセルの日付が文字型として R に保存されている場合には機能しないので、必ず数値がnumericクラスであることを確認してください。

<span style="color: black;">**_注:_** 起点日は、R の標準の日付形式（YYYY-MM-DD）で入力してください。</span>

```{r, eval = FALSE}
# Excel の数字の日付を変換する際、エクセルの「起点日」を入力する例
data_cleaned <- data %>% 
  mutate(date_onset = as.numeric(date_onset)) %>%   # クラスが numeric であることを確認
  mutate(date_onset = as.Date(date_onset, origin = "1899-12-30")) # エクセルの起点日で日付に変換
```



<!-- ======================================================= -->
## 厄介な日付  

**linelist** パッケージの関数 `guess_dates()` は、多くの異なる形式の日付を含む「厄介な」日付列を読み込んで、その日付を標準的な形式に変換しようとします。`guess_dates()` については[オンラインでもっと読む](https://www.repidemicsconsortium.org/linelist/reference/guess_dates.html)ことができます。R 4.0.2 の CRAN に `guess_dates()` がまだない場合は、 `pacman::p_load_gh("reconhub/linelist")` でインストールしてください。

例えば `guess_dates` は、文字の日付"03 Jan 2018", "07/03/1982", "08/20/85"のベクトルを、"2018-01-03", "1982-03-07", "1985-08-20"のように Date クラスに変換します。  

```{r, }
linelist::guess_dates(c("03 Jan 2018",
                        "07/03/1982",
                        "08/20/85"))
```

`guess_dates()` のオプションの引数には、以下が含まれます：  

* `error_tolerance` - 許容される日付として識別できないエントリの割合 (デフォルトは 0.1、つまり10%)
* `last_date` - 最後の有効な日付（デフォルトは現在の日付）  
* `first_date` - 最初の有効な日付（デフォルトは last_date の 50 年前）


```{r eval = FALSE}
# dater_onset列にguess_datesを使用した例
linelist <- linelist %>%                 # linelistと呼ばれるデータセット
  mutate(
    date_onset = linelist::guess_dates(  # "linelist" パッケージの guess_dates()
      date_onset,
      error_tolerance = 0.1,
      first_date = "2016-01-01"
    )
```




<!-- ======================================================= -->
## date-time クラスの操作

先に述べたように、R では日付**と**時間の情報を含む、`datetime` クラスもサポートしています。`Date` クラスと同様に、`character` オブジェクトから `datetime` オブジェクトに変換する必要があります。 

### 日付と時刻の変換 {.unnumbered}  

標準的な `datetime` オブジェクトは、最初に日付があって、その後に時間要素が続く形式（ _01 Jan 2020, 16:30_ など）です。日付と同様に、このフォーマットには様々な方法があり、また、提供できる精度（時、分、秒）のレベルも様々です。

これらの文字列を `datetime` オブジェクトに変換するための **lubridate** ヘルパー関数も存在します。これらの関数では、日付ヘルパー関数を拡張したもので、末尾に `_h` (時のみを指定)、`_hm` (時と分を指定)、`_hms` (時、分、秒を指定)を付けます (例: `dmy_hms()`)。以下のように使用します：

時間のみの datetime を datetime オブジェクトに変換する  

```{r}
ymd_h("2020-01-01 16hrs")
ymd_h("2020-01-01 4PM")
```

時と分を含む datetime を datetime オブジェクトに変換する  

```{r}
dmy_hm("01 January 2020 16:20")
```

時、分、秒を含む datetime を datetime オブジェクトに変換する  

```{r}
mdy_hms("01 January 2020, 16:20:40")
```

タイムゾーンを指定できますが、無視されます。タイムゾーンについては、このページの後のセクションを参照してください。  

```{r}
mdy_hms("01 January 2020, 16:20:40 PST")

```

データフレームを扱う際には、**stringr** パッケージの `str_glue()` と適切な **lubridate** 関数を用いて、time 列と date 列を組み合わせて datetime 列を作成できます。**stringr** の詳細については、[文字と文字列](#characters_strings)のページを参照してください。  

この例では、`linelist` データフレームに "hour:minutes" というフォーマットの列があります。これを日付時間に変換するには、いくつかの手順を踏みます。  

1) 欠損値を列の中央値で埋めて、「きれいな」入院時刻の列（time_admission_clean）を作成します。これは **lubridate** が欠損値を処理できないためです。これを `date_hospitalisation` 列と結合し、 `ymd_hm()` 関数を使って変換します。  

```{r, eval = FALSE}
# パッケージ
pacman::p_load(tidyverse, lubridate, stringr)

# time_admission 列は hours:minutes というフォーマット
linelist <- linelist %>%
  
  # 入院時刻が指定されていない場合は、中央値の入院時刻を割り当てる
  mutate(
    time_admission_clean = ifelse(
      is.na(time_admission),         # 時刻が欠損している場合、
      median(time_admission),        # 中央値を割り当て、
      time_admission                 # 欠損していない場合はそのまま
  ) %>%
  
    # str_glue() を使用して、日付と時刻のカラムを結合し、1つの文字カラムを作成し、
    # ymd_hm() を使って datetime に変換
  mutate(
    date_time_of_admission = str_glue("{date_hospitalisation} {time_admission_clean}") %>% 
      ymd_hm()
  )

```

### 時間のみの変換 {.unnumbered}  

データに文字列で時間（時、分）しか含まれていない場合は、**base** R の `strptime()` を使って時間として変換・操作することができます。例えば、2 つの時間の差を求めるには  

```{r}
# 直接、文字で時間を入力
time1 <- "13:45" 
time2 <- "15:20"

# datetime クラスに変換した時刻
time1_clean <- strptime(time1, format = "%H:%M")
time2_clean <- strptime(time2, format = "%H:%M")

# 差分はデフォルトでは "difftime" クラスだが、ここでは数値に変換
as.numeric(time2_clean - time1_clean)   # 時間単位（ hour ）での差分

```

ただし、日付の値が指定されていない場合は、今日の日付として変換されます。日付の文字列と時刻の文字列を組み合わせるには、上のセクションの**stringr**の使用方法を参照してください。`strptime()`について詳しくは[こちら](https://rdrr.io/r/base/strptime.html)をご覧ください。  

一桁の数字を二桁に変換するには（例えば、時間や分を先頭のゼロで"埋めて" 2 桁にするなど）、[文字列と文字のページの"Pad length"項](#str_pad)をご覧ください。  


### 時間の抽出 {.unnumbered}  

**lubridate** の `hour()`, `minute()`, `second()` で時間の要素を抽出できます。  

ここでは、時間を抽出して一日の区分で分類する例を示します。 `time_admission`という列（入院時刻を表す） は、"HH:MM" フォーマットの character クラスです。まず、上述した `strptime()` を使って文字を datetime クラスに変換します。次に `hour()` で時間を抽出して、0～24の数値を返します。最後に、`case_when()` のロジックを用いて `time_period` という列を作成し、入院時刻に基づいて午前/午後/夕方/夜に分類します。  

```{r}
linelist <- linelist %>%
  mutate(hour_admit = hour(strptime(time_admission, format = "%H:%M"))) %>%
  mutate(time_period = case_when(
    hour_admit > 06 & hour_admit < 12 ~ "Morning",
    hour_admit >= 12 & hour_admit < 17 ~ "Afternoon",
    hour_admit >= 17 & hour_admit < 21 ~ "Evening",
    hour_admit >=21 | hour_admit <= 6 ~ "Night"))
```

`case_when()` については、[データのクリーニングとコア関数](#cleaning)を参照してください。  

<!-- ======================================================= -->
## 日付の操作   

`lubridate` は他にも様々な機能があります。例えば、**日付/日時から一部を抽出**、**日付の演算**、**日付の間隔を計算**などです。

まず、例に用いる日付を定義します。  

```{r, }
# Date クラスのオブジェクトを作成
example_date <- ymd("2020-03-01")
```

### 日付成分の抽出 {.unnumbered}  

月、日、曜日などの共通する部分を抽出します。  

```{r}
month(example_date)  # 月番号
day(example_date)    # 日にち
wday(example_date)   # 曜日番号（1-7）
```

また、`Datetime` のオブジェクトや列から時間の要素を抽出できます。これは、入院時刻の分布を見たい場合に便利です。  

```{r, eval=F}
example_datetime <- ymd_hm("2020-03-01 14:45")

hour(example_datetime)     # 時の抽出
minute(example_datetime)   # 分の抽出
second(example_datetime)   # 秒の抽出
```

週を取得するにはいくつかオプションがあります。以下の Epidemiological weeksのセクションを参照してください。  

ただし、特定の表記で日付を表示したい場合（「Jan 2020」や「Thursday 20 March」、「Week 20, 1977」など）は、「日付の表示」の項で説明するように、より柔軟に対応することができます。  


### 日付の計算 {.unnumbered}  

日数や週数を足すには、**lubridate** の関数を使用します。  

```{r}
# 日付に3日分足す
example_date + days(3)
  
# 日付に7週分足し、2日分引く
example_date + weeks(7) - days(2)
```

### 日付の間隔 {.unnumbered}  

日付の間隔は以下の方法で計算できます。  

1. 両方の日付が Date クラスであることを確認する  
2. 引き算で日付の差「difftime」を返す  
3. 必要に応じて、結果を数値クラスに変換する  

以下では、2つの日付の間隔を計算しています。Date クラスの値に減算記号「マイナス」を使用して、間隔を求められます。ただし、返される値のクラスは  "difftime" であり、数値に変換する必要があります。 

```{r}
# example_dateから2020年2月20日までの間隔を求める 
output <- example_date - ymd("2020-02-20")
output    # 出力
class(output)
```

"difftime" に対して以降の操作を行うには、`as.numeric()` で数値に変換します。 

パイプによって、これらを一連の流れで操作できます。

```{r, eval = F}
pacman::p_load(lubridate, tidyverse)   # パッケージのロード

linelist <- linelist %>%
  
  # dmy フォーマットを指定して、発症日を文字から日付オブジェクトに変換
  mutate(date_onset = dmy(date_onset),
         date_hospitalisation = dmy(date_hospitalisation)) %>%
  
  # 3 月に発症していないケースをすべて除外
  filter(month(date_onset) == 3) %>%
    
  # 発症から入院までの日数の差を求める
  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)
```



データフレームでは、上記の日付のいずれかが欠損していると操作が失敗し、数値ではなく `NA` が表示されます。この列を計算に使用する場合は、以下のように必ず `na.rm =` 引数を `TRUE` に設定してください。

```{r, eval = FALSE}
# データが欠損していない症例について、発症から入院までの日数の中央値を算出
median(linelist_delay$days_onset_to_hosp, na.rm = T)
```


<!-- ======================================================= -->
## 日付の表示  

日付を正しいクラスにした後、「2018-01-05」ではなく「Monday 05 January」など、異なる表示にしたくなることがあります。また表示されている日付の要素でグループ化し、表示を調整することもあります（例：年と月でグループ化）。  

### `format()` {.unnumbered}  

日付の表示を調整するには、**base** R 関数の `format()` を使用します。この関数は、"%" で始まる strptime 略語（ `as.Date()` で使用されるのと同じ構文）で、 <u>望みの</u>出力フォーマットを指定する文字列（引用符で囲まれたもの）を受け入れます。以下は、一般的な略語の例です。  

注意：`format()` を使用すると、値が character クラスに変換されるので、一般的に分析の最後に使用するか、表示のみを目的としています。完全なリストは `?strptime` を実行して見ることができます。  

%d = 月の日にち (5, 17, 28, 等)  
%j = 年の日にち  (ユリウス通日 001-366)  
%a = 曜日の省略形 (Mon, Tue, Wed, 等)  
%A = 完全な曜日表示 (Monday, Tuesday, 等)
%w = 曜日番号 (0-6, 日曜日が0)  
%u = 曜日番号 (1-7, 月曜日が1)  
%W = 週の番号 (00-53, 月曜日が週の始まり)  
%U = 週の番号 (01-53, 日曜日が週の始まり)  
%m = 月の番号 (e.g. 01, 02, 03, 04)  
%b = 月の省略形 (Jan, Feb, 等)  
%B = 完全な月表示 (January, February, 等)  
%y = 2桁の年  (例: 89)  
%Y = 4桁の年  (例: 1989)  
%h = 時間 (24時間表示)  
%m = 分  
%s = 秒  
%z = GMT（グリニッジ標準時）からのオフセット  
%Z = タイムゾーン (character型) 


今日の日付のフォーマットの例です。  

```{r}
# フォーマットした今日の日付
format(Sys.Date(), format = "%d %B %Y")

# 完全な日付と時間を簡単に取得（デフォルトのフォーマット）
date()

# str_glue() 関数を使って、フォーマットした日付、時刻、タイムゾーンを組み合わせる
str_glue("{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}")

# フォーマットを使用して週を表示
format(Sys.Date(), "%Y Week %W")
```

なお、`str_glue()` を使用する場合は、二重引用符""の中では一重引用符''を使用することに注意してください。  


### 年月 {.unnumbered}  

日付を月年形式に変換するには、 **zoo** パッケージの関数 `as.yearmon()` を使うことをお勧めします。これは、日付を yearmon クラスに変換し、適切な順序を保持します。一方 `format(column, "%Y %B")` を使用すると、character クラスに変換され、値がアルファベット順に並んでしまいます。 

以下では、`as.yearmon()` 関数を使って、`date_onset` という列から `yearmonth` という列を新たに作成しています。得られる値のデフォルト（正しい）順序をテーブルに示します。  

```{r}
# 新しい列の作成 
test_zoo <- linelist %>% 
     mutate(yearmonth = zoo::as.yearmon(date_onset))

# テーブルの出力
table(test_zoo$yearmon)
```

一方、`format()` を使っただけでは、目的の表示形式にはなりますが、正しい順序にはなりません。  

```{r}
# 新しい列の作成
test_format <- linelist %>% 
     mutate(yearmonth = format(date_onset, "%b %Y"))

# テーブルの出力
table(test_format$yearmon)
```

注意： `ggplot()` を用いる際、日付の <u>表示</u>のみを調整したい場合は、`scale_x_date()` の `date_labels = ` 引数に strptime フォーマットを与えるだけで十分な場合があります。この場合 `"%b %Y"` または `"%Y %b"` を使用できます。[ggplot tips](#ggplot) のページをご覧ください。  


また **zoo** には `as.yearqtr()` という関数があります。 `ggplot()` を用いる際には `scale_x_yearmon()` を使用できます。  



<!-- ======================================================= -->
## 疫学週 {#dates_epi_wks}

### **lubridate** {.unnumbered}  

日付ごとにデータをグループ化する例は、[データのグループ化](#grouping)をご覧ください。以下では、週ごとにデータをグループ化することについて簡単に説明します。  

一般的には、 **lubridate** の `floor_date()` 関数に引数 `unit = "week"` を指定して使用することをお勧めします。これは、引数 `week_start = ` で定義される週の「開始日」に日付を丸めるものです。デフォルトの週の開始日は1（月曜日）ですが、週の任意の日を開始日として指定することができます（例：日曜日は7）。`floor_date()`は汎用性があり、`unit = `を "second", "minute", "hour", "day", "month", "year"に設定することで、他の時間単位への切り捨てに使用することができます。  

返される値は、Date クラスの週の開始日です。Date クラスはデータをプロットする際に便利で、`ggplot()` で簡単に認識され、正しい順序で表示されます。

プロットの中で週ごとに日付を調整して <u>表示</u>するだけなら、このページの日付の表示のセクションを参照してください。例えば、エピカーブをプロットする際に、必要な strptime の"%"を指定することで、日付表示をフォーマットすることができます。例えば、"%Y-%W "または"%Y-%U"を使用して、年と週の番号を返します（それぞれ月曜または日曜の週の開始日を指定）。  

### 週ごとのカウント {.unnumbered}  

`count()`, `group_by()`, `summarise()`によるデータのグループ化については、[データのグループ化](#grouping)のページで詳しく説明しています。以下に簡単な例を示します。  

1) `mutate()` で新しく "week" という列を作成し、`floor_date()` で `unit = "week"` を使用する。  
2) 週ごとのケースの行数を `count()` で取得し、日付が欠損しているケースを除外する。  
3) **tidyr** の `complete()` では、行やケースがないものも含めて、 <u>すべての</u>週がデータに現れるようになる。デフォルトでは、"新しい"行のカウント値は NA だが、 `fill = ` 引数で 0 にすることができる。 `fill = ` 引数では、名前付きリストを指定する（以下、`n` はカウント列の名前）。  

```{r}
# 毎週の症例数を集計したデータセットの作成
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%             # 発症日が欠損のケースを削除
  mutate(weekly_cases = floor_date(   # 発症週の新しい列を作成
    date_onset,
    unit = "week")) %>%            
  count(weekly_cases) %>%           # 週ごとにグループ化し、グループごとの行数をカウント（「n」という列を作成）。
  tidyr::complete(                  # 症例が報告されていない週も含めて、すべての週が存在するようにする
    weekly_cases = seq.Date(          # "weekly_cases" という列を完全なシーケンスとして再定義
      from = min(weekly_cases),       # 最小の日付から
      to = max(weekly_cases),         # 最大の日付まで
      by = "week"),                   # 週ごとに
    fill = list(n = 0))             # n という列の NA を 0 で埋める
```

以上の結果、得られたデータフレームの最初の行を示します。  

```{r message=FALSE, echo=F}
DT::datatable(head(weekly_counts, 20), rownames = FALSE, options = list(pageLength = 5, scrollX = T), class = 'white-space: nowrap')
```


### 疫学週 の代替案 {.unnumbered}  

なお、**lubridate** には `week()`, `epiweek()`, `isoweek()` という関数があり、それぞれ開始日などが微妙に異なります。しかし、一般的には`floor_date()`があれば十分です。これらの関数の詳細については、コンソールに `?week` と入力するか、[ドキュメント](https://www.rdocumentation.org/packages/lubridate/versions/1.7.4/topics/week) をご覧ください。 


疫学週 を設定するために、**aweek** パッケージの使用を検討してはいかがでしょうか。このパッケージについては、[RECON のウェブサイト](https://www.repidemicsconsortium.org/aweek/)で詳しく説明されています。このパッケージには、`date2week()` と `week2date()` という関数があり、`week_start = "Monday"` で週の開始日を設定することができます。このパッケージは、"week" スタイルの出力 (例： "2020-W12") が必要な場合に最も簡単です。もう一つの **aweek** の利点は、`date2week()` を日付列に適用すると、返される列 (週形式) は自動的に factor クラスになり、タイムスパン内のすべての週のレベルが含まれることです (これにより、上述の `complete()` の余分なステップを回避できます)。ただし、**aweek** には、日付を月や年などの他の時間単位に丸める機能はありません。  


時系列の代わりに、"週"のフォーマット（"2020 W12"）を表示するのにも適しているのが、パッケージ **tsibble** の `yearweek()` です。これは[Time series and outbreak detection](#time_series)のページで紹介しています。  


<!-- ======================================================= -->
## 日付/タイムゾーンの変換

異なるタイムゾーンにデータが存在する場合、そのデータを統一されたタイムゾーンで標準化することが重要になります。これにはさらなる課題があり、データのタイムゾーン要素を手作業でコード化しなければなりません。

R では、各 <u>datetime</u> オブジェクトは timezone 要素を持っています。デフォルトでは、すべての datetime オブジェクトには、コンピュータのローカルタイムゾーンが適用されます。これは、サマータイムによりタイムゾーンが変更されることが多いため、通常は名前付きのタイムゾーンではなく <u>場所</u> に固有のものです。日付の列が表すイベントは特定の時間に起因するものではないため、時間単位でのタイムシフトを合理的に説明することはできませんので、日付の時間要素なしにタイムゾーンを正確に補正することはできません。

lubridate には datetime オブジェクトのタイムゾーンを異なるタイムゾーンに変更するためのヘルパー関数がいくつかあります。tz データベースのタイムゾーンを datetime オブジェクトに適用することで、タイムゾーンの設定が行えます。データを使用している場所がこのリストにない場合は、近隣の大都市のタイムゾーンが利用可能です。 

https://en.wikipedia.org/wiki/List_of_tz_database_time_zones


```{r}
# 現在の時刻を列に割り当て
time_now <- Sys.time()
time_now

# with_tz()を使用して、時刻を変更しながら、新しいタイムゾーンをカラムに割り当て
time_london_real <- with_tz(time_now, "Europe/London")

# force_tz()を使って、時刻を維持したまま、新しいタイムゾーンをカラムに割り当て
time_london_local <- force_tz(time_now, "Europe/London")


# このコードを実行したコンピュータがロンドン時間に設定されていない場合は
# 時間の差が発生する
# (コンピュータのタイムゾーンとロンドンのタイムゾーンとの差の時間数)
time_london_real - time_london_local

```

この作業は抽象的に見えるかもしれませんが、複数のタイムゾーンを扱わない場合は不要なことが多いです。  





<!-- ======================================================= -->
## 前後の値の計算  

`lead()` と `lag()` は **dplyr** パッケージの関数で、ベクトル（通常は数値や日付のベクトル）の中から前の値（遅れた値）や後の値（先行する値）を見つけるのに役立ちます。これは、時間単位での変化や差を計算するときに便利です。  


```{r, echo=F}
counts <- import(here("data", "example", "district_weekly_count_data.xlsx")) %>% 
  filter(District == "Nibari") %>% 
  mutate(Date = as.Date(Date),
         week_start = lubridate::floor_date(Date, "week")) %>%
  group_by(week_start) %>% 
  summarize(cases_wk = sum(Cases, na.rm = T)) %>% 
  complete(week_start = seq.Date(min(week_start), max(week_start), by = "week"), fill = list(cases_wk = 0))
```

例えば、現在の週と前の週の症例数の差を計算したいとします。元のデータは、以下のように週ごとのカウントになっています。  

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX = T), class = 'white-space: nowrap')
```

**`lag()` や `lead()` を使用する際には、データフレーム内の行の順序が非常に重要です。日付や数字が昇順か降順かに注意してください**。  

まず、前週（lagged）の値を含む新しい列を作成します。  

* `n = ` で前後のユニット数（非負の整数）を指定する。  
* 存在しない行（前の値がない最初の行など）に置かれる値を定義するには、`default = ` を使用する。デフォルトは `NA` 。  
* 参照する列が順序付けられていない場合は、`order_by = TRUE` を使用する。  


```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1))
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX = T), class = 'white-space: nowrap')
```

次に、2つのケースの列の差分となる新しい列を作成します。  

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1),
         case_diff = cases_wk - cases_prev_wk)
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX = T), class = 'white-space: nowrap')
```


`lead()` と `lag()` については、[ドキュメント](https://dplyr.tidyverse.org/reference/lead-lag.html)をご覧いただくか、コンソールで `?lag` と入力してください。  


<!-- ======================================================= -->
## 資料  

**lubridate** [tidyverse page](https://lubridate.tidyverse.org/)  
**lubridate** RStudio [cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)  
R for Data Science page on [dates and times](https://r4ds.had.co.nz/dates-and-times.html)  
[Online tutorial](https://www.statmethods.net/input/dates.html)  
[Date formats](https://www.r-bloggers.com/2013/08/date-formats-in-r/)

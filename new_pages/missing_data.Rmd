# データの欠損 {#Missing-data}

```{r, out.width=c("50%"), echo=F}
knitr::include_graphics(here::here("images", "missingness.png"))
knitr::include_graphics(here::here("images", "missingness_overview.png"))
```

このページでは以下の内容について説明します：

1)  欠損の評価\
2)  欠損による行のフィルタリング\
3)  時系列による欠損のプロット\
4)  プロットにおける `NA` の処理の仕方\
5)  欠損値の補完：MCAR, MAR, MNAR

<!-- ======================================================= -->

## 準備

### パッケージの読み込み {.unnumbered}

以下のコードは解析に必要なパッケージの読み込みを示しています。このハンドブックでは、**pacman** の `p_load()` を特に使用していますが、パッケージのインストールを必要に応じて行い、[かつ]{.ul}読み込みまで行ってくれます。他にも、**base** R の `library()` を用いてインストールされているパッケージを読み込む方法があります。R のパッケージについてより知りたい場合は、[R の基礎 {#basics}] を参考にしてください。

```{r}
pacman::p_load(
  rio,           # インポート／エクスポート
  tidyverse,     # データの管理と視覚化
  naniar,        # 欠損を評価と視覚化
  mice           # 欠損値の補完
)
```

### データのインポート {.unnumbered}

エボラ流行熱のシミュレーションケースのデータセットをインポートします。同じように行いたい場合、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>クリックして"クリーニングされた（clean）" ラインリストをダウンロードしてください</a> （.rds 形式のファイルです）。**rio** パッケージの関数 `import()` を用いてデータをインポートしてください（.xlsx, .rds, .csv など、様々な形式のファイルをダウンロードすることが出来ますー詳しくは[インポートとエクスポート {#Importing}] のページを参照にしてください。）

```{r, echo=F}
# ラインリストを R にインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# ラインリストをインポートする
linelist <- import("linelist_cleaned.rds")
```

最初の 50 行を以下に示します。

```{r, message=FALSE, echo=F}
# ラインリストのデータをテーブルとして表示する
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### インポート時における欠損の変換 {.unnumbered}

データをインポートする際に、欠損、と分類されるべき値については少し注意が必要です。例えば、99、999、"Missing"、空欄（""）、または 空のスペースを含むセル（" "） などです。インポートのコマンドと一緒にこれらの値を `NA` （R における欠損値の意味）に変換することが出来ます。\
使用するコマンドがファイルのタイプによって異なるので、詳細については [データの欠損](#import_missing) のインポートのセクションを参考にしてください。

<!-- ======================================================= -->

## R における欠損値

以下では、R における欠損の表示や評価の仕方、また、それに関連するいくつかの値や関数について見ていきたいと思います。

### `NA` {.unnumbered}

R においては、欠損値は特に `NA` という値で表示されます。これは引用符[なし]{.ul}で用いります。"NA" は特殊で、普通の文字値と同じです。

データ内では"99"、"Missing"、または "Unknown" というように欠損が表されていることもあります。また、空の文字値 ""（空欄のように見える）や、スペース " " で表されていることもあります。これらについては、[インポート時に `NA` に変換する](#import_missing) もしくはデータを `na_if()` を用いてクリーニングする必要があります。

データクリーニングにおいて、逆に全ての `NA` を "Missing" に変換したり、`replace_na()` やカテゴリ変数の場合は `fct_explicit_na()` を用いて処理したい場合もあると思います。

### いろいろな `NA` {.unnumbered}

多くの場合は、`NA` が欠損値を示し、それで全てがうまくいきます。しかし、オブジェクトのクラス（文字値、数値、など）によって[異なる]{.ul} `NA` を用いる必要が出てくる場合があります。あまり頻繁に起こることではないですが、注意が必要です。\
多いのは、**dplyr** 関数の `case_when()` を用いて新しい列を作成する場合などです。 [Cleaning data and core functions](#clean_case_when) のページで述べたように、この関数はデータフレーム内の全ての行に対して、ある基準（コードの右辺に書かれている条件）に合致するかどうかを評価し、新しい値（コードの左辺に書かれている値）を作成します。[右辺に書かれている値は、全ておなじクラスでないといけません。]{.ul}

```{r, eval=F}
linelist <- linelist %>% 
  
  # "age" 列から新しく "age_years" 列を作成する
  mutate(age_years = case_when(
    age_unit == "years"  ~ age,       # もし age が年で与えられていたら、そのままの値を返す
    age_unit == "months" ~ age/12,    # もし age が月で与えられていたら、12 で割る
    is.na(age_unit)      ~ age,       # もし age の UNIT が欠損であれば、years だと仮定する
    TRUE                 ~ NA_real_)) # 他のすべての場合には欠損とする
```

右辺に `NA` を持ってきたい場合は、以下に示している特殊な `NA` のうちのどれかを用いる必要があります。他の右辺の値が文字値の場合は "Missing" か、`NA_character_` を使用する必要があります。他の右辺が数値の場合は `NA_real_` を用いります。他の値がすべて日付や条件式であった場合 `NA` を用いることが出来ます。

-   `NA` ー日付や条件式 TRUE/FALSE において用いる
-   `NA_character_` ー文字値に用いる\
-   `NA_real_` ー数字値に用いる

繰り返しになりますが、新しい行を `case_when()` を用いて作成しようと[しない限り]{.ul}は、こうした例に出会うことはありません。より詳細について知りたい方は、[R documentation on NA](https://stat.ethz.ch/R-manual/R-devel/library/base/html/NA.html) を参考にしてください。

### `NULL` {.unnumbered}

他に R で用いられる値に、`NULL` があります。これは、条件が正でも誤でもないことを示しています。すなわち、値が定義されていない関数等によって返されます。一般的には、関数を書いたり、ある特定の条件において `NULL` を返すことを指示する [**shiny** app][Dashboards with Shiny] を書いたりする場合を除いて、NULL を値として指定することはありません。

Nullは `is.null()` を用いて評価され、`as.null()` を用いて変換されます。

`NULL` と `NA` の違いについては、[ブログのポスト](https://www.r-bloggers.com/2010/04/r-na-vs-null/) を見てください。

### `NaN` {.unnumbered}

取ることのできない値は、`NaN` で表されます。例えば、0 を 0 で割れ、と R に指示したような場合です。`is.nan()` を用いて評価することが出来、また、補足関数として`is.infinite()` や `is.finite()` が存在します。

### `Inf` {.unnumbered}

`Inf` は、例えばある値を 0 で割った場合など、無限大を表します。

これらの欠損値がどのように影響するかを簡単な例で示しましょう。例えば、`z <- c(1, 22, NA, Inf, NaN, 5)` で作成される `z` というベクターまたはコラムがあるとします。

一番大きな値を見つけるために `max()` という関数をこのコラムに適用することを考えます。`na.rm = TRUE` を用いることで、計算から `NA` を除くことが出来ます。しかし、`Inf` や `NaN` は残り、結果として `Inf` が返されます。これを解決するには、`[ ]` と `is.finite()` を用いて、すなわち `max(z[is.finite(z)])` とすることで、有限な値のみを含むサブセットを作成することが出来ます。

```{r, eval=F}
z <- c(1, 22, NA, Inf, NaN, 5)
max(z)                           # NA が返される
max(z, na.rm=T)                  # Inf が返される
max(z[is.finite(z)])             # 22 が返される
```

### 例 {.unnumbered}

+-----------------------------------------------------------------------------------------------------------------------+-----------------+
| R コマンド                                                                                                            | 出力            |
+=======================================================================================================================+=================+
| `5 / 0`                                                                                                               | `Inf`           |
+-----------------------------------------------------------------------------------------------------------------------+-----------------+
| `0 / 0`                                                                                                               | `NaN`           |
+-----------------------------------------------------------------------------------------------------------------------+-----------------+
| `5 / NA`                                                                                                              | `NA`            |
+-----------------------------------------------------------------------------------------------------------------------+-----------------+
| `5 / Inf |`0NA - 5`|`NAInf / 5`|`Infclass(NA)`| "logical"`class(NaN)`| "numeric"`class(Inf)`| "numeric"`class(NULL)\` | "NULL"          |
+-----------------------------------------------------------------------------------------------------------------------+-----------------+

"NAs introduced by coercion" はよくある警告メッセージです。数値のベクターに文字値を挿入しようとするなどの不正な操作を行った場合に起こります。

```{r}
as.numeric(c("10", "20", "thirty", "40"))
```

`NULL` はベクターにおいては無視されます。

```{r}
my_vector <- c(25, NA, 10, NULL)  # define
my_vector                         # print
```

ある一つの値のバリアンスを求めようとすると `NA` が返されます。

```{r}
var(22)
```

<!-- ======================================================= -->

## 便利な関数

以下では、R の **base** 関数で、欠損値を評価したり扱ったりする際に便利なものを示します。

### `is.na()` と `!is.na()` {.unnumbered}

`is.na()` は欠損値を特定する場合、または欠損でない値を特定する場合（`!` を一緒に用いります）に使います。どちらも理論値（`TRUE` or `FALSE`）が返されます。 返されたベクターに `sum()` を適用、例えば `sum(is.na(linelist$date_outcome))` とすることで、`TRUE` の数を計算することが出来ます。

```{r}
my_vector <- c(1, 4, 56, NA, 5, NA, 22)
is.na(my_vector)
!is.na(my_vector)
sum(is.na(my_vector))
```

### `na.omit()` {.unnumbered}

この関数をデータフレームに対して適用し、[全ての]{.ul}欠損値を含む行を除くことが出来ます。これもまた、R の **base** 関数です。\
ベクターに対して適用すると、`NA` を除くことが出来ます。例えば：

```{r}
na.omit(my_vector)
```

### `drop_na()` {.unnumbered}

[data cleaning pipeline][Cleaning data and core functions] の際に便利な **tidyr** の関数です。括弧内を空にして走らせると、欠損値を含む[全て]{.ul}の行を除くことが出来ます。括弧内で列の名前を指定することで、その列内の値を欠損している行を除くことが出来ます。列の指定には "tidyselect" を用いることもできます。

```{r, eval=F}
linelist %>% 
  drop_na(case_id, date_onset, age) # これらの列の値を欠損している行を除く
```

### `na.rm = TRUE` {.unnumbered}

`max()`、`min()`、`sum()` または、`mean()` などの数学関数を用いるときに `NA` が存在すると、`NA` が返されます。これは、欠損値があるという警告を知らせるためのデフォルトの挙動です。

計算から欠損値を除くことで、この警告を回避することが出来ます。そのためには、`na.rm = TRUE` （"na.rm" は "remove `NA`" の意）を一緒に用いります。

```{r}
my_vector <- c(1, 4, 56, NA, 5, NA, 22)

mean(my_vector)     

mean(my_vector, na.rm = TRUE)
```

<!-- ======================================================= -->

## データフレーム内の欠損を評価する

データフレーム `linelist` 内の欠損を評価し、視覚化するのに **naniar** というパッケージが使えます。

```{r}
# パッケージをインストールするもしくは読み込む
pacman::p_load(naniar)
```

### 欠損の数を数える {.unnumbered}

全ての欠損の値の割合を示すには `pct_miss()` を、数を示すには `n_miss()` を用いります。

```{r}
# すべてのデータフレーム内の欠損値の割合
pct_miss(linelist)
```

以下の 2 つの関数は、それぞれ、欠損値を含む行の割合、またはコンプリートケースの割合を返してくれます。`NA` は欠損を意味しますが、`""` や `" "` は欠損としてはカウントされないことに注意してください。

```{r}
# 欠損値を含む行の割合を示す
pct_miss_case(linelist)   # 数を示すには n_complete() を用いる
```

```{r}
# コンプリートケース（欠損のない行）の割合を示す  
pct_complete_case(linelist) # 数を示すには n_complete() を用いる
```

### 欠損値を視覚的に捉える {.unnumbered}

`gg_miss_var()` 関数を用いることで、それぞれの列における欠損値の数（もしくは割合）を示すことが出来ます。

-   プロットをグループごとに見たい場合は、`facet =` で列の名前（引用符にいれない）を指定することが出来ます\
-   デフォルトでは、割合ではなく数が表示されます。割合にしたい場合は `show_pct = TRUE` で指定します\
-   通常の `ggplot()` 通り、軸やタイトルのラベルを追加したい場合は `+ labs(...)` を用いて行うことが出来ます

```{r}
gg_miss_var(linelist, show_pct = TRUE)
```

以下では、データが `%>%` を用いて関数に渡されています。`facet =` を用いても、データを分けることが出来ます。

```{r}
linelist %>% 
  gg_miss_var(show_pct = TRUE, facet = outcome)
```

どの値が欠損しているかを示すために、`vis_miss()` を用いてデータフレームをヒートマップで表すことが出来ます。また `select()` を用いてある特定の列を指定することで、その列だけを示すこともできます。

```{r}
# データフレーム全体に対して欠損のヒートプロットを示す  
vis_miss(linelist)
```

### 欠損同士の関係性を探り、視覚化する {.unnumbered}

存在しないものをどうやって視覚化すればよいのでしょうか？デフォルトでは、`ggplot()` を使うと、欠損値は除いてプロットを作成してしまいます。

**naniar** の `geom_miss_point()` を用いれば解決します。2 つの列に対して散布図を作成するときに、ある一方の変数は存在し、片方の変数は欠損である場合には、欠損値をその列の最小値よりもさらに 10% 小さな値に変換し、違う色で散布図上に示してくれます。

以下に示している散布図では、赤いドットはある一方の変数は存在しているが片方の変数が欠損している場合を示しています。これによって欠損していない値に対する欠損している値の分布を視覚的に確認することが出来ます。

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = age_years, y = temp)) +     
  geom_miss_point()
```

[別の列によって層別化した]{.ul}あとに欠損を評価したい場合は、`gg_miss_fct()` を使います。これは、[カテゴリ変数（または日付）の列ごとに]{.ul}データフレームの欠損の割合をヒートマップで示してくれます。

```{r}
gg_miss_fct(linelist, age_cat5)
```

この関数を日付ごとにデータフレームを示すのに用いると、欠損が時系列を追うごとにどのように変化しているかを示すことも出来ます。

```{r}
gg_miss_fct(linelist, date_onset)
```

### "付随する"列 {.unnumbered}

ある一方の列の欠損を、もう片方の列の値ごとに示す別の方法として、**naniar** の作成する"付随する列"を用いるものがあります。`bind_shadow()` を用いると、全ての列に対して `NA` または not `NA` の 2 値変数を作成し、これらの新しい列を "\_NA" を末尾に付けた新しい列として元のデータセットに結合してくれます。すなわち、データセットの列は 2 倍になります。

```{r}
shadowed_linelist <- linelist %>% 
  bind_shadow()

names(shadowed_linelist)
```

これらの"付随する列"は、他のどの列に対してでも、欠損している値の割合をプロットするのに使えます。

例えば、以下のプロットでは、`date_hospitalisation` 列の値ごとに、`days_onset_hosp` 列（発症してから入院までの日数）における欠損の割合を示しています。x 軸の列の密度をプロットしており、興味のある付随する列によって層別化（`color =`）していることに注意してください。x 軸が数値もしくは日付の列である場合、このプロットはうまく行きます。

```{r, message = F}
ggplot(data = shadowed_linelist,          # 付随する列を含むデータフレーム
  mapping = aes(x = date_hospitalisation, # 数値もしくは日付の列
                colour = age_years_NA)) + # 興味のある付随する列
  geom_density()                          # 密度曲線をプロットする
```

以下に示すように、統計量のサマリを層別化して示すのにも"付随する列"を使用することが出来ます。

```{r}
linelist %>%
  bind_shadow() %>%                # "付随する列"を作成する
  group_by(date_outcome_NA) %>%    # 層別化に用いる"付随する列"を指定する
  summarise(across(
    .cols = age_years,             # 統計量を示したい変数を指定する
    .fns = list("mean" = mean,     # 興味のある統計量を指定する
                "sd" = sd,
                "var" = var,
                "min" = min,
                "max" = max),  
    na.rm = TRUE))                 # 統計量の計算に用いるその他のコマンド
```

以下に、列の欠損値の割合を時系列ごとに示す他の方法を示します。以下の方法では、**naniar** は[使用しません]{.ul}。以下の例は、週ごとの観測値の欠損の割合を示しています。

1)  データを、興味のある単位時間（日、週、など）でまとめ、`NA`（そしてその他興味のある値）を含む観測値の割合を計算します\
2)  `ggplot()` を用いて、欠損の割合をラインとしてプロットします

以下では、ラインリストを用いて、まず週ごとの値を新しい列として加え、値が欠損している週ごとの記録の割合を計算しています（7 に置換の割合を計算したい場合は、以下のスクリプトとは少し異なります）。

```{r}
outcome_missing <- linelist %>%
  mutate(week = lubridate::floor_date(date_onset, "week")) %>%   # 新しく week の列を作成する
  group_by(week) %>%                                             # 行を、week ごとにグルーピングする
  summarise(                                                     # それぞれの week ごとにまとめる
    n_obs = n(),                                                  # 観測値の数
    
    outcome_missing = sum(is.na(outcome) | outcome == ""),        # 欠損を含む観測値の数
    outcome_p_miss  = outcome_missing / n_obs,                    # 欠損を含む観測値の割合
  
    outcome_dead    = sum(outcome == "Death", na.rm=T),           # 死亡例の観測値の数
    outcome_p_dead  = outcome_dead / n_obs) %>%                   # 死亡例の観測地の割合
  
  tidyr::pivot_longer(-week, names_to = "statistic") %>%         # ggplot のために week を除くすべての列をロング形式にピボットする
  filter(stringr::str_detect(statistic, "_p_"))                  # 割合を示す値だけを残す
```

このデータを用いて、週ごとに欠損の割合をラインで示します。**ggplot2** というプロットのためのパッケージについてあまり詳しくない場合は、[ggplot basics] のページを参考にしてください。

```{r, message=F, warning=F}
ggplot(data = outcome_missing)+
    geom_line(
      mapping = aes(x = week, y = value, group = statistic, color = statistic),
      size = 2,
      stat = "identity")+
    labs(title = "Weekly outcomes",
         x = "Week",
         y = "Proportion of weekly records") + 
     scale_color_discrete(
       name = "",
       labels = c("Died", "Missing outcome"))+
    scale_y_continuous(breaks = c(seq(0,1,0.1)))+
  theme_minimal()+
  theme(legend.position = "bottom")
```

<!-- ======================================================= -->

## 欠損値を含むデータを使う

### 欠損値を含む行を取り除く {.unnumbered}

欠損値を含む行を除く簡単な方法は、**dplyr** パッケージの関数 `drop_na()` を用いる方法です。

元の `linelist` には `nrow(linelist)` 行含まれています。欠損値を含む行を除いた後の行数は以下になります。

```{r}
linelist %>% 
  drop_na() %>%     # あらゆる欠損値を含む列を除く
  nrow()
```

また、ある特定の列内の欠損値を含む行を除くこともできます。

```{r}
linelist %>% 
  drop_na(date_onset) %>% # date_onset 行における欠損値を含む列を除く
  nrow()
```

順番に行を表示することも出来ますし、 ["tidyselect" helper functions](#clean_tidyselect) を使うこともできます。

```{r}
linelist %>% 
  drop_na(contains("date")) %>% # "date" 行におけるあらゆる欠損値を含む列を除く 
  nrow()
```

<!-- ======================================================= -->

### `ggplot()` での `NA` の扱い方  {.unnumbered}

たいていの場合、プロットから除かれた値の数はキャプションとして報告するのが賢明です。以下に例を示します。

`ggplot()` においては、`labs()` を追加し、その中で `caption =` としてキャプションを追加することが出来ます。キャプションの中で **stringr** パッケージの `str_glue()` を使うことで、文中に直接値を張り付けることが出来るので、データそれぞれの値を用いることが出来ます。

-   `\n` は、行替えに用いることが出来ます。\
-   もし複数の列によって欠損値が定義され、プロットされていない値が決定されている場合（例えば、年齢と性別がプロットに反映されている場合）は、それら複数の列によってフィルタリングを行い、表示されていない値の数を正確に報告しなければなりません。

```{r, eval=F}
labs(
  title = "",
  y = "",
  x = "",
  caption  = stringr::str_glue(
  "n = {nrow(central_data)} from Central Hospital;
  {nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown."))  
```

`ggplot()` コマンドを使用する前に、文章をオブジェクトとして保存し、`str_glue()` 内ではそのオブジェクト名を指定するだけの方が簡単な場合もあります。

<!-- ======================================================= -->

### カテゴリ変数における`NA` {.unnumbered}

興味のある列がカテゴリ変数である場合、`NA` を文字値にするには **forcats** パッケージの `fct_explicit_na()` 関数を用いる必要があります。詳細については [Factors] ページを参考にしてください。デフォルトでは、新しい値は "(Missing)" として扱われますが、`na_level =` のコマンドによって変更することが出来ます。

```{r}
pacman::p_load(forcats)   # パッケージの読み込み

linelist <- linelist %>% 
  mutate(gender = fct_explicit_na(gender, na_level = "Missing"))

levels(linelist$gender)
```

<!-- ======================================================= -->

## 欠損値の補完

単純に全ての欠損値を除いたデータセットを解析するのではなく、"ギャップを埋めて"、欠損値を補完してからデータを解析する方が良い場合もあります。単純にすべての欠損値を除くと、いろいろ問題があることがあります。例えば：

1)  欠損値を含む観測値や大量の欠損値を含む変数を全て除くと、ある種の解析を行うパワーが減る可能性があります。例えば、先に示したように、全ての変数のうち、欠損値を含まない観測値が非常に少ない場合があります。データセットの大部分を取り除いてしまうと、大量の情報を失ってしまうことになります！さらに、たいていの変数は欠損値を含んでいます。なので、大量の欠損値を除くすべての変数を除くのはあまり合理的ではありません。

2)  欠損がなぜ生じているのかによっては、単に欠損を含まないデータのみで解析することは、解析結果にバイアスを生じたり、ミスリーディングな結果となることがあります。例えば、ある患者さんに対して熱や咳などの重要な症状の有無に関するデータを欠損しているとします。たとえば、明らかにそこまで重症でない患者さんについては記録されていない可能性もあります。その場合は、単に欠損を含む観測値を除くと、データセット内の最も健康な人々を除くことになり、非常に結果にバイアスを生じることになります。

どのくらい欠損しているか、ということに加えて、なぜ欠損が生じてるのかを考えることが重要です。そうすることで、欠損データを補完することがどうして重要なのか、そしてどの方法で補完することが一番良いのかについて判断を下しやすくなるでしょう。

### 欠損データの種類 {.unnumbered}

欠損データには主に、以下に挙げる 3 つの種類があります；

1)  **Missing Completely at Random** (MCAR) これは、欠損しているデータの割合と、その他の変数の間には何の関係もないタイプの欠損データです。すなわち、欠損しているデータの割合は全てのケースにおいて同じということですが、これはレアな状況です。しかし、自分の解析しようとしているデータが MCAR であるという強い理由がある場合には、欠損値を補完せず欠損値を含まないデータのみで解析を行っても、（パワーはいくらか失われるが）結果にバイアスは生じません。[TODO: consider discussing statistical tests for MCAR]

2)  **Missing at Random** (MAR) この名前は少しミスリーディングで、というのも、MAR は、生じている欠損のパターンを他の変数の情報から規則的に予測できるタイプの欠損データのことだからです。例えば、全てのケースにおいて、熱のデータを欠損しているのは、実は寒気と痛みのある人は熱があると推測されたために熱を測らなかったためだとします。そうだとすると、寒気と痛みのあった観測値においては、発熱もまた生じていると容易に予測することが出来、欠損値を補完するためにこの情報を使用することが出来ます。実際には、これはもう少しスペクトラム的な話で、悪寒と痛みの両方を訴えており発熱のデータを欠損している患者は発熱もしている可能性が高いが、必ずしもそうというわけではない、ということです。しかし、完全に予測できるわけではなくとも、予測可能ではあります。欠損データの種類としては、最も多いタイプのものです。

3)  **Missing not at Random** (MNAR) このタイプは、 **Not Missing at Random** (NMAR) と呼ばれることもあります。これは、欠損データの割合が系統的でなく、他の情報を用いて予測可能でもなく、また、ランダムに欠損が生じているわけでもないタイプの欠損のデータのことです。すなわち、データは何らかの明らかでない原因により欠損しているか、あるいは情報を持っていない何らかの規則に基づいて欠損しているといえます。例えば、年齢のデータが欠損しているのは、非常に高齢の患者は自分の年齢を知らないか、自分の年齢を開示したくなかったからだとします。この場合、年齢の欠損は、年齢データ自身に関連しており（すなわちランダムに生じているわけではない）、従って他の情報に基づいて欠損を予測することはできません。MNAR は複雑で、対処法としては、欠損を補完しようとするよりも、もっとデータを集めること、そしてなぜ欠損が生じているのかについての情報を収集することが良いでしょう。

まとめると、MCAR データを補完することは比較的容易ですが、一方、MNAR データを補完することは不可能ではないにしても非常にチャレンジングです。多くのデータの補完のメソッドは、MAR を仮定しています。

### 便利なパッケージ {.unnumbered}

Mmisc、missForest（ランダムフォレストによる欠損値の補完）、そして mice（連鎖方程式による多重代入法）などのパッケージは、欠損値の補完に便利です。このセクションでは、いろいろなテクニックを学ぶことの出来る mice パッケージについてのみ解説します。mice の開発者によるオンラインブックには、より詳細が示されています（<https://stefvanbuuren.name/fimd/>）。

mice パッケージを読み込みます；

```{r}
pacman::p_load(mice)
```

### 平均値代入法 {.unnumbered}

例えば、非常に単純な解析をしている、あるいは MCAR を仮定する強い理由がある時には、数値の欠損を単にその変数の平均値で代入することが出来る場合があります。例えば、我々のデータセット内の気温の欠損値は MCAR であるか単に平年値である、と仮定できる可能性があります。気温の欠損値をデータセットの値の平均値で補完した新しい変数を作成するコードを示します。しかし、多くの場合では単に平均値を補完するとバイアスを生じる可能性があるので、十分注意が必要です。

```{r}
linelist <- linelist %>%
  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))
```

同じような方法で、カテゴリ変数の欠損値をある特定の値で補完することもできます。例えば、転帰について（"Death" または "Recover"）の情報が欠損している観測値はすべて死亡データであるとします（このデータセットについては、これは本当は正しくないのですが）。

```{r}
linelist <- linelist %>%
  mutate(outcome_replace_na_with_death = replace_na(outcome, "Death"))
```

### 回帰代入法 {.unnumbered}

いくらかアドバンスな方法として、何らかの統計モデルを用いて欠損値がどんな値らしいのかを推測し、それで補完する方法があります。ここでは、体温についての情報は欠損しているけれど年齢と発熱についての情報は持っている観測値に対して、年齢（年）と発熱を予測因子とした簡単な線形回帰モデルを用いて値を予測する方法を示しています。実際には、このような単純なモデルではなく、より正確なモデルを使用した方が良いでしょう。

```{r, warning=F, message=F}
simple_temperature_model_fit <- lm(temp ~ fever + age_years, data = linelist)

#単純な体温モデルを用いて、体温の欠損値を予測する
predictions_for_missing_temps <- predict(simple_temperature_model_fit,
                                        newdata = linelist %>% filter(is.na(temp))) 
```

もしくは、体温の欠損値に対して同様にモデルを作成する方法として mice パッケージを用いる方法もあります。

```{r}
model_dataset <- linelist %>%
  select(temp, fever, age_years)  

temp_imputed <- mice(model_dataset,
                            method = "norm.predict",
                            seed = 1,
                            m = 1,
                            print = F)

temp_imputed_values <- temp_imputed$imp$temp

```

これは、欠損値を予測値で補完する、という意味で missForest パッケージなどのよりアドバンスな方法と同じタイプの方法だと言えます。missForest の場合は、線形回帰ではなくランダムフォレストを用いて予測モデルを作成します。他のタイプのモデルを使用することもできます。この方法は、MCARの場合はうまくいきますが、MAR あるいは MNAR の方がデータをうまく説明する、と思っている場合には注意が必要です。補完の質は、予測モデルがどのくらい正確か、ということにも拠りますが、正確なモデルであっても補完されたデータのばらつきが少し過小である場合もあります。

### LOCF と BOCF {.unnumbered}

Last observation carried forward (LOCF) と baseline observation carried forward (BOCF) は、時系列および縦断データの補完方法です。考え方としては、欠損の生じている観測値の前のデータで欠損値を補完しようというものです。連続で値が欠損している場合は、最後に観測された値で補完します。

LOCF および BOCF のどちらも **tidyr** パッケージの `fill()` 関数を用いて実装することが出来ます（**HMISC**、**zoo**、そして **data.table** などのパッケージを用いても行うことが出来ます）。`fill()` をどのように使うのか示すために、2000 年と 2001 年において四半期ごとの罹患数を含む単純な時系列データを作成します。しかし、Q1 以降の半期に関するデータは欠損しているので、補完する必要があります。[Pivoting data] のページにおいても、`fill()` の使用方法が示されています。

```{r}
#単純なデータセットを作成する
disease <- tibble::tribble(
  ~quarter, ~year, ~cases,
  "Q1",    2000,    66013,
  "Q2",      NA,    69182,
  "Q3",      NA,    53175,
  "Q4",      NA,    21001,
  "Q1",    2001,    46036,
  "Q2",      NA,    58842,
  "Q3",      NA,    44568,
  "Q4",      NA,    50197)

#year の欠損値を補完する
disease %>% fill(year)

```

`fill()` 関数を使用する前に、データが正しくソートされているかどうかを確認してください。`fill()` はデフォルトで"下向きに"補完しますが、 `.direction` パラメタを用いることで違う方向に補完することもできます。例えば、似たようなデータですが、今度は年の終わり（Q4）のみ記録があり、他は欠損しているデータセットがあるとします。

```{r}
#先ほどと少しだけ違うデータセットを作成する
disease <- tibble::tribble(
  ~quarter, ~year, ~cases,
  "Q1",      NA,    66013,
  "Q2",      NA,    69182,
  "Q3",      NA,    53175,
  "Q4",    2000,    21001,
  "Q1",      NA,    46036,
  "Q2",      NA,    58842,
  "Q3",      NA,    44568,
  "Q4",    2001,    50197)

#year の欠損値を、今度は"上向き"に補完する
disease %>% fill(year, .direction = "up")

```

この例では、LOCFおよびにBOCFは明らかに正しい方法でしたが、より複雑な状況ではこの方法が適切かどうかを判断するのが難しい場合もあります。例えば、初日から何日間、患者の検査値が欠損しているとします。ある場合は、これは検査値に変動がないことを示していますが、患者が回復しており、値が初日とは全く異なる可能性もあります！なので、少し注意してこれらのメソッドを使う必要があります。

### 多重代入法 {.unnumbered}

先ほど紹介した mice パッケージの開発者によるオンラインブック（<https://stefvanbuuren.name/fimd/>）には多重代入法の説明と、なぜそれをすべきなのかが詳細に記されています。ここでは、非常に基本的な方法について説明します。

多重代入法では、尤もらしい値で欠損値を代入したデータセットを複数作成します（データによってはより多くもしくは少なくデータセットを作成したい場合もあると思いますが、mice パッケージのデフォルトでは、5 つのデータセットが作成されます）。違いとしては、代入される値は、ある単一の値ではなく、予測された分布に基づき特定される値（したがっていくらかのランダムさを含んでいます）である、という点です。それぞれのデータセットに対してある種の予測モデルを用いる（mice には様々なオプションがあり、例えば[予測平均マッチング]{.ul}、[ロジスティック回帰]{.ul}、[ランダムフォレスト]{.ul}などがあります）点では同じですが、mice パッケージでは様々なモデルの詳細について考慮することが出来ます。

代入されたデータセット群を作成したら、これらの新しいデータセットに対して行おうと思っていた解析を行い、結果をプールします。この方法は、MCAR において、また MAR の多くの場合においてバイアスを減少するのに非常に有用で、より正確なスタンダードエラーを得ることが出来ます。

以下では、多重代入法を用いて、ラインリストのデータセット（より単純にした model_dataset を用いります）で、年齢と発熱のデータから体温を予測する方法を示します。

```{r}
# model_datasetにおける欠損をすべて代入し、新たに 10 つのデータセットを作成する
multiple_imputation = mice(
  model_dataset,
  seed = 1,
  m = 10,
  print = FALSE) 

model_fit <- with(multiple_imputation, lm(temp ~ age_years + fever))

base::summary(mice::pool(model_fit))
```

ここでは、mice のデフォルトの予測モデルである予測平均マッチングで欠損を補完しました。そして、それぞれの代入されたデータセットを値の推定に用いり、線形回帰によりそれぞれのデータセットにおいて得られた推定値をプールします。ここでは触れませんでしたが、mice パッケージを用いる際のより詳細な方法や多重代入法に関する様々な設定があります。例えば、常に数値データをであるとは限らず、その場合は他の代入方法を用いる必要があります（mice パッケージは、他の様々なデータの種類や補完の方法を含んでいます）。欠損データが非常に問題となる場合は、より頑健な解析結果を得るためには、単にコンプリートケースによる解析を行うよりも、多重代入法を用いる方が良いと言えるでしょう。

<!-- ======================================================= -->

## Resources

Vignette on the [naniar package](https://cran.r-project.org/web/packages/naniar/vignettes/getting-started-w-naniar.html)

Gallery of [missing value visualizations](https://cran.r-project.org/web/packages/naniar/vignettes/naniar-visualisation.html)

[Online book](https://stefvanbuuren.name/fimd/) about multiple imputation in R by the maintainer of the **mice** package

# データの結合

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
```

[上: left joinのアニメーション例（]{.ul}[画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images)[）]{.ul}

このページでは、データフレームを "join"、"match"、"link"、"bind"、その他の方法で結合する方法について説明します。

疫学分析またはワークフローには、複数のデータソースと複数のデータセットのリンクが含まれるのが一般的です。検査データと患者の臨床結果、Googleモビリティデータと感染症トレンド、あるいは分析のある段階にあるデータセットと変換されたデータセットとの接続が必要な場合があります。

このページでは、以下のコードを紹介します。

-   識別子列の共通値に基づいて行が一致するように、2つのデータフレームの[結合]{.ul}を実行する\
-   値間の[確率的]{.ul}（可能性が高い）一致に基づいて2つのデータフレームを結合する\
-   別のデータフレームから行または列を直接[結合]{.ul}または（"appending（追加）"）し、データフレームを拡張する

<!-- ======================================================= -->

## 準備

### パッケージを読み込む {.unnumbered}

このコードでは、解析に必要なパッケージの読み込みを示しています。 このハンドブックでは、必要に応じてパッケージをインストールし、[さらに]{.ul}皿使用するために読み込む **pacman** の `p_load()` を推奨しています。インストールされたパッケージを **base** R の `library()` で読み込むこともできます。R パッケージの詳細については、\[R の基礎\] のページを参照してください。

```{r}
pacman::p_load(
  rio,            # ファイルのインポートとエクスポート
  here,           # ファイルを探す 
  tidyverse,      # データ管理と可視化
  RecordLinkage,  # 確率的一致
  fastLink        # 確率的一致
)
```

### データのインポート {.unnumbered}

まず、シミュレートされたエボラ出血熱の流行から、整理された症例のラインリストをインポートします。[クリックして "整理された" ラインリストをダウンロード](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds)します（.rds ファイルとして）。`import()` 関数を使用して **rio** パッケージからデータをインポートします（.xlsx、.csv、.rds などの多くのファイルタイプを処理します。詳細については、\[データのインポート・エクスポート\] のページをご覧ください）。

```{r, echo=F}
# ラインリストを R にインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# 症例ラインリストをインポートする 
linelist <- import("linelist_cleaned.rds")
```

ラインリストの最初の50行が下に表示されます。

```{r, message=FALSE, echo=F}
# ラインリストデータを表として表示する
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

### データセットの例 {.unnumbered}

以下のデータの結合セクションでは、次のデータセットを使用します。

1)  `case_id`、`date_onset`、`hospital` の列の最初の10行のみを含む、症例 `linelist` の "ミニチュア" 版。\
2)  各病院の詳細な情報を含む、 `hosp_info` という名前の別のデータフレーム。

確率的マッチングの項では、2種類の小さなデータセットを使用する。これらのデータセットを作成するためのコードはそのセクションに記載されています。

#### "ミニチュア" 症例ラインリスト {#joins_llmini .unnumbered}

以下はミニチュアの症例のラインリストで、`case_id`、`date_onset`、`hospital` の列の最初の10行のみが含まれています。

```{r}
linelist_mini <- linelist %>%                 # 元のラインリストから始める
  select(case_id, date_onset, hospital) %>%   # 列を選択
  head(10)                                    # 最初の10行のみを取得します
```

```{r message=FALSE, echo=F}
DT::datatable(linelist_mini, rownames = FALSE, options = list(pageLength = nrow(10)))
```

#### 病院情報データフレーム {#joins_hosp_info .unnumbered}

以下は、7つの病院に関する追加情報（患者数、利用可能な医療レベル）を含む別のデータフレームを作成するためのコードです。 Nなお、"Military Hospital" という名称は、住民10000人を収容する一次病院と住民50280人を収容する二次病院の2つに属しています。

```{r}
# 病院情報データフレームを作成する
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level         = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)
```

このデータフレームは以下の通りです。

```{r message=FALSE, echo=F}
# 病院のデータを表として表示する
DT::datatable(hosp_info, rownames = FALSE, options = list(pageLength = nrow(hosp_info)))
```

<!-- ======================================================= -->

### プレクリーニング {.unnumbered}

従来の結合（非確率的）では大文字と小文字が区別され、2つのデータフレーム内の値間で文字の完全一致を必要とします。結合を開始する前に実行する必要のあるクリーニング手順のいくつかを示すために、 `linelist_mini` データセットと `hosp_info` データセットをクリーンアップして調整します。

**違いを特定する**

データフレームの `hosp_name` 列の値は、`linelist_mini` データフレームの `hospital` 列の値と一致する必要があります。

以下は、`linelist_mini` データフレームの値を、base R の基本関数 `unique()` で表示したものです。

```{r}
unique(linelist_mini$hospital)
```

hosp_infoデータフレームの値は次のとおりです。

```{r}
unique(hosp_info$hosp_name)
```

一部の病院は両方のデータフレームに存在しますが、スペルには多くの違いがあることがわかります。

**値を揃える**

まず、`hosp_info` データフレームの値をクリーンアップします。\[データクリーニングと主要関数\] のページで説明したように、**dplyr** の`case_when()` 関数を使って、論理的な基準で値を再コード化することができます。両方のデータフレームに存在する4つの病院については、`linelist_mini` の値と一致するように値を変更します。 他の病院は、値をそのままにします（`TRUE ~ hosp_name`）。

[[**注:**]{.ul} 通常、クリーニングを行う場合は新しい列を作成する必要がありますが（例: `hosp_name_clean`）、今回の例では簡単にするために古い列を修正したものを示します。 ]{style="color: orange;"}

```{r}
hosp_info <- hosp_info %>% 
  mutate(
    hosp_name = case_when(
      # 基準　　                         # 新しい値
      hosp_name == "military"          ~ "Military Hospital",
      hosp_name == "port"              ~ "Port Hospital",
      hosp_name == "St. Mark's"        ~ "St. Mark's Maternity Hospital (SMMH)",
      hosp_name == "central hospital"  ~ "Central Hospital",
      TRUE                             ~ hosp_name
      )
    )
```

両方のデータフレームに表示される病院名が揃えられました。`linelist_mini` にはない病院が`hosp_info` に2つありますが、これらは後の結合で扱います。

```{r}
unique(hosp_info$hosp_name)
```

結合の前に、列名をすべて小文字または大文字に変換することで手間を省けます。列のすべての値を大文字または小文字に変換する必要がある場合は、\[文字列型データ\] のページに示すように、`mutate()` を使用して、さらに**stringr** の以下の関数のいずれかに目的の列を適用します。

`str_to_upper()`\
`str_to_upper()`\
`str_to_title()`

<!-- ======================================================= -->

## **dplyr による結合**

**dplyr** パッケージには、いくつかの異なる結合関数があります。**dplyr** は **tidyverse** パッケージに含まれます。 これらの結合関数について、簡単な使用例とともに以下に説明します。

有益な GIF を提供してくれた[https://github.com/gadenbuie](https://github.com/gadenbuieに感謝します。)に感謝申し上げます。

<!-- ======================================================= -->

### 一般的な構文 {.unnumbered}

合コマンドは、単一のコマンドとして実行して2つのデータフレームを新しいオブジェクトに結合することも、あるいは、パイプチェーン（`%>%`）内で使用して、クリーンアップまたはその他の方法で変更するときに1つのデータフレームを別のデータフレームにマージ（併合）することもできます。

以下の例では、関数 `left_join()` を単一コマンドとして使用して、新しい `joined_data` データフレームを作成します。 結合に使用するデータはデータフレーム1と2（`df1` と `df2` ）です。 前者のデータフレームはベースラインデータフレームであり、後者のデータフレームは前者のデータフレーム[に]{.ul}結合されています。

3番目の引数 `y =` では、2つのデータフレームの行を揃えるために使用される各データフレームの列を指定することができます。 これらの列の名前が異なる場合は、以下に示すよう に`c()` ベクトル内に指定してください。ここで、行は `df1` の列 `ID`と `df2` の列 `identifier` の間の共通値に基づいて照合されます。

```{r, eval=F}
# 列 "ID"（最初のデータフレーム）と列 "identifier"（2番目のデータフレーム）の間の共通の値に基づいて結合します。
joined_data <- left_join(df1, df2, by = c("ID" = "identifier"))
```

`by` で指定する列名が両方のデータフレームで全く同じ名前である場合、この1つの名前を引用符で囲んで指定できます。

```{r, eval=F}
# 両方のデータフレームの列 "ID" の共通値に基づく結合
joined_data <- left_join(df1, df2, by = "ID")
```

複数のフィールドにまたがる共通の値に基づいてデータフレームを結合する場合は、これらのフィールドを `c()` ベクトル内で指定します。 この例では、各データセットの3つの列の値が正確に一致している場合に行が結合されます。

```{r, eval=F}
# 同じ名、姓、年齢に基づいて結合する
joined_data <- left_join(df1, df2, by = c("name" = "firstname", "surname" = "lastname", "Age" = "age"))
```

コマンドは、パイプチェーン内で実行することもできます。 これにより、パイプされるデータフレームが変更されます。

以下の例では、`df1` がパイプを通過し、`df2` がパイプに結合されるため、`df` が変更され、再定義されます。

```{r eval=F}
df1 <- df1 %>%
  filter(date_onset < as.Date("2020-03-05")) %>% # その他のクリーニング 
  left_join(df2, by = c("ID" = "identifier"))    # df2 を df1 に結合
```

[[**注:**]{.ul} 結合において大文字と小文字は区別されます。したがって、結合の前にすべての値を小文字または大文字に変換しておくと便利です。文字列型データのページを参照ください。　]{style="color: orange;"}

<!-- ======================================================= -->

### 左結合（left join）と右結合（right join） {.unnumbered}

**左結合または右結合は、データフレームに情報を追加するためによく使用されます** - 新しい情報は、ベースラインデータフレームにすでに存在する行にのみ追加されます。 これらは疫学的研究において、あるデータセットから別のデータセットに情報を追加するために使われる一般的な結合です。

これらの結合を使用する場合、コマンド内のデータフレームの記述順序が重要となります\*。

-   [左結合]{.ul}では、[最初に]{.ul}書き込まれるデータフレームがベースラインです。\
-   [右結合]{.ul}では、[2番目に]{.ul}書き込まれるデータフレームがベースラインです。

**ベースラインデータフレームのすべての行が保持されます。** 他の（二次）データフレームの情報は、[識別子として指定される列を介して一致する場合にのみ]{.ul}、ベースラインデータフレームに結合されます。加えて、

-   一致しない二次データフレームの行は削除されます

-   二次データフレームの1行に一致するベースライン行が多数ある場合（多対一）、[一致する各ベースライン行に]{.ul}二次データフレームが追加されます\

-   ベースライン行が二次リデータフレームの複数の行（1対多）と一致する場合、すべての組み合わせが指定されます。*つまり、*[返されたデータフレームに新しい行が追加される可能性があります]{.ul}

左結合と右結合のアニメーション例（[画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images)）

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
knitr::include_graphics(here::here("images", "right-join.gif"))
```

**例**

以下は、 `hosp_info` （二次データフレーム、ここに表示）の `left_join()` [を]{.ul}`linelist_mini` （ベースラインデータフレーム、[ここを参照](#joins_llmini)）[として]{.ul}アウトプットしたものです。元の `linelist_mini` の行数は `nrow(linelist_mini)` です。 変更された `linelist_mini` が表示されます。 次の点に注意してください。

-    `linelist_mini` の左側に2つの新しい列、 `catchment_pop` と `level` が追加されました\
-   ベースラインデータフレーム`linelist_mini` の元の行はすべて保持されます\
-   "Military Hospital" の `linelist_mini` の元の行は、二次データフレームの[2つの行]{.ul}と一致したため複製され、両方の組み合わせが反映されます\
-   二次リデータセットの結合識別子列（`hosp_name`）は、元のデータセットの識別子列（`hospital`）と重複しているため、削除されました\
-   ベースライン行がどの二次データフレームの行とも一致しなかった場合（たとえば、 `hospital` が "Other" または "Missing" の場合）、`NA`（空白）が二次データフレームの列に入力されます\
-   元のデータフレーム（"sisters" および "ignace" 病院）と一致しない二次データフレームの行が削除されました

```{r, eval=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

#### "右結合を使用するべきか、それとも左結合を使用するべきか？" {.unnumbered}

上記の質問に答えるために、"どのデータフレームがすべての行を保持すべきか？"と自問自答してください。 - これをベースラインとして使用します。 [左結合]{.ul}では、コマンドで指定された最初のデータフレームのすべての行が保持されますが、[右結合]{.ul}では、2番目のデータフレームのすべての行が保持されます。

以下の2つのコマンドは、10行の `hosp_info` [を]{.ul} `linelist_mini` ベースライン*に*結合するというアウトプットは同じですが、異なる結合方法によるものです。その結果、`hosp_info` が右から結合するか（左結合）、左から結合するか（右結合）によって、列の順序が異なります。それに伴い、行の順番もずれる可能性がありますが、`select()` による列の並べ替えや `arrange()` による行の並べ替えで対処することができます。

```{r, eval=F}
# 以下の2つのコマンドのアプトプットは同じデータですが、行と列の順序が異なります
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name"))
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital"))
```

こちらは、 `hosp_info` が左結合を介して `linelist_mini` に入力された結果です（新しい列は右から入力されます）。

```{r message=FALSE, echo=F}
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

これは、右結合（左から入ってくる新しい列）を介して `linelist_mini` に `hosp_info` を入れた結果です。

```{r message=FALSE, echo=F}
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

また、ユースケースがパイプチェーン内にあるかどうかも検討してください（`%>%`）。 パイプ内のデータセットがベースラインである場合は、左結合を使用してデータを追加する可能性があります。

<!-- ======================================================= -->

### 完全結合（full join） {.unnumbered}

**完全結合は、結合の中で最も[包括的な]{.ul}ものです** - 両方のデータフレームのすべての行が結合されます。

一方のデータフレームにある行があり、もう一方にはない（一致が見つからなかった）場合でも、この行はアウトプットのデータフレームにも結合されるためデータフレームはその分長くなります。`NA` の欠損値は、生じたギャップを埋めるために使用されます。 結合の際には、列や行の数に注意を払い、大文字小文字の区別や文字の完全一致のトラブルシューティングを行います。

"ベースライン" データフレームは、コマンドで最初に書き込まれるものです。これを調整しても、結合によって取得されるデータ自体には影響しませんが、結果の列の順序、行の順序、および保持される識別子の列に影響を与える可能性があります。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "full-join.gif"))
```

完全結合のアニメーション例（[画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images)）

**例**

以下は、 `hosp_info` （元々は `nrow(hosp_info)`、[ここに表示](#joins_hosp_info)）の `full_join()` を`linelist_mini` （元々は `nrow(linelist_mini)`、[ここに表示](#joins_llmini)）にアウトプットしたものです。 次の点に注意してください。

-   すべてのベースライン行が保持されます（`linelist_mini`）\
-   ベースラインと一致しない二次データの行は保持され（"ignace" と "sisters" ）、対応するベースラインの列 `case_id` と `onset` の値は欠損値で埋められる\
-   同様に、ベースラインデータフレームの行のうち、二次データ（"Other" と "Missing"）と一致しないものは保持され、二次データ列の `catchment_pop` と `level` が欠損値で埋められます\
-   一対多または多対一の場合（例えば "Military Hospital "の行）、可能なすべての組み合わせが結合されます（最終的なデータフレームが長くなります）\
-   ベースラインの識別子列のみが保持されます（`hospital`）

```{r, eval=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 15))
```

<!-- ======================================================= -->

### 内部結合（inner join） {.unnumbered}

**内部結合はデータ結合の中で最も制限の多いものです** - 両方のデータフレームで一致する行のみが結合されます。\
このため、ベースラインデータフレームの行数が実際に[減少する]{.ul}可能性があります。どのデータフレームを "ベースライン" するか（関数内で最初に指定されるデータフレーム）を調整しても、結合される行は変わりませんが、列の順番、行の順番、どの識別子列が保持されるかには影響します。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "inner-join.gif"))
```

内部結合のアニメーション例（[画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images)）

**例**

`linelist_mini` (ベースラインデータフレーム) と `hosp_info` (二次データフレーム) を `inner_join()` したときのアウトプットは以下の通りです。以下のことに注意してください。

-   二次データと一致しないベースラインの行が削除されます（ `hospital` が"Missing" または "Other" である行）\
-   同様に、ベースラインで一致しなかった二次データフレームの行も削除されます（ `hosp_name` が "sisters "または "ignace "の行）\
-   ベースラインの識別子列のみが保持されます（`hospital`）

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```

<!-- ======================================================= -->

### 準結合（semi join） {.unnumbered}

準結合は、別のデータセットを使用して[行や列を追加するのではなく、フィルタリングを実行する]{.ul} "フィルタリング結合" です。

**準結合では、二次データフレームで一致するすべての値をベースラインデータフレームに保持します** (ただし、新しい列を追加したり、複数の一致に対して行を複製したりすることはありません）。"フィルタリング" 結合について詳しくは、[こちら](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0)をご覧ください。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "semi-join.gif"))
```

準結合のアニメーション例 ([画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images))

以下のコードでは、病院名に基づいて`linelist_mini` に一致する `hosp_info` データフレームからの行が取得されます。

```{r}
hosp_info %>% 
  semi_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

<!-- ======================================================= -->

### アンチ結合（anti join） {.unnumbered}

**アンチ結合では、ベースラインデータフレームのうち、セカンダリーデータフレームと[一致しない行が]{.ul}結合される、もう1つの "フィルタリング結合" です。**

フィルタリング結合について詳しくは、[こちら](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0)をご覧ください。

アンチ結合は一般的に、別のデータフレームに存在しないデータの識別、結合のスペルのトラブルシューティング（一致するはずのデータの確認）、および別の結合後に除外されたデータの調査などに用いられます。

**`right_join()` および `left_join()` と同様に、最初にリストされる[ベースライン]{.ul}データフレームが重要です。**結合される行は、ベースラインデータフレームのみからのものです。下の GIF では、二次データフレームの行（紫の行4）がベースラインと一致しないにもかかわらず、取得されないことに注意してください。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "anti-join.gif"))
```

アンチ結合のアニメーション例 ([画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images))

#### 簡単な `anti_join()` の例 {.unnumbered}

簡単な例として、`linelist_mini` に症例が存在しない `hosp_info` の病院を検索してみましょう。ベースラインデータフレームとして、`hosp_info` を最初にリストアップする。`linelist_mini` に存在しない病院が取得される。

```{r, eval=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

```{r message=FALSE, echo=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```

#### Complex `anti_join()` example {.unnumbered}

For another example, let us say we ran an `inner_join()` between `linelist_mini` and `hosp_info`. This returns only a subset of the original `linelist_mini` records, as some are not present in `hosp_info`.

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

To review the `linelist_mini` records that were excluded during the inner join, we can run an anti-join with the same settings (`linelist_mini` as the baseline).

```{r, eval = F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

To see the `hosp_info` records that were excluded in the inner join, we could also run an anti-join with `hosp_info` as the baseline data frame.

<!-- ======================================================= -->

## Probabalistic matching

If you do not have a unique identifier common across datasets to join on, consider using a probabilistic matching algorithm. This would find matches between records based on similarity (e.g. Jaro--Winkler string distance, or numeric distance). Below is a simple example using the package **fastLink** .

**Load packages**

```{r}
pacman::p_load(
  tidyverse,      # data manipulation and visualization
  fastLink        # record matching
  )
```

Here are two small example datasets that we will use to demonstrate the probabilistic matching (`cases` and `test_results`):

Here is the code used to make the datasets:

```{r}
# make datasets

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )

```

**The `cases` dataset has 9 records** of patients who are awaiting test results.

```{r message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(cases, rownames = FALSE, options = list(pageLength = nrow(cases), scrollX=T), class = 'white-space: nowrap')
```

**The `test_results` dataset** has 14 records and contains the column `result`, which we want to add to the records in `cases` based on probabilistic matching of records.

```{r message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(results, rownames = FALSE, options = list(pageLength = nrow(results), scrollX=T), class = 'white-space: nowrap')
```

### Probabilistic matching {.unnumbered}

The `fastLink()` function from the **fastLink** package can be used to apply a matching algorithm. Here is the basic information. You can read more detail by entering `?fastLink` in your console.

-   Define the two data frames for comparison to arguments `dfA =` and `dfB =`\
-   In `varnames =` give all column names to be used for matching. They must all exist in both `dfA` and `dfB`.\
-   In `stringdist.match =` give columns from those in `varnames` to be evaluated on string "distance".\
-   In `numeric.match =` give columns from those in `varnames` to be evaluated on numeric distance.\
-   Missing values are ignored\
-   By default, each row in either data frame is matched to at most one row in the other data frame. If you want to see all the evaluated matches, set `dedupe.matches = FALSE`. The deduplication is done using Winkler's linear assignment solution.

*Tip: split one date column into three separate numeric columns using `day()`, `month()`, and `year()` from **lubridate** package*

The default threshold for matches is 0.94 (`threshold.match =`) but you can adjust it higher or lower. If you define the threshold, consider that higher thresholds could yield more false-negatives (rows that do not match which actually should match) and likewise a lower threshold could yield more false-positive matches.

Below, the data are matched on string distance across the name and district columns, and on numeric distance for year, month, and day of birth. A match threshold of 95% probability is set.

```{r, message=F, warning=F}
fl_output <- fastLink::fastLink(
  dfA = cases,
  dfB = results,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district"),
  stringdist.match = c("first", "middle", "last", "district"),
  numeric.match = c("yr", "mon", "day"),
  threshold.match = 0.95)
```

**Review matches**

We defined the object returned from `fastLink()` as `fl_output`. It is of class `list`, and it actually contains several data frames within it, detailing the results of the matching. One of these data frames is `matches`, which contains the most likely matches across `cases` and `results`. You can access this "matches" data frame with `fl_output$matches`. Below, it is saved as `my_matches` for ease of accessing later.

When `my_matches` is printed, you see two column vectors: the pairs of row numbers/indices (also called "rownames") in `cases` ("inds.a") and in `results` ("inds.b") representing the best matches. If a row number from a datafrane is missing, then no match was found in the other data frame at the specified match threshold.

```{r}
# print matches
my_matches <- fl_output$matches
my_matches
```

Things to note:

-   Matches occurred despite slight differences in name spelling and dates of birth:

    -   "Tony B. Smith" matched to "Anthony B Smith"\
    -   "Maria Rodriguez" matched to "Marialisa Rodrigues"\
    -   "Betty Chase" matched to "Elizabeth Chase"\
    -   "Olivier Laurent De Bordeaux" matched to "Oliver Laurent De Bordow" (missing date of birth ignored)\

-   One row from `cases` (for "Blessing Adebayo", row 9) had no good match in `results`, so it is not present in `my_matches`.

**Join based on the probabilistic matches**

To use these matches to join `results` to `cases`, one strategy is:

1)  Use `left_join()` to join `my_matches` to `cases` (matching rownames in `cases` to "inds.a" in `my_matches`)\
2)  Then use another `left_join()` to join `results` to `cases` (matching the newly-acquired "inds.b" in `cases` to rownames in `results`)

Before the joins, we should clean the three data frames:

-   Both `dfA` and `dfB` should have their row numbers ("rowname") converted to a proper column.\
-   Both the columns in `my_matches` are converted to class character, so they can be joined to the character rownames

```{r}
# Clean data prior to joining
#############################

# convert cases rownames to a column 
cases_clean <- cases %>% rownames_to_column()

# convert test_results rownames to a column
results_clean <- results %>% rownames_to_column()  

# convert all columns in matches dataset to character, so they can be joined to the rownames
matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))



# Join matches to dfA, then add dfB
###################################
# column "inds.b" is added to dfA
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))

# column(s) from dfB are added 
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

As performed using the code above, the resulting data frame `complete` will contain *all* columns from both `cases` and `results`. Many will be appended with suffixes ".x" and ".y", because the column names would otherwise be duplicated.

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

Alternatively, to achieve only the "original" 9 records in `cases` with the new column(s) from `results`, use `select()` on `results` before the joins, so that it contains only rownames and the columns that you want to add to `cases` (e.g. the column `result`).

```{r}
cases_clean <- cases %>% rownames_to_column()

results_clean <- results %>%
  rownames_to_column() %>% 
  select(rowname, result)    # select only certain columns 

matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))

# joins
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

If you want to subset either dataset to only the rows that matched, you can use the codes below:

```{r}
cases_matched <- cases[my_matches$inds.a,]  # Rows in cases that matched to a row in results
results_matched <- results[my_matches$inds.b,]  # Rows in results that matched to a row in cases
```

Or, to see only the rows that did **not** match:

```{r}
cases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # Rows in cases that did NOT match to a row in results
results_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # Rows in results that did NOT match to a row in cases
```

### Probabilistic deduplication {.unnumbered}

Probabilistic matching can be used to deduplicate a dataset as well. See the page on deduplication for other methods of deduplication.

Here we began with the `cases` dataset, but are now calling it `cases_dup`, as it has 2 additional rows that could be duplicates of previous rows: See "Tony" with "Anthony", and "Marialisa Rodrigues" with "Maria Rodriguez".

```{r, echo=F}
## Add duplicates
#cases_dup <- rbind(cases, cases[sample(1:nrow(cases), 3, replace = FALSE),])

cases_dup <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural",
  "M",     "Tony",   "B.",        "Smith",         1970, 09, 19,      "River", 
  "F",     "Maria",  "Contreras", "Rodriguez",     1972, 04, 15,      "River",
)

```

```{r message=FALSE, echo=F}
DT::datatable(cases_dup, rownames = FALSE, options = list(pageLength = nrow(cases_dup)))
```

Run `fastLink()` like before, but compare the `cases_dup` data frame to itself. When the two data frames provided are identical, the function assumes you want to de-duplicate. Note we do not specify `stringdist.match =` or `numeric.match =` as we did previously.

```{r, message = F, warning = F}
## Run fastLink on the same dataset
dedupe_output <- fastLink(
  dfA = cases_dup,
  dfB = cases_dup,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district")
)
```

Now, you can review the potential duplicates with `getMatches()`. Provide the data frame as both `dfA =` and `dfB =`, and provide the output of the `fastLink()` function as `fl.out =`. `fl.out` must be of class `fastLink.dedupe`, or in other words, the result of `fastLink()`.

```{r}
## Run getMatches()
cases_dedupe <- getMatches(
  dfA = cases_dup,
  dfB = cases_dup,
  fl.out = dedupe_output)
```

See the right-most column, which indicates the duplicate IDs - the final two rows are identified as being likely duplicates of rows 2 and 3.

```{r message=FALSE, echo=F}
DT::datatable(cases_dedupe, rownames = FALSE, options = list(pageLength = nrow(cases_dedupe)))
```

To return the row numbers of rows which are likely duplicates, you can count the number of rows per unique value in the `dedupe.ids` column, and then filter to keep only those with more than one row. In this case this leaves rows 2 and 3.

```{r}
cases_dedupe %>% 
  count(dedupe.ids) %>% 
  filter(n > 1)
```

To inspect the whole rows of the likely duplicates, put the row number in this command:

```{r}
# displays row 2 and all likely duplicates of it
cases_dedupe[cases_dedupe$dedupe.ids == 2,]   
```

## Binding and aligning

Another method of combining two data frames is "binding" them together. You can also think of this as "appending" or "adding" rows or columns.

This section will also discuss how to "align" the order of rows of one data frame to the order in another data frame. This topic is discussed below in the section on Binding columns.

### Bind rows {.unnumbered}

To bind rows of one data frame to the bottom of another data frame, use `bind_rows()` from **dplyr**. It is very inclusive, so any column present in either data frame will be included in the output. A few notes:

-   Unlike the **base** R version `row.bind()`, **dplyr**'s `bind_rows()` does not require that the order of columns be the same in both data frames. As long as the column names are spelled identically, it will align them correctly.\
-   You can optionally specify the argument `.id =`. Provide a character column name. This will produce a new column that serves to identify which data frame each row originally came from.\
-   You can use `bind_rows()` on a `list` of similarly-structured data frames to combine them into one data frame. See an example in the \[Iteration, loops, and lists\] page involving the import of multiple linelists with **purrr**.

One common example of row binding is to bind a "total" row onto a descriptive table made with **dplyr**'s `summarise()` function. Below we create a table of case counts and median CT values by hospital with a total row.

The function `summarise()` is used on data grouped by hospital to return a summary data frame by hospital. But the function `summarise()` does not automatically produce a "totals" row, so we create it by summarising the data *again*, but with the data not grouped by hospital. This produces a second data frame of just one row. We can then bind these data frames together to achieve the final table.

See other worked examples like this in the \[Descriptive tables\] and \[Tables for presentation\] pages.

```{r}
# Create core table
###################
hosp_summary <- linelist %>% 
  group_by(hospital) %>%                        # Group data by hospital
  summarise(                                    # Create new summary columns of indicators of interest
    cases = n(),                                  # Number of rows per hospital-outcome group     
    ct_value_med = median(ct_blood, na.rm=T))     # median CT value per group
```

Here is the `hosp_summary` data frame:

```{r message=FALSE, echo=F}
DT::datatable(hosp_summary, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Create a data frame with the "total" statistics (*not grouped by hospital*). This will return just one row.

```{r}
# create totals
###############
totals <- linelist %>% 
  summarise(
    cases = n(),                               # Number of rows for whole dataset     
    ct_value_med = median(ct_blood, na.rm=T))  # Median CT for whole dataset
```

And below is that `totals` data frame. Note how there are only two columns. These columns are also in `hosp_summary`, but there is one column in `hosp_summary` that is not in `totals` (`hospital`).

```{r message=FALSE, echo=F}
DT::datatable(totals, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Now we can bind the rows together with `bind_rows()`.

```{r}
# Bind data frames together
combined <- bind_rows(hosp_summary, totals)
```

Now we can view the result. See how in the final row, an empty `NA` value fills in for the column `hospital` that was not in `hosp_summary`. As explained in the \[Tables for presentation\] page, you could "fill-in" this cell with "Total" using `replace_na()`.

```{r message=FALSE, echo=F}
DT::datatable(combined, rownames = FALSE, options = list(pageLength = nrow(10)))
```

### Bind columns {.unnumbered}

There is a similar **dplyr** function `bind_cols()` which you can use to combine two data frames sideways. Note that rows are matched to each other *by position* (not like a *join* above) - for example the 12th row in each data frame will be aligned.

For an example, we bind several summary tables together. In order to do this, we also demonstrate how to re-arrange the order of rows in one data frame to match the order in another data frame, with `match()`.

Here we define `case_info` as a summary data frame of linelist cases, by hospital, with the number of cases and the number of deaths.

```{r}
# Case information
case_info <- linelist %>% 
  group_by(hospital) %>% 
  summarise(
    cases = n(),
    deaths = sum(outcome == "Death", na.rm=T)
  )
```

```{r message=FALSE, echo=F}
DT::datatable(case_info, rownames = FALSE, options = list(pageLength = nrow(10)))
```

And let's say that here is a different data frame `contact_fu` containing information on the percent of exposed contacts investigated and "followed-up", again by hospital.

```{r}
contact_fu <- data.frame(
  hospital = c("St. Mark's Maternity Hospital (SMMH)", "Military Hospital", "Missing", "Central Hospital", "Port Hospital", "Other"),
  investigated = c("80%", "82%", NA, "78%", "64%", "55%"),
  per_fu = c("60%", "25%", NA, "20%", "75%", "80%")
)
```

```{r message=FALSE, echo=F}
DT::datatable(contact_fu, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Note that the hospitals are the same, but are in different orders in each data frame. The easiest solution would be to use a `left_join()` on the `hospital` column, but you could also use `bind_cols()` with one extra step.

####  `match()` を使用して順序を揃える {.unnumbered}

Because the row orders are different, a simple `bind_cols()` command would result in a mis-match of data. 行の順序が異なるため、`bind_cols()` コマンドを実行すると、データが不一致になります。To fix this we can use `match()` from **base** R to align the rows of a data frame in the same order as in another. We assume for this approach that there are no duplicate values in either data frame.これを修正するには、ベースRのmatch（）を使用して、データフレームの行を別のフレームと同じ順序で整列させます。 このアプローチでは、どちらのデータフレームにも重複する値がないことを前提としています。

When we use `match()`, the syntax is `match(TARGET ORDER VECTOR, DATA FRAME COLUMN TO CHANGE)`, where the first argument is the desired order (either a stand-alone vector, or in this case a column in a data frame), and the second argument is the data frame column in the data frame that will be re-ordered. The output of `match()` is a vector of numbers representing the correct position ordering. You can read more with `?match`.

```{r}
match(case_info$hospital, contact_fu$hospital)
```

You can use this numeric vector to re-order the data frame - place it within subset brackets `[ ]` *before the comma*. この数値ベクトルを使用して、データフレームを並べ替えることができます。[コンマの前の]{.ul}サブセットブラケット\[\]内に配置します。Read more about **base** R bracket subset syntax in the \[R basics\] page. 基本Rブラケットサブセット構文の詳細については、\[Rの基礎\]ページを参照してください。The command below creates a new data frame, defined as the old one in which the rows are ordered in the numeric vector above.以下のコマンドは、行が上記の数値ベクトルで順序付けられている古いデータフレームとして定義された新しいデータフレームを作成します。

```{r}
contact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital),]
```

```{r message=FALSE, echo=F}
DT::datatable(contact_fu_aligned, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Now we can bind the data frame columns together, with the correct row order. Note that some columns are duplicated and will require cleaning with `rename()`. これで、正しい行順序でデータフレーム列をバインドできます。 一部の列が重複しており、rename（）でクリーニングする必要があることに注意してください。Read more aboout `bind_rows()` [here](https://dplyr.tidyverse.org/reference/bind.html).bind_rows()について詳しくはこちらをご覧ください。

```{r}
bind_cols(case_info, contact_fu)
```

`bind_cols` の**ベース** R の代替関数は `cbind()` であり、これで同じ操作が実行できます。

<!-- ======================================================= -->

## 資料

The [tidyverse page on joins](https://dplyr.tidyverse.org/reference/join.html)

The [R for Data Science page on relational data](https://r4ds.had.co.nz/relational-data.html)

Th [tidyverse page on dplyr](https://dplyr.tidyverse.org/reference/bind.html) on binding

A vignette on [fastLink](https://github.com/kosukeimai/fastLink) at the package's Github page

Publication describing methodology of [fastLink](https://imai.fas.harvard.edu/research/files/linkage.pdf)

Publication describing [RecordLinkage package](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

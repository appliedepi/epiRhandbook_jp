# データの結合

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
```

[上: left join のアニメーション例（]{.ul}[画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images)[）]{.ul}

このページでは、データフレームを "join"、"match"、"link"、"bind"、その他の方法で結合する方法について説明します。

疫学分析またはワークフローには、複数のデータソースと複数のデータセットのリンクが含まれるのが一般的です。検査データと患者の臨床結果、Google モビリティデータと感染症トレンド、あるいは分析のある段階にあるデータセットと変換されたデータセットとの接続が必要な場合があります。

このページでは、以下のコードを紹介します。

-   識別子列の共通値に基づいて行が一致するように、2つのデータフレームの[結合]{.ul}を実行する\
-   値間の[確率的]{.ul}（可能性が高い）一致に基づいて2つのデータフレームを結合する\
-   別のデータフレームから行または列を直接[結合]{.ul}または（"appending（追加）"）し、データフレームを拡張する

<!-- ======================================================= -->

## 準備

### パッケージを読み込む {.unnumbered}

このコードでは、解析に必要なパッケージの読み込みを示しています。 このハンドブックでは、必要に応じてパッケージをインストールし、[さらに]{.ul}皿使用するために読み込む **pacman** の `p_load()` を推奨しています。インストールされたパッケージを **base** R の `library()` で読み込むこともできます。R パッケージの詳細については、\[R の基礎\] のページを参照してください。

```{r}
pacman::p_load(
  rio,            # ファイルのインポートとエクスポート
  here,           # ファイルを探す 
  tidyverse,      # データ管理と可視化
  RecordLinkage,  # 確率的一致
  fastLink        # 確率的一致
)
```

### データのインポート {.unnumbered}

まず、シミュレートされたエボラ出血熱の流行から、整理された症例のラインリストをインポートします。[クリックして "整理された" ラインリストをダウンロード](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds)します（.rds ファイルとして）。`import()` 関数を使用して **rio** パッケージからデータをインポートします（.xlsx、.csv、.rds などの多くのファイルタイプを処理します。詳細については、\[データのインポート・エクスポート\] のページをご覧ください）。

```{r, echo=F}
# ラインリストを R にインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# 症例ラインリストをインポートする 
linelist <- import("linelist_cleaned.rds")
```

ラインリストの最初の50行が下に表示されます。

```{r, message=FALSE, echo=F}
# ラインリストデータを表として表示する
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

### データセットの例 {.unnumbered}

以下のデータの結合セクションでは、次のデータセットを使用します。

1)  `case_id`、`date_onset`、`hospital` の列の最初の10行のみを含む、症例 `linelist` の "ミニチュア" 版。\
2)  各病院の詳細な情報を含む、 `hosp_info` という名前の別のデータフレーム。

確率的マッチングの項では、2種類の小さなデータセットを使用する。これらのデータセットを作成するためのコードはそのセクションに記載されています。

#### "ミニチュア" 症例ラインリスト {#joins_llmini .unnumbered}

以下はミニチュアの症例のラインリストで、`case_id`、`date_onset`、`hospital` の列の最初の10行のみが含まれています。

```{r}
linelist_mini <- linelist %>%                 # 元のラインリストから始める
  select(case_id, date_onset, hospital) %>%   # 列を選択
  head(10)                                    # 最初の10行のみを取得します
```

```{r message=FALSE, echo=F}
DT::datatable(linelist_mini, rownames = FALSE, options = list(pageLength = nrow(10)))
```

#### 病院情報データフレーム {#joins_hosp_info .unnumbered}

以下は、7つの病院に関する追加情報（患者数、利用可能な医療レベル）を含む別のデータフレームを作成するためのコードです。 Nなお、"Military Hospital" という名称は、住民10000人を収容する一次病院と住民50280人を収容する二次病院の2つに属しています。

```{r}
# 病院情報データフレームを作成する
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level         = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)
```

このデータフレームは以下の通りです。

```{r message=FALSE, echo=F}
# 病院のデータを表として表示する
DT::datatable(hosp_info, rownames = FALSE, options = list(pageLength = nrow(hosp_info)))
```

<!-- ======================================================= -->

### プレクリーニング {.unnumbered}

従来の結合（非確率的）では大文字と小文字が区別され、2つのデータフレーム内の値間で文字の完全一致を必要とします。結合を開始する前に実行する必要のあるクリーニング手順のいくつかを示すために、 `linelist_mini` データセットと `hosp_info` データセットをクリーンアップして調整します。

**違いを特定する**

データフレームの `hosp_name` 列の値は、`linelist_mini` データフレームの `hospital` 列の値と一致する必要があります。

以下は、`linelist_mini` データフレームの値を、base R の基本関数 `unique()` で表示したものです。

```{r}
unique(linelist_mini$hospital)
```

hosp_infoデータフレームの値は次のとおりです。

```{r}
unique(hosp_info$hosp_name)
```

一部の病院は両方のデータフレームに存在しますが、スペルには多くの違いがあることがわかります。

**値を揃える**

まず、`hosp_info` データフレームの値をクリーンアップします。\[データクリーニングと主要関数\] のページで説明したように、**dplyr** の`case_when()` 関数を使って、論理的な基準で値を再コード化することができます。両方のデータフレームに存在する4つの病院については、`linelist_mini` の値と一致するように値を変更します。 他の病院は、値をそのままにします（`TRUE ~ hosp_name`）。

[[**注:**]{.ul} 通常、クリーニングを行う場合は新しい列を作成する必要がありますが（例: `hosp_name_clean`）、今回の例では簡単にするために古い列を修正したものを示します。]{style="color: orange;"}

```{r}
hosp_info <- hosp_info %>% 
  mutate(
    hosp_name = case_when(
      # 基準　　                         # 新しい値
      hosp_name == "military"          ~ "Military Hospital",
      hosp_name == "port"              ~ "Port Hospital",
      hosp_name == "St. Mark's"        ~ "St. Mark's Maternity Hospital (SMMH)",
      hosp_name == "central hospital"  ~ "Central Hospital",
      TRUE                             ~ hosp_name
      )
    )
```

両方のデータフレームに表示される病院名が揃えられました。`linelist_mini` にはない病院が`hosp_info` に2つありますが、これらは後の結合で扱います。

```{r}
unique(hosp_info$hosp_name)
```

結合の前に、列名をすべて小文字または大文字に変換することで手間を省けます。列のすべての値を大文字または小文字に変換する必要がある場合は、\[文字列型データ\] のページに示すように、`mutate()` を使用して、さらに**stringr** の以下の関数のいずれかに目的の列を適用します。

`str_to_upper()`\
`str_to_upper()`\
`str_to_title()`

<!-- ======================================================= -->

## **dplyr による結合**

**dplyr** パッケージには、いくつかの異なる結合関数があります。**dplyr** は **tidyverse** パッケージに含まれます。 これらの結合関数について、簡単な使用例とともに以下に説明します。

有益な GIF を提供してくれた[https://github.com/gadenbuie](https://github.com/gadenbuieに感謝します。)に感謝申し上げます。

<!-- ======================================================= -->

### 一般的な構文 {.unnumbered}

結合コマンドは、単一のコマンドとして実行して2つのデータフレームを新しいオブジェクトに結合することも、あるいは、パイプチェーン（`%>%`）内で使用して、クリーンアップまたはその他の方法で変更するときに1つのデータフレームを別のデータフレームにマージ（併合）することもできます。

以下の例では、関数 `left_join()` を単一コマンドとして使用して、新しい `joined_data` データフレームを作成します。 結合に使用するデータはデータフレーム1と2（`df1` と `df2` ）です。 前者のデータフレームはベースラインデータフレームであり、後者のデータフレームは前者のデータフレーム[に]{.ul}結合されています。

3番目の引数 `y =` では、2つのデータフレームの行を揃えるために使用される各データフレームの列を指定することができます。 これらの列の名前が異なる場合は、以下に示すよう に`c()` ベクトル内に指定してください。ここで、行は `df1` の列 `ID`と `df2` の列 `identifier` の間の共通値に基づいて照合されます。

```{r, eval=F}
# 列 "ID"（最初のデータフレーム）と列 "identifier"（2番目のデータフレーム）の間の共通の値に基づいて結合します。
joined_data <- left_join(df1, df2, by = c("ID" = "identifier"))
```

`by` で指定する列名が両方のデータフレームで全く同じ名前である場合、この1つの名前を引用符で囲んで指定できます。

```{r, eval=F}
# 両方のデータフレームの列 "ID" の共通値に基づく結合
joined_data <- left_join(df1, df2, by = "ID")
```

複数のフィールドにまたがる共通の値に基づいてデータフレームを結合する場合は、これらのフィールドを `c()` ベクトル内で指定します。 この例では、各データセットの3つの列の値が正確に一致している場合に行が結合されます。

```{r, eval=F}
# 同じ名、姓、年齢に基づいて結合する
joined_data <- left_join(df1, df2, by = c("name" = "firstname", "surname" = "lastname", "Age" = "age"))
```

コマンドは、パイプチェーン内で実行することもできます。 これにより、パイプされるデータフレームが変更されます。

以下の例では、`df1` がパイプを通過し、`df2` がパイプに結合されるため、`df` が変更され、再定義されます。

```{r eval=F}
df1 <- df1 %>%
  filter(date_onset < as.Date("2020-03-05")) %>% # その他のクリーニング 
  left_join(df2, by = c("ID" = "identifier"))    # df2 を df1 に結合
```

[[**注:**]{.ul} 結合において大文字と小文字は区別されます。したがって、結合の前にすべての値を小文字または大文字に変換しておくと便利です。文字列型データのページを参照ください。　]{style="color: orange;"}

<!-- ======================================================= -->

### 左結合（left join）と右結合（right join） {.unnumbered}

**左結合または右結合は、データフレームに情報を追加するためによく使用されます** - 新しい情報は、ベースラインデータフレームにすでに存在する行にのみ追加されます。 これらは疫学的研究において、あるデータセットから別のデータセットに情報を追加するために使われる一般的な結合です。

これらの結合を使用する場合、コマンド内のデータフレームの記述順序が重要となります\*。

-   [左結合]{.ul}では、[最初に]{.ul}書き込まれるデータフレームがベースラインです。\
-   [右結合]{.ul}では、[2番目に]{.ul}書き込まれるデータフレームがベースラインです。

**ベースラインデータフレームのすべての行が保持されます。** 他の（二次）データフレームの情報は、[識別子として指定される列を介して一致する場合にのみ]{.ul}、ベースラインデータフレームに結合されます。加えて、

-   一致しない二次データフレームの行は削除されます

-   二次データフレームの1行に一致するベースライン行が多数ある場合（多対一）、[一致する各ベースライン行に]{.ul}二次データフレームが追加されます\

-   ベースライン行が二次リデータフレームの複数の行（1対多）と一致する場合、すべての組み合わせが指定されます。*つまり、*[返されたデータフレームに新しい行が追加される可能性があります]{.ul}

左結合と右結合のアニメーション例（[画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images)）

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
knitr::include_graphics(here::here("images", "right-join.gif"))
```

**例**

以下は、 `hosp_info` （二次データフレーム、ここに表示）の `left_join()` [を]{.ul}`linelist_mini` （ベースラインデータフレーム、[ここを参照](#joins_llmini)）[として]{.ul}アウトプットしたものです。元の `linelist_mini` の行数は `nrow(linelist_mini)` です。 変更された `linelist_mini` が表示されます。 次の点に注意してください。

-   `linelist_mini` の左側に2つの新しい列、 `catchment_pop` と `level` が追加されました\
-   ベースラインデータフレーム`linelist_mini` の元の行はすべて保持されます\
-   "Military Hospital" の `linelist_mini` の元の行は、二次データフレームの[2つの行]{.ul}と一致したため複製され、両方の組み合わせが反映されます\
-   二次リデータセットの結合識別子列（`hosp_name`）は、元のデータセットの識別子列（`hospital`）と重複しているため、削除されました\
-   ベースライン行がどの二次データフレームの行とも一致しなかった場合（たとえば、 `hospital` が "Other" または "Missing" の場合）、`NA`（空白）が二次データフレームの列に入力されます\
-   元のデータフレーム（"sisters" および "ignace" 病院）と一致しない二次データフレームの行が削除されました

```{r, eval=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

#### "右結合を使用するべきか、それとも左結合を使用するべきか？" {.unnumbered}

上記の質問に答えるために、"どのデータフレームがすべての行を保持すべきか？"と自問自答してください。 - これをベースラインとして使用します。 [左結合]{.ul}では、コマンドで指定された最初のデータフレームのすべての行が保持されますが、[右結合]{.ul}では、2番目のデータフレームのすべての行が保持されます。

以下の2つのコマンドは、10行の `hosp_info` [を]{.ul} `linelist_mini` ベースライン*に*結合するというアウトプットは同じですが、異なる結合方法によるものです。その結果、`hosp_info` が右から結合するか（左結合）、左から結合するか（右結合）によって、列の順序が異なります。それに伴い、行の順番もずれる可能性がありますが、`select()` による列の並べ替えや `arrange()` による行の並べ替えで対処することができます。

```{r, eval=F}
# 以下の2つのコマンドのアプトプットは同じデータですが、行と列の順序が異なります
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name"))
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital"))
```

こちらは、 `hosp_info` が左結合を介して `linelist_mini` に入力された結果です（新しい列は右から入力されます）。

```{r message=FALSE, echo=F}
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

これは、右結合（左から入ってくる新しい列）を介して `linelist_mini` に `hosp_info` を入れた結果です。

```{r message=FALSE, echo=F}
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

また、ユースケースがパイプチェーン内にあるかどうかも検討してください（`%>%`）。 パイプ内のデータセットがベースラインである場合は、左結合を使用してデータを追加する可能性があります。

<!-- ======================================================= -->

### 完全結合（full join） {.unnumbered}

**完全結合は、結合の中で最も[包括的な]{.ul}ものです** - 両方のデータフレームのすべての行が結合されます。

一方のデータフレームにある行があり、もう一方にはない（一致が見つからなかった）場合でも、この行はアウトプットのデータフレームにも結合されるためデータフレームはその分長くなります。`NA` の欠損値は、生じたギャップを埋めるために使用されます。 結合の際には、列や行の数に注意を払い、大文字小文字の区別や文字の完全一致のトラブルシューティングを行います。

"ベースライン" データフレームは、コマンドで最初に書き込まれるものです。これを調整しても、結合によって取得されるデータ自体には影響しませんが、結果の列の順序、行の順序、および保持される識別子の列に影響を与える可能性があります。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "full-join.gif"))
```

完全結合のアニメーション例（[画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images)）

**例**

以下は、 `hosp_info` （元々は `nrow(hosp_info)`、[ここに表示](#joins_hosp_info)）の `full_join()` を`linelist_mini` （元々は `nrow(linelist_mini)`、[ここに表示](#joins_llmini)）にアウトプットしたものです。 次の点に注意してください。

-   すべてのベースライン行が保持されます（`linelist_mini`）\
-   ベースラインと一致しない二次データの行は保持され（"ignace" と "sisters" ）、対応するベースラインの列 `case_id` と `onset` の値は欠損値で埋められる\
-   同様に、ベースラインデータフレームの行のうち、二次データ（"Other" と "Missing"）と一致しないものは保持され、二次データ列の `catchment_pop` と `level` が欠損値で埋められます\
-   一対多または多対一の場合（例えば "Military Hospital "の行）、可能なすべての組み合わせが結合されます（最終的なデータフレームが長くなります）\
-   ベースラインの識別子列のみが保持されます（`hospital`）

```{r, eval=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 15))
```

<!-- ======================================================= -->

### 内部結合（inner join） {.unnumbered}

**内部結合はデータ結合の中で最も制限の多いものです** - 両方のデータフレームで一致する行のみが結合されます。\
このため、ベースラインデータフレームの行数が実際に[減少する]{.ul}可能性があります。どのデータフレームを "ベースライン" するか（関数内で最初に指定されるデータフレーム）を調整しても、結合される行は変わりませんが、列の順番、行の順番、どの識別子列が保持されるかには影響します。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "inner-join.gif"))
```

内部結合のアニメーション例（[画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images)）

**例**

`linelist_mini` (ベースラインデータフレーム) と `hosp_info` (二次データフレーム) を `inner_join()` したときのアウトプットは以下の通りです。以下のことに注意してください。

-   二次データと一致しないベースラインの行が削除されます（ `hospital` が"Missing" または "Other" である行）\
-   同様に、ベースラインで一致しなかった二次データフレームの行も削除されます（ `hosp_name` が "sisters "または "ignace "の行）\
-   ベースラインの識別子列のみが保持されます（`hospital`）

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```

<!-- ======================================================= -->

### 準結合（semi join） {.unnumbered}

準結合は、別のデータセットを使用して[行や列を追加するのではなく、フィルタリングを実行する]{.ul} "フィルタリング結合" です。

**準結合では、二次データフレームで一致するすべての値をベースラインデータフレームに保持します** (ただし、新しい列を追加したり、複数の一致に対して行を複製したりすることはありません）。"フィルタリング" 結合について詳しくは、[こちら](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0)をご覧ください。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "semi-join.gif"))
```

準結合のアニメーション例 ([画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images))

以下のコードでは、病院名に基づいて`linelist_mini` に一致する `hosp_info` データフレームからの行が取得されます。

```{r}
hosp_info %>% 
  semi_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

<!-- ======================================================= -->

### アンチ結合（anti join） {.unnumbered}

**アンチ結合では、ベースラインデータフレームのうち、セカンダリーデータフレームと[一致しない行が]{.ul}結合される、もう1つの "フィルタリング結合" です。**

フィルタリング結合について詳しくは、[こちら](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0)をご覧ください。

アンチ結合は一般的に、別のデータフレームに存在しないデータの識別、結合のスペルのトラブルシューティング（一致するはずのデータの確認）、および別の結合後に除外されたデータの調査などに用いられます。

**`right_join()` および `left_join()` と同様に、最初にリストされる[ベースライン]{.ul}データフレームが重要です。**結合される行は、ベースラインデータフレームのみからのものです。下の GIF では、二次データフレームの行（紫の行4）がベースラインと一致しないにもかかわらず、取得されないことに注意してください。

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "anti-join.gif"))
```

アンチ結合のアニメーション例 ([画像提供元](https://github.com/gadenbuie/tidyexplain/tree/master/images))

#### 簡単な `anti_join()` の例 {.unnumbered}

簡単な例として、`linelist_mini` に症例が存在しない `hosp_info` の病院を検索してみましょう。ベースラインデータフレームとして、`hosp_info` を最初にリストアップする。`linelist_mini` に存在しない病院が取得される。

```{r, eval=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

```{r message=FALSE, echo=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```

#### 複雑な `anti_join()` の例 {.unnumbered}

別の例として、`linelist_mini` と `hosp_info` で `inner_join()` を実行したとします。これは、`hosp_info` に存在しないものもあるため、オリジナルの `linelist_mini`　のサブセットデータのみが得られます。

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

内部結合中に除外された `linelist_mini` データを確認するために、同じ設定でアンチジョインを実行します（ `linelist_mini` をベースラインとします）。

```{r, eval = F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

内部結合で除外された `hosp_info` データを確認するために、ベースラインデータフレームとして `hosp_info` を使用してアンチ結合を実行することも可能です。

<!-- ======================================================= -->

## 確率的マッチング

データセット間で共通する識別子がない場合は、確率的なマッチングアルゴリズムを使用することを検討してください。これは、レコード間の類似性（例えば、Jaro-Winkler 文字列距離や数値距離）に基づいてマッチングを見つけるものです。以下は、**fastLink** パッケージを使用した簡単な例です。

**パッケージを読み込む**

```{r}
pacman::p_load(
  tidyverse,      # データ整理と可視化
  fastLink        # データ結合
  )
```

確率的マッチング（`cases` と `test_results`）を示すために使用する2つの小さなサンプルデータセットを次に示します。

以下は、データセットを作成するためのコードです。

```{r}
# データセットを作成する

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )

```

**`cases` データセットには**、検査結果を待っている患者の記録が**9件ある。**

```{r message=FALSE, echo=F}
# 病院データを表として表示する
DT::datatable(cases, rownames = FALSE, options = list(pageLength = nrow(cases), scrollX=T), class = 'white-space: nowrap')
```

**`test_results` データセット**には14件の記録があり、`result` という列があります。この列は、記録の確率的マッチングに基づいて `cases` 内の記録に追加したいものです。

```{r message=FALSE, echo=F}
# 病院データを表として表示する
DT::datatable(results, rownames = FALSE, options = list(pageLength = nrow(results), scrollX=T), class = 'white-space: nowrap')
```

### 確率的マッチング {.unnumbered}

**fastLink** パッケージの `fastLink()` 関数を使用して、マッチングアルゴリズムを適用できます。以下が基本的な情報です。 コンソールに `?fastLink` と入力すると、詳細を読むことができます。

-   引数`dfA =` および`dfB =` を比較するために2つのデータフレームを定義します\
-   `varnames =` で、マッチングに使用するすべての列名を指定します。ここで指定される列はすべて `dfA` と `dfB` の両方に存在する必要があります。\
-   `stringdist.match =` で、文字列 "distance "に対して評価する列を `varnames` にある列の中から指定する。\
-   `numeric.match =` で、`varnames` にある列の中から、数値距離で評価する列を指定する。\
-   欠損値は無視されます\
-   デフォルトでは、どちらかのデータフレームの各行が、もう一方のデータフレームの最大1行とマッチングされます。評価済みのマッチをすべて表示したい場合は、 `dedupe.matches = FALSE` と設定してください。Winkler の線形割り当てソリューションで重複排除が行われる。

[ヒント: **lubridate** パッケージの `day()`、 `month()`、 `year()` を用いて、ひとつの日付カラムを 3 つの別々の数値カラムに分割します。]{.ul}

マッチングの閾値のデフォルトは0.94（`threshold.match =` ）ですが、この値は調整可能です。閾値を高くすると偽陰性（マッチするはずの行がマッチしない）が増える可能性があり、同様に閾値を低くすると偽陽性が増えうることを考慮して、閾値を設定してください。

以下では、名前と地区の列については文字列の距離で、年、月、誕生日については数値の距離でデータをマッチングしている。マッチングの閾値は95%の確率で設定されている。

```{r, message=F, warning=F}
fl_output <- fastLink::fastLink(
  dfA = cases,
  dfB = results,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district"),
  stringdist.match = c("first", "middle", "last", "district"),
  numeric.match = c("yr", "mon", "day"),
  threshold.match = 0.95)
```

**マッチを確認する**

`fastLink()` から得られるオブジェクトを`fl_output` として定義しました。 このオブジェクトのクラス（型）は `list` であり、実際にはその中にいくつかのデータフレームが含まれており、マッチングの結果の詳細が示されています。データフレームには `fl_output$matches` でアクセスすることができます。以下では、後でアクセスしやすいように `my_matches` という名前で保存します。

アウトプットの`my_matches` には、2つの列ベクトルが表示されます。`cases`（ "inds.a"）と `results`（ "inds.b"）の行番号/インデックスのペア（ "rownames"とも呼ばれます）がベストマッチを表します。データフレームの行番号が欠落している場合、もう一方のデータフレームに指定されたマッチングの閾値で対応する値が見つからなかったことを意味します。

```{r}
# マッチングを表示
my_matches <- fl_output$matches
my_matches
```

注意すべき点は以下の通りです。

-   名前のスペルや生年月日が若干異なるにもかかわらず、マッチングが成立した。

    -   "Tony B. Smith" が "Anthony B Smith" とマッチした\
    -   "Maria Rodriguez" が "Marialisa Rodrigues" とマッチした\
    -   "Betty Chase" が "Elizabeth Chase" とマッチした\
    -   "Olivier Laurent De Bordeaux" が "Oliver Laurent De Bordow" とマッチした（生年月日の欠落は無視）\

-   `cases` から1行（"Blessing Adebayo" の9行目）は、結果的に良い一致がなかったため、 `my_matches` には存在しない。

**確率的な一致に基づく結合**

これらの一致を使用して `results` を `cases` に結合するための戦略は、次のとおりです。

1)  `left_join()` を使用して、`my_matches` を `cases` に結合します（`cases` の行名を `my_matches` の "inds.a"に一致させます）\
2)  次に、もう一度 `left_join()` を使用し、今度は `results` を `cases` に結合します（ `cases` から新しく取得された "inds.b" を結果の行名に一致させます）

結合を行う前に、3つのデータフレームをクリーンアップする必要があります。

-   `dfA` と`dfB` の行番号（"rowname"）を列に変換する必要があります。\
-   `my_matches` の両方の列は文字型データに変換されるため、文字の行名に結合できます

```{r}
# 結合前のデータのクリーニング
#############################

# casesの行番号（rowname）を列に変換する 
cases_clean <- cases %>% rownames_to_column()

# test_results の 行番号（rownames） を列に変換する
results_clean <- results %>% rownames_to_column()  

#  データセットの全ての列を文字列に変換し、行番号で 結合できるようにする。
matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))



# matches_clean を dfA に結合、その後 dfB も結合
###################################
# 列 "inds.b" を dfA に追加する
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))

# dfB 由来の列を追加する 
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

上記のコードで実行すると、結果のデータフレーム `complete` は `cases` と `results` の両方のすべての列を含むことになります。多くの場合、列名が重複してしまうため、".x" や ".y" といった添え字が付加されます。

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

あるいは、 `cases` の9件の記録に `results` の新しい列を追加するには、結合の前に `select()` を使用し`results` を選択し、行番号の列と `cases` に追加する列（例えば、列 `result`）を含めるだけにしておくといいでしょう。

```{r}
cases_clean <- cases %>% rownames_to_column()

results_clean <- results %>%
  rownames_to_column() %>% 
  select(rowname, result)    # 特定の列のみを選択する

matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))

# 結合
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

どちらかのデータセットをマッチした行だけにサブセットしたい場合は、以下のコードを使用することができます。

```{r}
cases_matched <- cases[my_matches$inds.a,]  # results の行と一致した cases の行
results_matched <- results[my_matches$inds.b,]  # cases の行と一致した results の行
```

または、一致しなかった行**のみ**を表示する。

```{r}
cases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # results の行と一致しなかった cases の行
results_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # cases の行と一致しなかった results の行
```

### 確率的な重複排除 {.unnumbered}

確率的マッチングは、データセットの重複排除にも使用できます。その他の重複排除の方法については、重複排除のページを参照してください。

ここでは、 `cases` データセットから始めていますが、前の行と重複する可能性のある行が2つ追加されているため、 `cases_dup` としています。 "Tony" と "Anthony"、"Marialisa Rodrigues" と "Maria Rodriguez" を参照してください、

```{r, echo=F}
## 重複の追加
#cases_dup <- rbind(cases, cases[sample(1:nrow(cases), 3, replace = FALSE),])

cases_dup <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural",
  "M",     "Tony",   "B.",        "Smith",         1970, 09, 19,      "River", 
  "F",     "Maria",  "Contreras", "Rodriguez",     1972, 04, 15,      "River",
)

```

```{r message=FALSE, echo=F}
DT::datatable(cases_dup, rownames = FALSE, options = list(pageLength = nrow(cases_dup)))
```

以前と同じように `fastLink()` を実行し、`cases_dup` データフレームと比較します。提供された2つのデータフレームが同一である場合、この関数は重複を解消することを想定しています。以前のように `stringdist.match =` や `numeric.match =` は指定しないことに注意してください。

```{r, message = F, warning = F}
## 同じデータセットにfastLinkを実行する
dedupe_output <- fastLink(
  dfA = cases_dup,
  dfB = cases_dup,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district")
)
```

`getMatches()` で重複の可能性があるものを確認することができます。データフレームを `dfA =` と `dfB =` の両方で指定し、`fastLink()` 関数のアウトプットを `fl.out =` とします。`fl.out` は `fastLink.dedupe` クラスでなければならず、言い換えれば`fastLink()` の結果である必要があります。

```{r}
## getMatches() を実行
cases_dedupe <- getMatches(
  dfA = cases_dup,
  dfB = cases_dup,
  fl.out = dedupe_output)
```

一番右の列は重複する ID を表しており、最後の2行は2行目と3行目と重複している可能性が高いことが分かります。

```{r message=FALSE, echo=F}
DT::datatable(cases_dedupe, rownames = FALSE, options = list(pageLength = nrow(cases_dedupe)))
```

重複していると思われる行の行番号を把握するには、 `dedupe.ids` 列の重複のない値ごとに行数をカウントし、複数の行があるものだけを残すようにフィルタリングします。この場合、2行目と3行目が残ります。

```{r}
cases_dedupe %>% 
  count(dedupe.ids) %>% 
  filter(n > 1)
```

重複している可能性がある行全体を確認するために、このコマンドに行番号を入れます。

```{r}
# 2行目とその重複候補をすべて表示する
cases_dedupe[cases_dedupe$dedupe.ids == 2,]   
```

## データの結合と整列

2つのデータフレームを結合するもう一つの方法は、それらを "bind（結合）" することです。これは、行や列を "追加" することだと捉えることもできます。

このセクションでは、データフレームの行の順番を別のデータフレームの順番に "揃える" 方法についても説明します。このトピックについては、列の結合のセクションで後述します。

### 行を結合する {.unnumbered}

データフレームの行を別のデータフレームの下部にバインドするには、**dplyr**の `bind_rows()` を使用します。この方法は非常に包括的であるため、いずれかのデータフレームに存在するすべての列が結合されます。 以下のことに注意してください。

-   **ベース** R バージョンの `row.bind()` とは異なり、**dplyr** の `bind_rows()` では、両方のデータフレームで列の順序が同じである必要はありません。列名のスペルが同じである限り、データは正しく揃えられます。\
-   `.id =`. オプションで、引数 `.id =` を指定できます。文字列名を指定してください。これにより、各行が元々どのデータフレームからのものであるかを識別するのに役立つ新しい列が生成されます。\
-   同様の構造を持つデータフレームの `list` で `bind_rows()` を使用して、それらを1つのデータフレームに結合できます。\[ループと反復処理・リストの操作\] ページで、**purrr** を使用した複数のラインリストのインポートに関する例を参照してください。

行による結合の一般的な例の1つは、"合計" の行数を **dplyr** の `summarise()` 関数で作成された要約表に結合する方法です。以下に、合計行を含む病院ごとの症例数と中央値 CT 値の表を作成します。

関数 `summarise()` は、病院ごとにグループ化されたデータに対して使用され、病院ごとに要約データフレームが得られます。ただし、関数 `summarise()` では "合計" 行は自動的に生成されないため、データを再度要約して作成しますが、データは病院ごとにグループ化されていません。これにより、1行だけの2番目のデータフレームが生成されます。これらのデータフレームを結合し、ファイナルテーブルを作成できます。

\[記述統計表の作り方\] および \[見やすい表の作り方\] ページで、このような他の実例を参照してください。

```{r}
# コアテーブルの作成
###################
hosp_summary <- linelist %>% 
  group_by(hospital) %>%                        # 病院別のグループデータ
  summarise(                                    # 目的の指標の新しい要約列を作成する
    cases = n(),                                  # 病院ごとの行数-結果グループ
    ct_value_med = median(ct_blood, na.rm=T))     # グループあたりのCT値の中央値
```

`hosp_summary` データフレームは次のとおりです。

```{r message=FALSE, echo=F}
DT::datatable(hosp_summary, rownames = FALSE, options = list(pageLength = nrow(10)))
```

"合計" 統計（[病院ごとにグループ化されていない]{.ul}）を使用しデータフレームを作成します。 これにより、1行だけが得られます。

```{r}
# totals を作成
###############
totals <- linelist %>% 
  summarise(
    cases = n(),                               # データセット全体の行数    
    ct_value_med = median(ct_blood, na.rm=T))  # データセット全体のCT中央値
```

以下はその `totals` データフレームです。列が2つしかないことに注意してください。これらの列は `hosp_summary` にありますが、 `hosp_summary` には `totals`（`hospital`）にない列が1つあります。

```{r message=FALSE, echo=F}
DT::datatable(totals, rownames = FALSE, options = list(pageLength = nrow(10)))
```

これで、`bind_rows()` を使用して行を結合できます。

```{r}
# データフレームを結合する
combined <- bind_rows(hosp_summary, totals)
```

これで結果が表示されます。 最後の行で、`hosp_summary` になかった列 `hospital` の空の `NA` 値がどのように入力されるかを確認してください。\[見やすい表の作り方\] ページで説明されているように、 `replace_na()` を使用し、このセルに "合計" を "入力" できます。

```{r message=FALSE, echo=F}
DT::datatable(combined, rownames = FALSE, options = list(pageLength = nrow(10)))
```

### 列での結合 {.unnumbered}

同様の **dplyr** 関数、 `bind_cols()` を使用して2つのデータフレームを横向きに組み合わせることができます。行は[位置をもとに]{.ul}互いにマッチングされることに注意してください（上記の[結合]{.ul} *join* とは異なります）- たとえば、各データフレームの12行目が整列されます。

たとえば、いくつかのサマリーテーブルを結合します。これを行うために、 `match()` を使用して、データフレームの行の順序を別のデータフレームの順序と一致するように再配置する方法も示します。

この例では、 `case_info` を、病院ごとのラインリスト症例の要約データフレームとして、症例数と死亡数とともに定義します。

```{r}
# Case information を定義する
case_info <- linelist %>% 
  group_by(hospital) %>% 
  summarise(
    cases = n(),
    deaths = sum(outcome == "Death", na.rm=T)
  )
```

```{r message=FALSE, echo=F}
DT::datatable(case_info, rownames = FALSE, options = list(pageLength = nrow(10)))
```

また、ここでも病院ごとに調査および "フォローアップ" され、患者の連絡先の割合に関する情報を含む別のデータフレーム `contact_fu` があるとします。

```{r}
contact_fu <- data.frame(
  hospital = c("St. Mark's Maternity Hospital (SMMH)", "Military Hospital", "Missing", "Central Hospital", "Port Hospital", "Other"),
  investigated = c("80%", "82%", NA, "78%", "64%", "55%"),
  per_fu = c("60%", "25%", NA, "20%", "75%", "80%")
)
```

```{r message=FALSE, echo=F}
DT::datatable(contact_fu, rownames = FALSE, options = list(pageLength = nrow(10)))
```

病院は同じですが、データフレームごとに順序が異なることに注意してください。最も簡単な解決策は、病院の列で `left_join()` を使用することですが、もうひとつステップを追加することにより `bind_cols()` を使用することもできます。

#### `match()` を使用して順序を揃える {.unnumbered}

行の順序が異なるため、`bind_cols()` コマンドを実行すると、データの不一致が生じなす。これを修正するには、**ベース** R の `match()` を使用し、データフレームの行を別のフレームと同じ順序で整列させます。 このアプローチでは、どちらのデータフレームにも重複する値がないことを前提としています。

`match()` を使用する場合、構文は `match(TARGET ORDER VECTOR, DATA FRAME COLUMN TO CHANGE)` です。ここで、最初の引数は目的の順序（単一ベクトル、またはこの例ではデータフレームの列）、および2番目の引数は、並べ替えられるデータフレームのデータフレーム列です。`match()` のアウトプットのはは、正しい位置の順序を表す数値のベクトルです。 `?match` で詳細を読むことができます。

```{r}
match(case_info$hospital, contact_fu$hospital)
```

\\この数値ベクトルを使用して、データフレームを並べ替えることができます - [コンマの前の]{.ul}サブセットブラケット `[ ]` 内に配置します。**base** R のブラケット・サブセット構文は、\[R の基礎\] のページで詳しく説されています。以下のコマンドは、行が上記の数値ベクトルで順序付けられている古いデータフレームとして定義された新しいデータフレームを作成します。

```{r}
contact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital),]
```

```{r message=FALSE, echo=F}
DT::datatable(contact_fu_aligned, rownames = FALSE, options = list(pageLength = nrow(10)))
```

これで、正しい行順序でデータフレーム列を結合できます。 一部の列が重複しているため、`rename()` でクリーニングする必要があることに注意してください。`bind_rows()` について詳しくは[こちら](https://dplyr.tidyverse.org/reference/bind.html)をご覧ください。

```{r}
bind_cols(case_info, contact_fu)
```

`bind_cols` の**ベース** R の代替関数は `cbind()` であり、これで同じ操作が実行できます。

<!-- ======================================================= -->

## 資料

[Join に関する Tidyverse のページ](https://dplyr.tidyverse.org/reference/join.html)

[相関性データに関する R for Data Science のページ](https://r4ds.had.co.nz/relational-data.html)

[dplyr bind に関する Tidyverse のページ](https://dplyr.tidyverse.org/reference/bind.html)

[fastLink パッケージの コード例（Github）](https://github.com/kosukeimai/fastLink)

[fastLink についての論文](https://imai.fas.harvard.edu/research/files/linkage.pdf)

[RecordLinkage package についての論文](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

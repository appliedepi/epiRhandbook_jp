
# 文字と文字列 { }  

#```{r, out.width=c('100%'), echo=F, message=F}
#knitr::include_graphics(here::here("images", "Characters_Strings_1500x500.png"))
#```



このページでは **stringr** パッケージを使用して、文字（character）と文字列（string）を評価し、処理する方法を紹介します。  

1. 結合、並べ替え、分割 - `str_c()`, `str_glue()`, `str_order()`, `str_split()`  
2. 整理と標準化  
    * 長さの調整 - `str_pad()`, `str_trunc()`, `str_wrap()`  
    * 大文字小文字の変更 - `str_to_upper()`, `str_to_title()`, `str_to_lower()`, `str_to_sentence()`  
3. 位置による評価と抽出 - `str_length()`, `str_sub()`, `word()`  
4. パターン認識  
    * 検出と検索 - `str_detect()`, `str_subset()`, `str_match()`, `str_extract()`  
    * 修正と置換 - `str_sub()`, `str_replace_all()`  
7. 正規表現（"regex"）


表示を簡単にするためほとんどの例で短い文字ベクトルを用いていますが、それらの内容はデータフレーム内の列にも簡単に適用できます。

このページを作成するにあたり、この [stringr のビネット](
https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)が大変参考になりました。



<!-- ======================================================= -->
## 準備 { }

### パッケージの読み込み {.unnumbered}  

**stringr** およびその他の **tidyverse** パッケージをインストールまたは読み込みます。  

```{r}
# パッケージのインストール/読み込み
pacman::p_load(
  stringr,    # many functions for handling strings
  tidyverse,  # for optional data manipulation
  tools)      # alternative for converting to title case

```


### データの読み込み  {.unnumbered}  


このページでは、エボラ出血熱のシミュレーションから得られた症例の整理された `linelist` を参照することがあります。 それらに沿って作業をしたい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>こちらから</a>ラインリストをダウンロードしてください（.rdsファイル）。ダウンロードしたファイルは **rio** パッケージの`import()` を使って取り込むことができます（.xlsx、.csv、.rdsなど、さまざまなファイルタイプを扱うことができます。詳細は [インポートとエクスポート] のページを参照してください）。 

```{r, echo=F}
# 症例ラインリストの読み込み
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# 症例ラインリストの読み込み 
linelist <- import("linelist_cleaned.rds")
```

ラインリストの最初の50行が以下に表示されます。

```{r, message=FALSE, echo=F}
# ラインリストのデータをテーブルで表示
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




<!-- ======================================================= -->
## 結合、分割、配列 { }


このセクションでは以下の事柄を扱います:  

* `str_c()`、`str_glue()`、`unite()` を使った文字列の結合  
* `str_order()` を使った文字列の並べ替え  
* `str_split()` と `separate()` 文字列の分割  



<!-- ======================================================= -->
### 文字列の結合 {.unnumbered}

複数の文字列を1つの文字列に結合するには、**stringr** の `str_c` を使うことをお勧めします。結合するそれぞれの文字列はカンマで区切って指定します。     

```{r}
str_c("String1", "String2", "String3")
```

引数 `sep = ` は、与えられた各引数の間に文字値を挿入します（例：カンマ、スペース、改行 `"\n"` の挿入）。

```{r}
str_c("String1", "String2", "String3", sep = ", ")
```

引数 `collapse = ` は `str_c()` に複数の値をを*ベクター*で入力する場合に使用します。これは、*出力*ベクターの要素を区切るために使用され、出力ベクターが1つの長い文字列のみを要素として持つようにします。

以下の例では、2つのベクトルを1つにまとめています（姓と名）。また、似たような例として、管轄区域とその症例数があります。この例では

* 姓と名の間に `sep = ` で指定した値が表示されます  
* 各姓名の間に `collapse = ` で指定した値が表示されます  


```{r}
first_names <- c("abdul", "fahruk", "janice") 
last_names  <- c("hussein", "akinleye", "okeke")

# sep は入力された文字列（ここでは姓と名）を繋ぐ際間に挿入される文字（列）を指定し、collapse は繋がれた文字列同士（ここでは姓名）の間に挿入有される文字（列）を指定します。
str_c(first_names, last_names, sep = " ", collapse = ";  ")
```

注：目的の表示形式により、例えばこのように結合された文字列を改行付きで表示したい場合など、正しく表示されるようにフレーズ全体を `cat()` で囲む必要がある場合があります：

```{r}
# 改行を正しく表示するためにフレーズ全体を cat() で囲む
cat(str_c(first_names, last_names, sep = " ", collapse = ";\n"))
```



<!-- ======================================================= -->
### 動的文字列 {.unnumbered}

`str_glue()` を使うと、文字列に動的なRコードを挿入することができます。これは、以下のように、動的なプロットキャプションを作成するのに非常に便利な関数です。 

* すべての内容は二重引用符で囲まれます：`str_glue("")`  
* 動的なコードやあらかじめ定義された値への参照は、二重引用符の中の中括弧 `{}` に入力します。1つの `str_glue()` コマンド中に複数の中括弧を入れることができます。 
* 文字としての引用符 ''　を表示するには、二重引用符の中に*一重*引用符を使用します（例：日付の書式を指定する場合など。以下の例を参照）。  
* ヒント：`\n` で強制的に改行することができます。  
* ヒント：`format()` で日付の表示を調整し、`Sys.Date()` で現在の日付を表示することができます。

動的なプロットキャプションの簡単な例を示します:  

```{r}
str_glue("Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.")
```

もうひとつの方法は、以下のように中括弧内にプレースホルダー（仮置きされた変数）を置き、`str_glue()` の最後にそれらを定義する方法です。これにより、テキストが長い場合でもコードを読みやすくすることができます。

```{r}
str_glue("Linelist as of {current_date}.\nLast case hospitalized on {last_hospital}.\n{n_missing_onset} cases are missing date of onset and not shown",
         current_date = format(Sys.Date(), '%d %b %Y'),
         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),
         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))
         )

```


**データフレームからの引き出し**  

データフレームからデータを取り出して、文字列としてまとめておくと便利な場合があります。以下にデータフレームの例を示します。これを使って、管轄区域、新規および総症例数についての要約文を作成します。

```{r}
# 症例データフレームの作成
case_table <- data.frame(
  zone        = c("Zone 1", "Zone 2", "Zone 3", "Zone 4", "Zone 5"),
  new_cases   = c(3, 0, 7, 0, 15),
  total_cases = c(40, 4, 25, 10, 103)
  )
```

```{r, echo=F}
DT::datatable(case_table, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

`str_glue_data()` を使用することで、データフレームの各行から取り出した情報を文字列にまとめることができます：  

```{r}
case_table %>% 
  str_glue_data("{zone}: {new_cases} ({total_cases} total cases)")
```


**異なる行の文字列を結合する**  

複数の行の値を結合して1つの行にまとめる場合など、データフレームの値を列に沿って結合したい際は、[De-duplication](#de-duplication) 内の ["rolling-up" values](#str_rollup) のページを参照してください。 

**データフレームを1行の文字列にまとめる**  

`str_c()` でデータフレーム名と列名を指定し、`sep = ` と `collapse = ` の引数を与えることで、データフレーム内の情報を一行に表示させることができます。  

```{r}
str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  ")
```

もう1つの `str_c()` でこの `str_c()` を包むことで、文の先頭に文字列 "New Cases:" を追加することができます（「New Cases: 」が元のstr_c()内にあった場合、複数回表示されます）。

```{r}
str_c("New Cases: ", str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  "))
```





### 列の結合  {#str_unite .unnumbered}

データフレーム中の複数の列を文字列にまとめるには、**tidyr** パッケージの `unite()` を用います。これは `separate()` の逆の操作にあたります。

まず新しい統合された列の名前を指定します。次に、結合したい列の名前を指定します。

* 初期設定ではアンダースコア `_` によって各列の値が結合されますが、これは `sep = ` によって変更できます。  
* `remove = ` は入力に用いた列をデータフレームから削除します（初期設定ではTRUE）。
* `na.rm = ` は結合時に欠測値を取り除きます（初期設定ではFALSE）。

以下に、デモ用のミニデータフレームを定義します:  

```{r, message = F, warning=F}
df <- data.frame(
  case_ID = c(1:6),
  symptoms  = c("jaundice, fever, chills",     # patient 1
                "chills, aches, pains",        # patient 2 
                "fever",                       # patient 3
                "vomiting, diarrhoea",         # patient 4
                "bleeding from gums, fever",   # patient 5
                "rapid pulse, headache"),      # patient 6
  outcome = c("Recover", "Death", "Death", "Recover", "Recover", "Recover"))
```


```{r}
df_split <- separate(df, symptoms, into = c("sym_1", "sym_2", "sym_3"), extra = "merge")
```

ここで作られたデータフレームはこのようになります：

```{r, echo=F}
DT::datatable(df_split, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

B以下に、3つの症状の列を統一します：  

```{r}
df_split %>% 
  unite(
    col = "all_symptoms",         # 新しく作られる列の名前
    c("sym_1", "sym_2", "sym_3"), # 結合する列
    sep = ", ",                   # 区切りに使われる結合子
    remove = TRUE,                # TRUEの場合、結合元の列をデータフレームから削除します。
    na.rm = TRUE                  # TRUEの場合、欠測値を無視して結合します。
  )
```







<!-- ======================================================= -->
### 分割 {.unnumbered}  

パターンに基づいて文字列を分割するには、`str_split()`を使います。文字（列）を評価し、新たに分割された値からなる文字ベクターの `list` を返します。

以下の簡単な例では，1つの文字列を3つに分割しています．初期設定では、最初に与えられた文字列ごとに1つの要素（文字ベクター）を持つ `list` を返します。`simplify = TRUE` の場合は、文字行列を返します。

この例では、1つの文字列が与えられ、この関数は1つの要素を持つリスト - つまり3つの値を持つ文字ベクターを返します。 

```{r}
str_split(string = "jaundice, fever, chills",
          pattern = ",")
```

出力が保存されていれば、大括弧を使ってn番目の値にアクセスできます。特定の値にアクセスするには、次のような構文を使用できます：`the_returned_object[[1]][2]`。この例では、最初に評価された文字列（"fever"）から2番目の値にアクセスします。要素へのアクセスの詳細については、[R の基礎](#basics) のページを参照してください。

```{r}
pt1_symptoms <- str_split("jaundice, fever, chills", ",")

pt1_symptoms[[1]][2]  # リスト内の1つ目（かつここでは唯一）の要素内にある2つ目の値を返す
```

`str_split()` で複数の文字列を指定した場合、返されるリストには複数の要素が含まれます。

```{r}
symptoms <- c("jaundice, fever, chills",     # 患者 1
              "chills, aches, pains",        # 患者 2 
              "fever",                       # 患者 3
              "vomiting, diarrhoea",         # 患者 4
              "bleeding from gums, fever",   # 患者 5
              "rapid pulse, headache")       # 患者 6

str_split(symptoms, ",")                     # 各患者の症状を分割する
```


データフレームの列を作成したい場合、次のように `simplify = TRUE` を設定することで文字行列を出力すると便利です：

```{r}
str_split(symptoms, ",", simplify = TRUE)
```

また `n = ` を使って、分割する数を調整することもできます。例えば以下の例は分割数を2に制限するもので、それ以上のカンマは2番目の値の中に残ります。

```{r}
str_split(symptoms, ",", simplify = TRUE, n = 2)
```

*注 - `str_split_fixed()` でも同じ出力が得られますが、その場合は `simplify` 引数を与えず、代わりに列数（`n`）を指定しなければなりません。* 

```{r, eval=F}
str_split_fixed(symptoms, ",", n = 2)
```




### 列の分割 {.unnumbered}  

データフレームの列を分割する場合は、**dplyr** パッケージの `separate()` 関数が最適です。この関数は、文字列を要素に持つ 1 つの列を複数の列に分割することができます。

例えば、以前に[結合](#str_unite)の節で定義した簡単なデータフレーム `df` を見てみましょう。このデータフレームは `case_ID` の列、多くの症状をまとめた文字列からなる列、そして予後を示す列を含んでいます。我々のここでの目的は、`symptoms` 列を複数の列に分割し、各列が単一の症状を示すようにすることです。

```{r, echo=F}
DT::datatable(df, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

データを `separate()` で処理したい場合、まず分離する列を指定します。次に、以下のように新しい列名を含むベクター `c()` によって `into = ` を指定します。

* `sep = ` 分割する位置を、文字または数字で指定します。
* `remove = ` 初期設定ではFALSE。入力された列を削除します。  
* `convert = ` 初期設定ではFALSE。文字列 "NA"を NAに変換します。
* `extra = ` 分離によって作成された値の数が、指定された新規列の名前よりも多い場合の動作を制御します。
     * `extra = "warn"` は、警告を表示しますが、過剰な値は削除されます（**初期設定**）。
     * `extra = "drop"` は、警告を表示せずに余分な値を削除します。
     * **`extra = "merge"` は、`into = `で指定された新しい列の数だけ分割します。- *この設定では全ての入力データが保存されます。***  


`extra = "merge"` を使用した例を以下に示します - ここではデータは失われません。2つの新しい列が定義され、3つ目の症状は2つ目の列に残されます：  

```{r}
# 3 つ目の症状は 2 つ目の新しい列に組み込まれる
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",", extra = "merge")
```

初期設定の `extra = "drop"` では ≈、警告が表示されます：

```{r}
# 3番目の症状は失われる
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",")
```


<span style="color: orange;">**注意：** `into = `に入力された値の数が不足していると、データが切り捨てられる可能性があります。</span>  






<!-- ======================================================= -->
### アルファベット順に並べる {.unnumbered} 

複数の文字列をアルファベット順に並べることができます。 `str_order()` は順序を返し、`str_sort()` はその順序に並べ替えた文字列を返します。

```{r}
# 文字列の定義
health_zones <- c("Alba", "Takota", "Delta")

# アルファベット順を返す
str_order(health_zones)

# アルファベット順に並び替える
str_sort(health_zones)
```

異なるアルファベットを使用するには、引数 `locale = `を追加します。R コンソールで `stringi::stri_locale_list()` と入力することで、指定可能なアルファベットの一覧を表示することができます。





<!-- ======================================================= -->
### R の基本関数 {.unnumbered}

R の **base** （基本）関数である `paste()` や `paste0()` は、与えられたベクターのすべての要素を文字に変換した後、連結して1つの文字列を返すためにしばしば使われます。これらの関数は `str_c()` と似ていますが、構文はより複雑で、括弧の中では各部分がカンマで区切られています。各パーツは引用符で囲まれた文字テキストまたは既に定義されたコードオブジェクト（引用符なし）です。例えば、以下のようになります：

```{r}
n_beds <- 10
n_masks <- 20

paste0("Regional hospital needs ", n_beds, " beds and ", n_masks, " masks.")
```

`sep = ` と `collapse = ` の引数を指定できます。`paste()` は `sep = " "` （半角スペース）を初期設定に持つ `paste0()` と同値です。






## 整理と標準化


<!-- ======================================================= -->
### 大文字小文字の変更 {.unnumbered}

しばしば、管轄区域の名称などで大文字小文字を変更する必要に迫られることがあります。その際は以下のように、**stringr** に含まれる `str_to_upper()`、`str_to_lower()`、`str_to_title()` を用います：

```{r}
str_to_upper("California")

str_to_lower("California")
```

Rの **base** 関数である `toupper()`,`tolower()` を用いることでも上記と同じ処理が可能です。


**タイトルケース**  

各単語の語頭を大文字にするには `str_to_title()` を用います：  

```{r}
str_to_title("go to the US state of california ")
```

**tools** パッケージの `toTitleCase()` を使うことで、より厳密なタイトルケース（"to", "the", "of" といった単語は大文字化されません）に変更することができます。

```{r}
tools::toTitleCase("This is the US state of california")
```

`str_to_sentence()` を使えば、文字列の最初の文字のみを大文字化することができます。

```{r}
str_to_sentence("the patient must be transported")
```



### 文字列を伸長する  {#str_pad .unnumbered}

`str_pad()` を用いると、文字列に特定の文字を足すことで、指定した最小の長さまで文字列を伸ばすことができます。初期設定では空白が追加されますが、`pad = `によって他の文字を指定することも可能です。


```{r}
# ICD codes of differing length
ICD_codes <- c("R10.13",
               "R10.819",
               "R17")

# ICD codes padded to 7 characters on the right side
str_pad(ICD_codes, 7, "right")

# Pad with periods instead of spaces
str_pad(ICD_codes, 7, "right", pad = ".")
```

例えば、`pad = "0"` により先頭に 0 を足すことで、時間や分のように数字からなる文字列の長さが少なくとも 2 になるように処理することができます。

```{r}
# 先頭に 0 を足して 2 桁にする(例：時間・分の表示)
str_pad("4", 2, pad = "0") 

# "hours" という名前の数字列を作る場合
# hours <- str_pad(hours, 2, pad = "0")
```


### 文字数を短縮する {.unnumbered} 

`str_trunc()` で文字列の長さの最大値を設定できます。与えられた文字列の長さが指定した最大値を超える場合、その文字列は短縮され、省略記号（...）が挿入されます。このとき、省略記号は文字数にカウントされることに注意してください。使用される省略記号は `ellipsis = `で指定することができます。また `side = ` によって、省略記号がどこに挿入されるか（“left”、 “right”、 “center”）を指定することができます。

```{r}
original <- "Symptom onset on 4/3/2020 with vomiting"
str_trunc(original, 10, "center")
```


### 長さの標準化 {.unnumbered}

文字列の長さの最大値を `str_trunc()` で指定し、さらに `str_pad()` を用いて短い文字列をその長さまで伸長することができます。以下の例では、最大値を 6 に設定し（ 1 つの文字列が短縮されます）、続いて 1 つの短い文字列がその長さまで伸長されます。  

```{r}
# 異なる長さのICDコード
ICD_codes   <- c("R10.13",
                 "R10.819",
                 "R17")

# 最大の長さが 6 になるよう文字列を短縮
ICD_codes_2 <- str_trunc(ICD_codes, 6)
ICD_codes_2

# 最小の長さが 6 になるよう文字列を伸長
ICD_codes_3 <- str_pad(ICD_codes_2, 6, "right")
ICD_codes_3
```


### 先頭・末尾の空白を削除する {.unnumbered}  

`str_trim()` を用いて文字列の端にある空白、改行（`\n`）、タブ （`\t`）を削除できます。`"right"`、`"left"`、または `"both"` を指定することにより、どちらの端から削除するかを選択することができます（例：`str_trim(x, "right")`）。

```{r}
# 右端に余分な空白を持つID
IDs <- c("provA_1852  ", # 2 つの余分な空白
         "provA_2345",   # 余分な空白なし
         "provA_9460 ")  # 1 つの余分な空白

# 右端から空白を削除
str_trim(IDs)
```


### 繰り返される空白の削除 {.unnumbered}  

`str_squish()` を用いて文字列の内部に連続して現れる空白を作事できます。例えば、2 つ続きになっている空白を単一の空白に変更できます。`str_trim()` と同様、文字列の端にある空白、改行、タブを削除することもできます。


```{r}
# 元の文字列は内部に余分な空白を含む
str_squish("  Pt requires   IV saline\n") 
```

R コンソールに `?str_trim`、`?str_pad` と入力することで詳細を参照できます。


### 指定の文字数で文章を改行する {.unnumbered}  

`str_wrap()` を用いることで、長い文章を指定した文字数で改行し整理することができます。任意の文字数を指定すれば、アルゴリズムにより以下のように文章中に改行（`\n`）が挿入されます。

```{r}
pt_course <- "Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020."

str_wrap(pt_course, 40)
```

**base** 関数である `cat()` に上記のコマンドを入力することで、改行された文章を表示することができます。

```{r}
cat(str_wrap(pt_course, 40))
```












<!-- ======================================================= -->
## 位置による操作 { }


### 位置を指定して文字を抽出する {.unnumbered}  

`str_sub()` は文字列の一部を返します。この関数は3つの引数を取ります：

1) 文字ベクター
2) 開始位置
3) 終了位置

位置を定義する際にいくつかの注意点があります：

* 位置数が正のとき、位置は文字列の左端からカウントされます。
* 位置数が負のとき、位置は文字列の右端からカウントされます。
* 開始・終了位置は選択範囲に含まれます。
* 文字列の長さを超えて選択された範囲は無視されます。

以下に文字列 "pneumonia" を用いた例を示します：

```{r}
# 左から 3 文字目を開始および終了位置に設定
str_sub("pneumonia", 3, 3)

# 位置 0 は存在しません
str_sub("pneumonia", 0, 0)

# 左から 6 文字目を開始位置、右から 1 文字目を終了位置に設定
str_sub("pneumonia", 6, -1)

# 右から 5 文字目を開始位置、右から 2 文字目を終了位置に設定
str_sub("pneumonia", -5, -2)

# 左から 4 文字目を開始位置、文字列の長さを超えた位置を終了位置に設定
str_sub("pneumonia", 4, 15)
```



### 位置を指定して単語を抽出する {.unnumbered} 

n番目の '単語' を抽出するには、**stringr** パッケージから `word()` を用います。文字列、開始位置、終了位置を引数に取ります。

初期設定では空白で区切られた部分が単語と認識されます。区切りは `sep = ` で変更でき、例えば `sep = "_"` と指定すると下線で区切られた部分が単語と認識されます。


```{r}
# 評価したい文字列
chief_complaints <- c("I just got out of the hospital 2 days ago, but still can barely breathe.",
                      "My stomach hurts",
                      "Severe ear pain")

# 1 から 3 番目の単語を抽出
word(chief_complaints, start = 1, end = 3, sep = " ")
```


### 位置を指定して文字を入れ替える {.unnumbered} 

`str_sub()` と代入演算子（`<-`）を組み合わせて文字列の一部を変更できます：

```{r}
word <- "pneumonia"

# 3 番目と 4 番目の文字を X に変更する
str_sub(word, 3, 4) <- "XX"

# 結果を表示
word
```

データフレームの行など、複数の文字列に対して用いる場合の例を示します。"HIV" の例では文字列が長くなることに注意してください。  

```{r}
words <- c("pneumonia", "tubercolosis", "HIV")

# 3 番目と 4 番目の文字を X に変更する
str_sub(words, 3, 4) <- "XX"

words
```



### 長さを評価する  {.unnumbered}


```{r}
str_length("abc")
```

**base** 関数 `nchar()` でも同等の操作が可能です。







<!-- ======================================================= -->
## パターン { }

**stringr** に含まれる関数の多くは、与えられた文字列から特定の*パターン*を見つけ、その位置を特定したり、抽出・入れ替えなどの操作を行うことができます。  



<!-- ======================================================= -->
### パターンを見つける {.unnumbered}

以下の例のように `str_detect()` を使うことで、文字列中に特定のパターンが存在するか否かを判別することができます。初めに検索する文字列を与え（`string = `）、さらに探したいパターンを入力します（`pattern = `）。 初期設定では*大文字小文字が区別される*ことに注意してください！

```{r}
str_detect(string = "primary school teacher", pattern = "teach")
```

引数 `negate = `を `TRUE` に設定することで、パターンが存在 "しない" かどうかを判定できます。
 
```{r}
str_detect(string = "primary school teacher", pattern = "teach", negate = TRUE)
```

大文字小文字を無視したい場合は、パターンを `regex()` で包み、`regex()` *中に* `ignore_case = TRUE`（もしくは短く `T`）と指定します。 

```{r}
str_detect(string = "Teacher", pattern = regex("teach", ignore_case = T))
```

`str_detect()` で検索する文字列が文字ベクターやデータフレームの列である場合は、各要素に関して `TRUE` または `FALSE` を返します。

```{r}
# 職業のベクター/列
occupations <- c("field laborer",
                 "university professor",
                 "primary school teacher & tutor",
                 "tutor",
                 "nurse at regional hospital",
                 "lineworker at Amberdeen Fish Factory",
                 "physican",
                 "cardiologist",
                 "office worker",
                 "food service")

# 各文字列中に "teach" が含まれるかを判別する - TRUE/FALSE が出力される
str_detect(occupations, "teach")
```

`TRUE` がいくつあるかを数えたい場合は、出力された値を `sum()` に入力します。

```{r}
sum(str_detect(occupations, "teach"))
```

複数のパターンを探したい時は、以下のように各パターンを OR 記号で区切り（`|`）、`pattern = `で指定します：

```{r}
sum(str_detect(string = occupations, pattern = "teach|professor|tutor"))
```

より多くのパターンを同時に探したいときは、 `str_c()` と `sep = |` を組み合わせた出力を文字オブジェクトとして定義し用いることで、コードをより簡潔にすることができます。以下の例では、医療従事者の職業リストをパターンとして検索します。

```{r}
# 検索するパターン
occupation_med_frontline <- str_c("medical", "medicine", "hcw", "healthcare", "home care", "home health",
                                "surgeon", "doctor", "doc", "physician", "surgery", "peds", "pediatrician",
                               "intensivist", "cardiologist", "coroner", "nurse", "nursing", "rn", "lpn",
                               "cna", "pa", "physician assistant", "mental health",
                               "emergency department technician", "resp therapist", "respiratory",
                                "phlebotomist", "pharmacy", "pharmacist", "hospital", "snf", "rehabilitation",
                               "rehab", "activity", "elderly", "subacute", "sub acute",
                                "clinic", "post acute", "therapist", "extended care",
                                "dental", "dential", "dentist", sep = "|")

occupation_med_frontline
```

以下の例では、先に定義した職業リストの中に含まれる医療職（`occupation_med_frontline`）の数を返します：

```{r}
sum(str_detect(string = occupations, pattern = occupation_med_frontline))
```



**文字列検索のための基本 R 関数**  

**base** 関数 `grepl()` は `str_detect()` と同様、パターンの有無を判定し論理ベクターを返します。, 基本構文は `grepl(pattern, strings_to_search, ignore.case = FALSE, ...)` です。利点の１つとして、`regex()` を使う代わりに `ignore.case = `を指定するだけで大文字小文字を区別するかを変更することができます。

同様に、**base** 関数 `sub()` と `gsub()` は `str_replace()` に近い働きをします。 基本構文は `gsub(pattern, replacement, strings_to_search, ignore.case = FALSE)` です。`sub()` は一致したパターンのうち最初に現れるものだけを、`gsub()` は一致したパターンの全てを入れ替えます。


#### カンマをピリオドに入れ替える {.unnumbered}  

以下に `gsub()` を用いてカンマをピリオドに入れ替える例を示します。これは米国や英国以外で得られたデータを扱う際に役に立つかもしれません。

内部の `gsub()` は `lengths` 内のピリオドを "" に入れ替えます。ピリオド "." をパターンとして指定する際は、その前に2つバックスラッシュを置くことで "エスケープ" する必要があります。これは正規表現において "." が "全ての文字" を意味するためです。 ここで得られた出力（ピリオドは削除されカンマのみを含む）は外側の `gsub()` に渡され、カンマがピリオドに置き換わります。   

```{r, eval=F}
lengths <- c("2.454,56", "1,2", "6.096,5")

as.numeric(gsub(pattern = ",",                # カンマを見つける
                replacement = ".",            # ピリオドに入れ替える
                x = gsub("\\.", "", lengths)  # ピリオド（エスケープして指定）を削除する
                )
           )                                  # 出力を数字ベクターに変更
```





### 全て入れ替える {.unnumbered}  

`str_replace_all()` は "検索と置換" ツールとして使用できます。検索する文字列、パターン、置き換える値をそれぞれ `string = `、`pattern = `、`replacement = `で指定します。 以下の例では全ての "dead" を "deceased" に入れ替えます。大文字小文字が区別されることに注意してください。

```{r}
outcome <- c("Karl: dead",
            "Samantha: dead",
            "Marco: not dead")

str_replace_all(string = outcome, pattern = "dead", replacement = "deceased")
```

注：  

* パターンを `NA` で置き換えるには `str_replace_na()` を用います。
* `str_replace()` は与えられた各文字列中に現れる最初のパターンだけを入れ替えます。





<!-- ======================================================= -->
### パターンの有無による条件分岐 {.unnumbered}


**`case_when()` との組み合わせ**  

`str_detect()` はしばしば **dplyr** パッケージの `case_when()` と組み合わせて用いられます。例として、`occupations` がラインリスト内の列であるとします。以下の `mutate()` は `case_when()` による条件分岐に従って新しい列 `is_educator` を作ります。`case_when()` についての詳細はデータクリーニングのページを参照してください。


```{r, eval=F}
df <- df %>% 
  mutate(is_educator = case_when(
    # occupation内でパターン検索。大文字小文字は区別しない。
    str_detect(occupations,
               regex("teach|prof|tutor|university",
                     ignore_case = TRUE))              ~ "Educator",
    # その他全て
    TRUE                                               ~ "Not an educator"))
```

`negate = F` を用いて除外したいパターンを指定できることも覚えておきましょう： 

```{r, eval=F}
df <- df %>% 
  # 新しい列 is_educator の値を条件分岐により決定する
  mutate(is_educator = case_when(
    
    # "Educator"の値を取るためには 2 つの基準を満たす必要がある：
    # 指定されたパターンを持ち、かつ除外されたパターンを持たない

    # 指定されたパターンを持つ
    str_detect(occupations,
               regex("teach|prof|tutor|university", ignore_case = T)) &
    
    # 除外されたパターンを持たない
    str_detect(occupations,
               regex("admin", ignore_case = T),
               negate = TRUE                        ~ "Educator"
    
    # 上記の条件を満たさない全ての行
    TRUE                                            ~ "Not an educator"))
```





<!-- ======================================================= -->
### パターンの位置を特定する {.unnumbered}  

指定したパターンが与えられた文字列中に*最初に*現れる位置を特定するためには、`str_locate()` を用います。パターンの最初と最後の文字の位置を返します。

```{r}
str_locate("I wish", "sh")
```

その他の `str` 関数と同様、`str_locate()` にも "_all" バージョンが存在します（`str_locate_all()`）。与えられた各文字列中に現れるパターンの全ての位置を `list` 形式で返します。

```{r}
phrases <- c("I wish", "I hope", "he hopes", "He hopes")

str_locate(phrases, "h" )     # *最初に*現れるパターンの位置
str_locate_all(phrases, "h" ) # *全ての*パターンの位置
```





<!-- ======================================================= -->
### 一致したパターンを抽出する {.unnumbered}  

`str_extract_all()` はマッチしたパターンそのものを返します。これは "OR" を用いて複数のパターンを検索したときに特に有用です。例えば、職業の文字列リスト（前節を参照）内に "teach"、"prof"、"tutor" の*いずれか*のパターンを探すことを考えます。

`str_extract_all()` 与えられた文字列内の一致するパターン全ての `list` を返します。以下の例で 3 つ目の文字列において 2 つのパターンが一致していることに注目してください。

```{r}
str_extract_all(occupations, "teach|prof|tutor")
```


`str_extract()` は*最初に一致したパターンのみ*を返します。従って、出力は与えられた各文字列に対して 1 つのパターンを文字ベクターで返します。 一致するパターンがない場合は `NA` を返します。この `NA` は `str_extract` を `na.exclude()` で包むことで消去できます。3 つ目の文字列の 2 つ目の一致パターンが表示されないことに注意してください。 

```{r}
str_extract(occupations, "teach|prof|tutor")
```

<!-- ======================================================= -->
### サブセットと数え上げ {.unnumbered}  

ここでは `str_subset()` と `str_count()` を扱います。

`str_subset()` は一致したパターンだけでなく、そのパターンを含む文字列全体を返します：

```{r}
str_subset(occupations, "teach|prof|tutor")
```

`str_count()` は検索した文字列中に指定したパターンが現れる**合計回数**をベクターで返します。  

```{r}
str_count(occupations, regex("teach|prof|tutor", ignore_case = TRUE))
```












<!-- ======================================================= -->
### 正規表現グループ {.unnumbered}

作成中






<!-- ======================================================= -->
## 特殊文字

**バックスラッシュ `\` によるエスケープ**  

バックスラッシュ `\` はその直後に現れる文字の意味を "エスケープ" するために使われます。例えば、引用符の前にバックスラッシュを置くことで（`\"`）引用符を別の 2 つの引用符の*間に*表示することができます。その際、間に挟まれる引用符はそれを囲む引用符とは干渉しません。

注: バックスラッシュを*文字として表示したい*場合は、その前に*もう 1 つの*バックスラッシュを置いて、エスケープ記号としての役割を回避する必要があります。つまり、`\\` と書くことでバックスラッシュ 1 つを表示できます。

**特殊文字の例**  

特殊文字 | 意味  
----------------- | --------------------------------------------------------------    
`"\\"` | バックスラッシュ  
`"\n"` | 改行 
`"\""` | *二重引用符中での*二重引用符の表示  
`'\''` | *一重引用符中での*一重引用符の表示  
`"\`"` | アクサングラーヴ  
`"\r"` | キャリッジリターン
`"\t"` | タブ  
`"\v"` | バーティカルタブ
`"\b"` | バックスペース  


`?"'"` コマンドを R コンソール中で使うと、これらの特殊文字の一覧が表示できます（RStudio ではヘルプ画面に表示されます）。



<!-- ======================================================= -->
## 正規表現 (regex) 


<!-- ======================================================= -->
## 正規表現と特殊文字 { } 

正規表現（または regex）とは、文字列パターンを記述するために用いられる言語規則のことです。馴染みがない人にとっては、まるで他の星の言葉のように映るかもしれません。ここでは、その正規表現に対するハードルを少し下げることを目標にします。

*この節で扱う内容の大部分は[こちらのチュートリアル](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432)と[こちらのチートシート](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)から取られています。*ここでは、このハンドブックがインターネットへのアクセスが無く他のチュートリアルを見れない方からも利用されうることを念頭に、これら参考文献から内容を選んで参考にしています。


正規表現は*決まった構造を持たない*文章 - たとえば診療録、主訴、既往歴やデータフレーム中の文字列など - から特定のパターンを抜き出すためにしばしば使われます。

正規表現を構築するために使われる基本ツールが 4 つあります：

1) 文字セット
2) メタ文字
3) 数量詞  
4) グループ  


**文字セット**  

文字セットは大括弧を用いて文字のリストを表現します。大括弧中に含まれる文字のいずれかが対象の文字列中に含まれる場合、一致パターンとして扱われます。例えば、母音のいずれかを検索したい場合 "[aeiou]" と表現できます。以下にその他のしばしば使われる文字セットを示します： 

文字セット | 検索される文字
----------------- | --------------------------------------------------------------    
`"[A-Z]"` | 全ての大文字アルファベット
`"[a-z]"` | 全ての小文字アルファベット 
`"[0-9]"` | 全ての数字 
`[:alnum:]` | 全てのアルファベットおよび数字
`[:digit:]` | 全ての数字
`[:alpha:]` | 全ての大文字および小文字アルファベット
`[:upper:]` | 全ての大文字アルファベット
`[:lower:]` | 全ての小文字アルファベット


複数の文字セットを 1 つの大括弧中に（空白なしで！）組み合わせることができます。例えば `"[A-Za-z]"` は全ての大文字および小文字アルファベットを、`"[t-z0-5]"` は t から z までの小文字アルファベットと 0 から 5 までの数字を表します。



**メタ文字**  

メタ文字は文字セットの省略表記です。以下にいくつかの重要な例を示します：

メタ文字 | 検索される文字  
----------------- | --------------------------------------------------------------    
`"\\s"` | 1 つの空白  
`"\\w"` | 全てのアルファベットおよび数字（A-Z、a-z、または 0-9）  
`"\\d"` | 全ての数字（0-9）  


**数量詞**  

多くの場合、検索したいパターンは 2 つ以上の文字を含みます。数量詞により一致を探す文字や数字の長さを規定できます。

数量詞は数を指定したいパターンの*後に*中括弧 `{ }` を置き、その中に数字を書くことで定義されます。 例えば、

* `"A{2}"` は大文字 A **2 つ**を示します。  
* `"A{2,4}"` は **2 から 4 つの**大文字 A を示します（中括弧中に空白は置かれません！）。  
* `"A{2,}"` は **2 つ以上の**大文字Aを示します。
* `"A+"` は **1 つ以上の**大文字 A を示します（他の文字が現れるまで、連続した A は全てグループに含まれます）。
* アスタリスク `*` を前におくと **0 個以上の**という意味が付加されます（そのパターンが存在するか不確かなときに有用です）。


`+` シンボルを使うと、他の文字が出てくるまでの連続した同一の文字が全て一致するパターンとして扱われます。例えば、`"[A-Za-z]+"` という表現は全ての単語（アルファベットのみでできた文字列）に対応します。 


```{r}
# 数量詞をテストするための文字列
test <- "A-AA-AAA-AAAA"
```

数量詞 {2} を用いた場合、2 つ続きの A のみがマッチとして扱われます。`AAAA` からは 2 つのマッチが返されます。

```{r}
str_extract_all(test, "A{2}")
```

数量詞 {2,4} を用いた場合、2 つから 4 つ続きの A がマッチとして扱われます。

```{r}
str_extract_all(test, "A{2,4}")
```

数量詞 `+` を用いた場合、**1 つ以上の**連続した A がマッチとして扱われます：

```{r}
str_extract_all(test, "A+")
```

**相対的位置**  

These express requirements for what precedes or follows a pattern. For example, to extract sentences, "two numbers that are followed by a period" (`""`).  (?<=\\.)\\s(?=[A-Z]) 

```{r}
str_extract_all(test, "")
```

Position statement | Matches to  
----------------- | --------------------------------------------------------------    
`"(?<=b)a"` | "a" that **is preceded** by a "b"  
`"(?<!b)a"` | "a" that **is NOT preceded** by a "b"  
`"a(?=b)"` | "a" that **is followed** by a "b"  
`"a(?!b)"` | "a" that **is NOT followed** by a "b"  





**Groups**  

Capturing groups in your regular expression is a way to have a more organized output upon extraction.  




**Regex examples**  

Below is a free text for the examples. We will try to extract useful information from it using a regular expression search term.  

```{r}
pt_note <- "Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute."
```

This expression matches to all words (any character until hitting non-character such as a space):  

```{r}
str_extract_all(pt_note, "[A-Za-z]+")
```

The expression `"[0-9]{1,2}"` matches to consecutive numbers that are 1 or 2 digits in length. It could also be written `"\\d{1,2}"`, or `"[:digit:]{1,2}"`.  

```{r}
str_extract_all(pt_note, "[0-9]{1,2}")
```

<!-- This expression will extract all sentences (assuming first letter is capitalized, and the sentence ends with a period). The pattern reads in English as: "A capital letter followed by some lowercase letters, a space, some letters, a space,     -->

<!-- ```{r} -->
<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->
<!-- ``` -->


You can view a useful list of regex expressions and tips on page 2 of [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)  

Also see this [tutorial](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432).  




<!-- ======================================================= -->
## Resources { }

A reference sheet for **stringr** functions can be found [here](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)


A vignette on **stringr** can be found [here](
https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)




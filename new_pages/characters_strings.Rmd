
# 文字と文字列 { }  

#```{r, out.width=c('100%'), echo=F, message=F}
#knitr::include_graphics(here::here("images", "Characters_Strings_1500x500.png"))
#```



このページでは **stringr** パッケージを使用して、文字（character）と文字列（string）を評価し、処理する方法を紹介します。  

1. 結合、並べ替え、分割 - `str_c()`, `str_glue()`, `str_order()`, `str_split()`  
2. 整理と標準化  
    * 長さの調整 - `str_pad()`, `str_trunc()`, `str_wrap()`  
    * 大文字小文字の変更 - `str_to_upper()`, `str_to_title()`, `str_to_lower()`, `str_to_sentence()`  
3. 位置による評価と抽出 - `str_length()`, `str_sub()`, `word()`  
4. パターン認識  
    * 検出と検索 - `str_detect()`, `str_subset()`, `str_match()`, `str_extract()`  
    * 修正と置換 - `str_sub()`, `str_replace_all()`  
7. 正規表現（"regex"）


表示を簡単にするためほとんどの例で短い文字ベクトルを用いていますが、それらの内容はデータフレーム内の列にも簡単に適用できます。

このページを作成するにあたり、この [stringr のビネット](
https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)が大変参考になりました。



<!-- ======================================================= -->
## 準備 { }

### パッケージの読み込み {.unnumbered}  

**stringr** およびその他の **tidyverse** パッケージをインストールまたは読み込みます。  

```{r}
# パッケージのインストール/読み込み
pacman::p_load(
  stringr,    # many functions for handling strings
  tidyverse,  # for optional data manipulation
  tools)      # alternative for converting to title case

```


### データの読み込み  {.unnumbered}  


このページでは、エボラ出血熱のシミュレーションから得られた症例の整理された `linelist` を参照することがあります。 それらに沿って作業をしたい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>こちらから</a>ラインリストをダウンロードしてください（.rdsファイル）。ダウンロードしたファイルは **rio** パッケージの`import()` を使って取り込むことができます（.xlsx、.csv、.rdsなど、さまざまなファイルタイプを扱うことができます。詳細は [インポートとエクスポート] のページを参照してください）。 

```{r, echo=F}
# 症例ラインリストの読み込み
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# 症例ラインリストの読み込み 
linelist <- import("linelist_cleaned.rds")
```

ラインリストの最初の50行が以下に表示されます。

```{r, message=FALSE, echo=F}
# ラインリストのデータをテーブルで表示
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




<!-- ======================================================= -->
## 結合、分割、配列 { }


このセクションでは以下の事柄を扱います:  

* `str_c()`、`str_glue()`、`unite()` を使った文字列の結合  
* `str_order()` を使った文字列の並べ替え  
* `str_split()` と `separate()` 文字列の分割  



<!-- ======================================================= -->
### 文字列の結合 {.unnumbered}

複数の文字列を1つの文字列に結合するには、**stringr** の `str_c` を使うことをお勧めします。結合するそれぞれの文字列はカンマで区切って指定します。     

```{r}
str_c("String1", "String2", "String3")
```

引数 `sep = ` は、与えられた各引数の間に文字値を挿入します（例：カンマ、スペース、改行 `"\n"` の挿入）。

```{r}
str_c("String1", "String2", "String3", sep = ", ")
```

引数 `collapse = ` は `str_c()` に複数の値をを*ベクター*で入力する場合に使用します。これは、*出力*ベクターの要素を区切るために使用され、出力ベクターが1つの長い文字列のみを要素として持つようにします。

以下の例では、2つのベクトルを1つにまとめています（姓と名）。また、似たような例として、管轄区域とその症例数があります。この例では

* 姓と名の間に `sep = ` で指定した値が表示されます  
* 各姓名の間に `collapse = ` で指定した値が表示されます  


```{r}
first_names <- c("abdul", "fahruk", "janice") 
last_names  <- c("hussein", "akinleye", "okeke")

# sep は入力された文字列（ここでは姓と名）を繋ぐ際間に挿入される文字（列）を指定し、collapse は繋がれた文字列同士（ここでは姓名）の間に挿入有される文字（列）を指定します。
str_c(first_names, last_names, sep = " ", collapse = ";  ")
```

注：目的の表示形式により、例えばこのように結合された文字列を改行付きで表示したい場合など、正しく表示されるようにフレーズ全体を `cat()` で囲む必要がある場合があります：

```{r}
# 改行を正しく表示するためにフレーズ全体を cat() で囲む
cat(str_c(first_names, last_names, sep = " ", collapse = ";\n"))
```



<!-- ======================================================= -->
### 動的文字列 {.unnumbered}

`str_glue()` を使うと、文字列に動的なRコードを挿入することができます。これは、以下のように、動的なプロットキャプションを作成するのに非常に便利な関数です。 

* すべての内容は二重引用符で囲まれます：`str_glue("")`  
* 動的なコードやあらかじめ定義された値への参照は、二重引用符の中の中括弧 `{}` に入力します。1つの `str_glue()` コマンド中に複数の中括弧を入れることができます。 
* 文字としての引用符 ''　を表示するには、二重引用符の中に*一重*引用符を使用します（例：日付の書式を指定する場合など。以下の例を参照）。  
* ヒント：`\n` で強制的に改行することができます。  
* ヒント：`format()` で日付の表示を調整し、`Sys.Date()` で現在の日付を表示することができます。

動的なプロットキャプションの簡単な例を示します:  

```{r}
str_glue("Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.")
```

もうひとつの方法は、以下のように中括弧内にプレースホルダー（仮置きされた変数）を置き、`str_glue()` の最後にそれらを定義する方法です。これにより、テキストが長い場合でもコードを読みやすくすることができます。

```{r}
str_glue("Linelist as of {current_date}.\nLast case hospitalized on {last_hospital}.\n{n_missing_onset} cases are missing date of onset and not shown",
         current_date = format(Sys.Date(), '%d %b %Y'),
         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),
         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))
         )

```


**データフレームからの引き出し**  

データフレームからデータを取り出して、文字列としてまとめておくと便利な場合があります。以下にデータフレームの例を示します。これを使って、管轄区域、新規および総症例数についての要約文を作成します。

```{r}
# 症例データフレームの作成
case_table <- data.frame(
  zone        = c("Zone 1", "Zone 2", "Zone 3", "Zone 4", "Zone 5"),
  new_cases   = c(3, 0, 7, 0, 15),
  total_cases = c(40, 4, 25, 10, 103)
  )
```

```{r, echo=F}
DT::datatable(case_table, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

`str_glue_data()` を使用することで、データフレームの各行から取り出した情報を文字列にまとめることができます：  

```{r}
case_table %>% 
  str_glue_data("{zone}: {new_cases} ({total_cases} total cases)")
```


**異なる行の文字列を結合する**  

複数の行の値を結合して1つの行にまとめる場合など、データフレームの値を列に沿って結合したい際は、[De-duplication](#de-duplication) 内の ["rolling-up" values](#str_rollup) のページを参照してください。 

**データフレームを1行の文字列にまとめる**  

`str_c()` でデータフレーム名と列名を指定し、`sep = ` と `collapse = ` の引数を与えることで、データフレーム内の情報を一行に表示させることができます。  

```{r}
str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  ")
```

もう1つの `str_c()` でこの `str_c()` を包むことで、文の先頭に文字列 "New Cases:" を追加することができます（「New Cases: 」が元のstr_c()内にあった場合、複数回表示されます）。

```{r}
str_c("New Cases: ", str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  "))
```





### 列の結合  {#str_unite .unnumbered}

データフレーム中の複数の列を文字列にまとめるには、**tidyr** パッケージの `unite()` を用います。これは `separate()` の逆の操作にあたります。

まず新しい統合された列の名前を指定します。次に、結合したい列の名前を指定します。

* 初期設定ではアンダースコア `_` によって各列の値が結合されますが、これは `sep = ` によって変更できます。  
* `remove = ` は入力に用いた列をデータフレームから削除します（初期設定ではTRUE）。
* `na.rm = ` は結合時に欠測値を取り除きます（初期設定ではFALSE）。

以下に、デモ用のミニデータフレームを定義します:  

```{r, message = F, warning=F}
df <- data.frame(
  case_ID = c(1:6),
  symptoms  = c("jaundice, fever, chills",     # patient 1
                "chills, aches, pains",        # patient 2 
                "fever",                       # patient 3
                "vomiting, diarrhoea",         # patient 4
                "bleeding from gums, fever",   # patient 5
                "rapid pulse, headache"),      # patient 6
  outcome = c("Recover", "Death", "Death", "Recover", "Recover", "Recover"))
```


```{r}
df_split <- separate(df, symptoms, into = c("sym_1", "sym_2", "sym_3"), extra = "merge")
```

ここで作られたデータフレームはこのようになります：

```{r, echo=F}
DT::datatable(df_split, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

B以下に、3つの症状の列を統一します：  

```{r}
df_split %>% 
  unite(
    col = "all_symptoms",         # 新しく作られる列の名前
    c("sym_1", "sym_2", "sym_3"), # 結合する列
    sep = ", ",                   # 区切りに使われる結合子
    remove = TRUE,                # TRUEの場合、結合元の列をデータフレームから削除します。
    na.rm = TRUE                  # TRUEの場合、欠測値を無視して結合します。
  )
```







<!-- ======================================================= -->
### 分割 {.unnumbered}  

パターンに基づいて文字列を分割するには、`str_split()`を使います。文字（列）を評価し、新たに分割された値からなる文字ベクターの `list` を返します。

以下の簡単な例では，1つの文字列を3つに分割しています．初期設定では、最初に与えられた文字列ごとに1つの要素（文字ベクター）を持つ `list` を返します。`simplify = TRUE` の場合は、文字行列を返します。

この例では、1つの文字列が与えられ、この関数は1つの要素を持つリスト - つまり3つの値を持つ文字ベクターを返します。 

```{r}
str_split(string = "jaundice, fever, chills",
          pattern = ",")
```

出力が保存されていれば、大括弧を使ってn番目の値にアクセスできます。特定の値にアクセスするには、次のような構文を使用できます：`the_returned_object[[1]][2]`。この例では、最初に評価された文字列（"fever"）から2番目の値にアクセスします。要素へのアクセスの詳細については、[R の基礎](#basics) のページを参照してください。

```{r}
pt1_symptoms <- str_split("jaundice, fever, chills", ",")

pt1_symptoms[[1]][2]  # リスト内の1つ目（かつここでは唯一）の要素内にある2つ目の値を返す
```

`str_split()` で複数の文字列を指定した場合、返されるリストには複数の要素が含まれます。

```{r}
symptoms <- c("jaundice, fever, chills",     # 患者 1
              "chills, aches, pains",        # 患者 2 
              "fever",                       # 患者 3
              "vomiting, diarrhoea",         # 患者 4
              "bleeding from gums, fever",   # 患者 5
              "rapid pulse, headache")       # 患者 6

str_split(symptoms, ",")                     # 各患者の症状を分割する
```


データフレームの列を作成したい場合、次のように `simplify = TRUE` を設定することで文字行列を出力すると便利です：

```{r}
str_split(symptoms, ",", simplify = TRUE)
```

また `n = ` を使って、分割する数を調整することもできます。例えば以下の例は分割数を2に制限するもので、それ以上のカンマは2番目の値の中に残ります。

```{r}
str_split(symptoms, ",", simplify = TRUE, n = 2)
```

*注 - `str_split_fixed()` でも同じ出力が得られますが、その場合は `simplify` 引数を与えず、代わりに列数（`n`）を指定しなければなりません。* 

```{r, eval=F}
str_split_fixed(symptoms, ",", n = 2)
```




### 列の分割 {.unnumbered}  

データフレームの列を分割する場合は、**dplyr** パッケージの `separate()` 関数が最適です。この関数は、文字列を要素に持つ 1 つの列を複数の列に分割することができます。

例えば、以前に[結合](#str_unite)の節で定義した簡単なデータフレーム `df` を見てみましょう。このデータフレームは `case_ID` の列、多くの症状をまとめた文字列からなる列、そして予後を示す列を含んでいます。我々のここでの目的は、`symptoms` 列を複数の列に分割し、各列が単一の症状を示すようにすることです。

```{r, echo=F}
DT::datatable(df, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

データを `separate()` で処理したい場合、まず分離する列を指定します。次に、以下のように新しい列名を含むベクター `c()` によって `into = ` を指定します。

* `sep = ` 分割する位置を、文字または数字で指定します。
* `remove = ` 初期設定ではFALSE。入力された列を削除します。  
* `convert = ` 初期設定ではFALSE。文字列 "NA"を NAに変換します。
* `extra = ` 分離によって作成された値の数が、指定された新規列の名前よりも多い場合の動作を制御します。
     * `extra = "warn"` は、警告を表示しますが、過剰な値は削除されます（**初期設定**）。
     * `extra = "drop"` は、警告を表示せずに余分な値を削除します。
     * **`extra = "merge"` は、`into = `で指定された新しい列の数だけ分割します。- *この設定では全ての入力データが保存されます。***  


`extra = "merge"` を使用した例を以下に示します - ここではデータは失われません。2つの新しい列が定義され、3つ目の症状は2つ目の列に残されます：  

```{r}
# 3 つ目の症状は 2 つ目の新しい列に組み込まれる
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",", extra = "merge")
```

初期設定の `extra = "drop"` では ≈、警告が表示されます：

```{r}
# 3番目の症状は失われる
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",")
```


<span style="color: orange;">**注意：** `into = `に入力された値の数が不足していると、データが切り捨てられる可能性があります。</span>  






<!-- ======================================================= -->
### アルファベット順に並べる {.unnumbered} 

複数の文字列をアルファベット順に並べることができます。 `str_order()` は順序を返し、`str_sort()` はその順序に並べ替えた文字列を返します。

```{r}
# 文字列の定義
health_zones <- c("Alba", "Takota", "Delta")

# アルファベット順を返す
str_order(health_zones)

# アルファベット順に並び替える
str_sort(health_zones)
```

異なるアルファベットを使用するには、引数 `locale = `を追加します。R コンソールで `stringi::stri_locale_list()` と入力することで、指定可能なアルファベットの一覧を表示することができます。





<!-- ======================================================= -->
### R の基本関数 {.unnumbered}

R の **base** （基本）関数である `paste()` や `paste0()` は、与えられたベクターのすべての要素を文字に変換した後、連結して1つの文字列を返すためにしばしば使われます。これらの関数は `str_c()` と似ていますが、構文はより複雑で、括弧の中では各部分がカンマで区切られています。各パーツは引用符で囲まれた文字テキストまたは既に定義されたコードオブジェクト（引用符なし）です。例えば、以下のようになります：

```{r}
n_beds <- 10
n_masks <- 20

paste0("Regional hospital needs ", n_beds, " beds and ", n_masks, " masks.")
```

`sep = ` と `collapse = ` の引数を指定できます。`paste()` は `sep = " "` （半角スペース）を初期設定に持つ `paste0()` と同値です。






## 整理と標準化


<!-- ======================================================= -->
### 大文字小文字の変更 {.unnumbered}

しばしば、管轄区域の名称などで大文字小文字を変更する必要に迫られることがあります。その際は以下のように、**stringr** に含まれる `str_to_upper()`、`str_to_lower()`、`str_to_title()` を用います：

```{r}
str_to_upper("California")

str_to_lower("California")
```

Rの **base** 関数である `toupper()`,`tolower()` を用いることでも上記と同じ処理が可能です。


**タイトルケース**  

各単語の語頭を大文字にするには `str_to_title()` を用います：  

```{r}
str_to_title("go to the US state of california ")
```

**tools** パッケージの `toTitleCase()` を使うことで、より厳密なタイトルケース（"to", "the", "of" といった単語は大文字化されません）に変更することができます。

```{r}
tools::toTitleCase("This is the US state of california")
```

`str_to_sentence()` を使えば、文字列の最初の文字のみを大文字化することができます。

```{r}
str_to_sentence("the patient must be transported")
```



### 文字列を伸長する  {#str_pad .unnumbered}

`str_pad()` を用いると、文字列に特定の文字を足すことで、指定した最小の長さまで文字列を伸ばすことができます。初期設定では空白が追加されますが、`pad = `によって他の文字を指定することも可能です。


```{r}
# ICD codes of differing length
ICD_codes <- c("R10.13",
               "R10.819",
               "R17")

# ICD codes padded to 7 characters on the right side
str_pad(ICD_codes, 7, "right")

# Pad with periods instead of spaces
str_pad(ICD_codes, 7, "right", pad = ".")
```

例えば、`pad = "0"` により先頭に 0 を足すことで、時間や分のように数字からなる文字列の長さが少なくとも 2 になるように処理することができます。

```{r}
# 先頭に 0 を足して 2 桁にする(例：時間・分の表示)
str_pad("4", 2, pad = "0") 

# "hours" という名前の数字列を作る場合
# hours <- str_pad(hours, 2, pad = "0")
```


### 文字数を短縮する {.unnumbered} 

`str_trunc()` で文字列の長さの最大値を設定できます。与えられた文字列の長さが指定した最大値を超える場合、その文字列は短縮され、省略記号（...）が挿入されます。このとき、省略記号は文字数にカウントされることに注意してください。使用される省略記号は `ellipsis = `で指定することができます。また `side = ` によって、省略記号がどこに挿入されるか（“left”、 “right”、 “center”）を指定することができます。

```{r}
original <- "Symptom onset on 4/3/2020 with vomiting"
str_trunc(original, 10, "center")
```


### 長さの標準化 {.unnumbered}

文字列の長さの最大値を `str_trunc()` で指定し、さらに `str_pad()` を用いて短い文字列をその長さまで伸長することができます。以下の例では、最大値を 6 に設定し（ 1 つの文字列が短縮されます）、続いて 1 つの短い文字列がその長さまで伸長されます。  

```{r}
# 異なる長さのICDコード
ICD_codes   <- c("R10.13",
                 "R10.819",
                 "R17")

# 最大の長さが 6 になるよう文字列を短縮
ICD_codes_2 <- str_trunc(ICD_codes, 6)
ICD_codes_2

# 最小の長さが 6 になるよう文字列を伸長
ICD_codes_3 <- str_pad(ICD_codes_2, 6, "right")
ICD_codes_3
```


### 先頭・末尾の空白を削除する {.unnumbered}  

`str_trim()` を用いて文字列の端にある空白、改行（`\n`）、タブ （`\t`）を削除できます。`"right"`、`"left"`、または `"both"` を指定することにより、どちらの端から削除するかを選択することができます（例：`str_trim(x, "right")`）。

```{r}
# 右端に余分な空白を持つID
IDs <- c("provA_1852  ", # 2 つの余分な空白
         "provA_2345",   # 余分な空白なし
         "provA_9460 ")  # 1 つの余分な空白

# 右端から空白を削除
str_trim(IDs)
```


### 繰り返される空白の削除 {.unnumbered}  

`str_squish()` を用いて文字列の内部に連続して現れる空白を作事できます。例えば、2 つ続きになっている空白を単一の空白に変更できます。`str_trim()` と同様、文字列の端にある空白、改行、タブを削除することもできます。


```{r}
# 元の文字列は内部に余分な空白を含む
str_squish("  Pt requires   IV saline\n") 
```

R コンソールに `?str_trim`、`?str_pad` と入力することで詳細を参照できます。


### 指定の文字数で文章を改行する {.unnumbered}  

`str_wrap()` を用いることで、長い文章を指定した文字数で改行し整理することができます。任意の文字数を指定すれば、アルゴリズムにより以下のように文章中に改行（`\n`）が挿入されます。

```{r}
pt_course <- "Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020."

str_wrap(pt_course, 40)
```

**base** 関数である `cat()` に上記のコマンドを入力することで、改行された文章を表示することができます。

```{r}
cat(str_wrap(pt_course, 40))
```












<!-- ======================================================= -->
## Handle by position { }


### Extract by character position {.unnumbered}  

Use `str_sub()` to return only a part of a string. The function takes three main arguments:  

1) the character vector(s)  
2) start position  
3) end position  

A few notes on position numbers:  

* If a position number is positive, the position is counted starting from the left end of the string.  
* If a position number is negative, it is counted starting from the right end of the string.  
* Position numbers are inclusive.  
* Positions extending beyond the string will be truncated (removed).  

Below are some examples applied to the string "pneumonia":  

```{r}
# start and end third from left (3rd letter from left)
str_sub("pneumonia", 3, 3)

# 0 is not present
str_sub("pneumonia", 0, 0)

# 6th from left, to the 1st from right
str_sub("pneumonia", 6, -1)

# 5th from right, to the 2nd from right
str_sub("pneumonia", -5, -2)

# 4th from left to a position outside the string
str_sub("pneumonia", 4, 15)
```



### Extract by word position {.unnumbered} 

To extract the nth 'word', use `word()`, also from **stringr**. Provide the string(s), then the first word position to extract, and the last word position to extract.  

By default, the separator between 'words' is assumed to be a space, unless otherwise indicated with `sep = ` (e.g. `sep = "_"` when words are separated by underscores.  


```{r}
# strings to evaluate
chief_complaints <- c("I just got out of the hospital 2 days ago, but still can barely breathe.",
                      "My stomach hurts",
                      "Severe ear pain")

# extract 1st to 3rd words of each string
word(chief_complaints, start = 1, end = 3, sep = " ")
```


### Replace by character position {.unnumbered} 

`str_sub()` paired with the assignment operator (`<-`) can be used to modify a part of a string: 

```{r}
word <- "pneumonia"

# convert the third and fourth characters to X 
str_sub(word, 3, 4) <- "XX"

# print
word
```

An example applied to multiple strings (e.g. a column). Note the expansion in length of "HIV".  

```{r}
words <- c("pneumonia", "tubercolosis", "HIV")

# convert the third and fourth characters to X 
str_sub(words, 3, 4) <- "XX"

words
```



### Evaluate length  {.unnumbered}


```{r}
str_length("abc")
```

Alternatively, use `nchar()` from **base** R







<!-- ======================================================= -->
## Patterns { }

Many **stringr** functions work to detect, locate, extract, match, replace, and split based on a specified *pattern*.  



<!-- ======================================================= -->
### Detect a pattern {.unnumbered}

Use `str_detect()` as below to detect presence/absence of a pattern within a string. First provide the string or vector to search in (`string = `), and then the pattern to look for (`pattern = `). Note that by default the search *is case sensitive*!

```{r}
str_detect(string = "primary school teacher", pattern = "teach")
```

The argument `negate = ` can be included and set to `TRUE` if you want to know if the pattern is NOT present.  
 
```{r}
str_detect(string = "primary school teacher", pattern = "teach", negate = TRUE)
```

To ignore case/capitalization, wrap the pattern within `regex()`, and *within* `regex()` add the argument `ignore_case = TRUE` (or `T` as shorthand).  

```{r}
str_detect(string = "Teacher", pattern = regex("teach", ignore_case = T))
```

When `str_detect()` is applied to a character vector or a data frame column, it will return TRUE or FALSE for each of the values. 

```{r}
# a vector/column of occupations 
occupations <- c("field laborer",
                 "university professor",
                 "primary school teacher & tutor",
                 "tutor",
                 "nurse at regional hospital",
                 "lineworker at Amberdeen Fish Factory",
                 "physican",
                 "cardiologist",
                 "office worker",
                 "food service")

# Detect presence of pattern "teach" in each string - output is vector of TRUE/FALSE
str_detect(occupations, "teach")
```

If you need to count the `TRUE`s, simply `sum()` the output. This counts the number `TRUE`.  

```{r}
sum(str_detect(occupations, "teach"))
```

To search inclusive of multiple terms, include them separated by OR bars (`|`) within the `pattern = ` argument, as shown below:  

```{r}
sum(str_detect(string = occupations, pattern = "teach|professor|tutor"))
```

If you need to build a long list of search terms, you can combine them using `str_c()` and `sep = |`, then define this is a character object, and then reference the vector later more succinctly. The example below includes possible occupation search terms for front-line medical providers.     

```{r}
# search terms
occupation_med_frontline <- str_c("medical", "medicine", "hcw", "healthcare", "home care", "home health",
                                "surgeon", "doctor", "doc", "physician", "surgery", "peds", "pediatrician",
                               "intensivist", "cardiologist", "coroner", "nurse", "nursing", "rn", "lpn",
                               "cna", "pa", "physician assistant", "mental health",
                               "emergency department technician", "resp therapist", "respiratory",
                                "phlebotomist", "pharmacy", "pharmacist", "hospital", "snf", "rehabilitation",
                               "rehab", "activity", "elderly", "subacute", "sub acute",
                                "clinic", "post acute", "therapist", "extended care",
                                "dental", "dential", "dentist", sep = "|")

occupation_med_frontline
```

This command returns the number of occupations which contain any one of the search terms for front-line medical providers (`occupation_med_frontline`):  

```{r}
sum(str_detect(string = occupations, pattern = occupation_med_frontline))
```



**Base R string search functions**  

The **base** function `grepl()` works similarly to `str_detect()`, in that it searches for matches to a pattern and returns a logical vector. The basic syntax is `grepl(pattern, strings_to_search, ignore.case = FALSE, ...)`. One advantage is that the `ignore.case` argument is easier to write (there is no need to involve the `regex()` function).  

Likewise, the **base** functions `sub()` and `gsub()` act similarly to `str_replace()`. Their basic syntax is: `gsub(pattern, replacement, strings_to_search, ignore.case = FALSE)`. `sub()` will replace the first instance of the pattern, whereas `gsub()` will replace all instances of the pattern.  


#### Convert commas to periods {.unnumbered}  

Here is an example of using `gsub()` to convert commas to periods in a vector of numbers. This could be useful if your data come from parts of the world other than the United States or Great Britain.  

The inner `gsub()` which acts first on `lengths` is converting any periods to no space "". The period character  "." has to be "escaped" with two slashes to actually signify a period, because "." in regex means "any character". Then, the result (with only commas) is passed to the outer `gsub()` in which commas are replaced by periods.   

```{r, eval=F}
lengths <- c("2.454,56", "1,2", "6.096,5")

as.numeric(gsub(pattern = ",",                # find commas     
                replacement = ".",            # replace with periods
                x = gsub("\\.", "", lengths)  # vector with other periods removed (periods escaped)
                )
           )                                  # convert outcome to numeric
```





### Replace all {.unnumbered}  

Use `str_replace_all()` as a "find and replace" tool. First, provide the strings to be evaluated to `string = `, then the pattern to be replaced to `pattern = `, and then the replacement value to `replacement = `. The example below replaces all instances of "dead" with "deceased". Note, this IS case sensitive.  

```{r}
outcome <- c("Karl: dead",
            "Samantha: dead",
            "Marco: not dead")

str_replace_all(string = outcome, pattern = "dead", replacement = "deceased")
```

Notes:  

* To replace a pattern with `NA`, use `str_replace_na()`.  
* The function `str_replace()` replaces only the first instance of the pattern within each evaluated string.  





<!-- ======================================================= -->
### Detect within logic {.unnumbered}


**Within `case_when()`**  

`str_detect()` is often used within `case_when()` (from **dplyr**). Let's say `occupations` is a column in the linelist. The `mutate()` below creates a new column called `is_educator` by using conditional logic via `case_when()`. See the page on data cleaning to learn more about `case_when()`.  


```{r, eval=F}
df <- df %>% 
  mutate(is_educator = case_when(
    # term search within occupation, not case sensitive
    str_detect(occupations,
               regex("teach|prof|tutor|university",
                     ignore_case = TRUE))              ~ "Educator",
    # all others
    TRUE                                               ~ "Not an educator"))
```

As a reminder, it may be important to add exclusion criteria to the conditional logic (`negate = F`):  

```{r, eval=F}
df <- df %>% 
  # value in new column is_educator is based on conditional logic
  mutate(is_educator = case_when(
    
    # occupation column must meet 2 criteria to be assigned "Educator":
    # it must have a search term AND NOT any exclusion term
    
    # Must have a search term
    str_detect(occupations,
               regex("teach|prof|tutor|university", ignore_case = T)) &              
    
    # AND must NOT have an exclusion term
    str_detect(occupations,
               regex("admin", ignore_case = T),
               negate = TRUE                        ~ "Educator"
    
    # All rows not meeting above criteria
    TRUE                                            ~ "Not an educator"))
```





<!-- ======================================================= -->
### Locate pattern position {.unnumbered}  

To locate the *first* position of a pattern, use `str_locate()`. It outputs a start and end position.   

```{r}
str_locate("I wish", "sh")
```

Like other `str` functions, there is an "_all" version (`str_locate_all()`) which will return the positions of *all* instances of the pattern within each string. This outputs as a `list`.  

```{r}
phrases <- c("I wish", "I hope", "he hopes", "He hopes")

str_locate(phrases, "h" )     # position of *first* instance of the pattern
str_locate_all(phrases, "h" ) # position of *every* instance of the pattern
```





<!-- ======================================================= -->
### Extract a match {.unnumbered}  

`str_extract_all()` returns the matching patterns themselves, which is most useful when you have offered several patterns via "OR" conditions. For example, looking in the string vector of occupations (see previous tab) for *either* "teach", "prof", or "tutor".

`str_extract_all()` returns a `list` which contains *all matches* for each evaluated string. See below how occupation 3 has two pattern matches within it.  

```{r}
str_extract_all(occupations, "teach|prof|tutor")
```


`str_extract()` extracts *only the first match* in each evaluated string, producing a character vector with one element for each evaluated string. It returns `NA` where there was no match. The `NA`s can be removed by wrapping the returned vector with `na.exclude()`. Note how the second of occupation 3's matches is not shown.  

```{r}
str_extract(occupations, "teach|prof|tutor")
```

<!-- ======================================================= -->
### Subset and count {.unnumbered}  

Aligned functions include `str_subset()` and `str_count()`.  

`str_subset()` returns the actual values which contained the pattern: 

```{r}
str_subset(occupations, "teach|prof|tutor")
```

`str_count()` returns a vector of numbers: the **number of times** a search term appears in each evaluated value.  

```{r}
str_count(occupations, regex("teach|prof|tutor", ignore_case = TRUE))
```












<!-- ======================================================= -->
### Regex groups {.unnumbered}

UNDER CONSTRUCTION






<!-- ======================================================= -->
## Special characters  

**Backslash `\` as escape**  

The backslash `\` is used to "escape" the meaning of the next character. This way, a backslash can be used to have a quote mark display *within* other quote marks (`\"`) - the middle quote mark will not "break" the surrounding quote marks.  

Note - thus, if you want to *display* a backslash, you must escape it's meaning with *another* backslash. So you must write two backslashes `\\` to display one.  

**Special characters**  

Special character | Represents  
----------------- | --------------------------------------------------------------    
`"\\"` | backslash  
`"\n"` | a new line (newline)   
`"\""` | double-quote *within* double quotes  
`'\''` | single-quote *within* single quotes  
`"\`"` | grave accent  
`"\r"` | carriage return  
`"\t"` | tab  
`"\v"` | vertical tab 
`"\b"` | backspace  


Run `?"'"` in the R Console to display a complete list of these special characters (it will appear in the RStudio Help pane). 



<!-- ======================================================= -->
## Regular expressions (regex) 


<!-- ======================================================= -->
## Regex and special characters { } 

Regular expressions, or "regex", is a concise language for describing patterns in strings. If you are not familiar with it, a regular expression can look like an alien language. Here we try to de-mystify this language a little bit.  

*Much of this section is adapted from [this tutorial](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) and [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)*. We selectively adapt here knowing that this handbook might be viewed by people without internet access to view the other tutorials.    


A regular expression is often applied to extract specific patterns from "unstructured" text - for example medical notes, chief complaints, patient history, or other free text columns in a data frame  

There are four basic tools one can use to create a basic regular expression:  

1) Character sets  
2) Meta characters  
3) Quantifiers  
4) Groups  


**Character sets**  

Character sets, are a way of expressing listing options for a character match, within brackets. So any a match will be triggered if any of the characters within the brackets are found in the string. For example, to look for vowels one could use this character set: "[aeiou]". Some other common character sets are:  

Character set | Matches for  
----------------- | --------------------------------------------------------------    
`"[A-Z]"` | any single capital letter  
`"[a-z]"` | any single lowercase letter  
`"[0-9]"` | any digit  
`[:alnum:]` | any alphanumeric character  
`[:digit:]` | any numeric digit  
`[:alpha:]` | any letter (upper or lowercase)  
`[:upper:]` | any uppercase letter  
`[:lower:]` | any lowercase letter  


Character sets can be combined within one bracket (no spaces!), such as `"[A-Za-z]"` (any upper or lowercase letter), or another example `"[t-z0-5]"` (lowercase t through z OR number 0 through 5).  



**Meta characters**  

Meta characters are shorthand for character sets. Some of the important ones are listed below:  

Meta character | Represents  
----------------- | --------------------------------------------------------------    
`"\\s"` | a single space  
`"\\w"` | any single alphanumeric character (A-Z, a-z, or 0-9)  
`"\\d"` | any single numeric digit (0-9)  


**Quantifiers**  

Typically you do not want to search for a match on only one character. Quantifiers allow you to designate the length of letters/numbers to allow for the match.  

Quantifiers are numbers written within curly brackets `{ }` *after* the character they are quantifying, for example,  

* `"A{2}"` will return instances of **two** capital A letters.  
* `"A{2,4}"` will return instances of **between two and four** capital A letters *(do not put spaces!)*.  
* `"A{2,}"` will return instances of **two or more** capital A letters.  
* `"A+"` will return instances of **one or more** capital A letters (group extended until a different character is encountered).  
* Precede with an `*` asterisk to return **zero or more** matches (useful if you are not sure the pattern is present)  


Using the `+` plus symbol as a quantifier, the match will occur until a different character is encountered. For example, this expression will return all *words* (alpha characters: `"[A-Za-z]+"`  


```{r}
# test string for quantifiers
test <- "A-AA-AAA-AAAA"
```

When a quantifier of {2} is used, only pairs of consecutive A's are returned. Two pairs are identified within `AAAA`.  

```{r}
str_extract_all(test, "A{2}")
```

When a quantifier of {2,4} is used, groups of consecutive A's that are two to four in length are returned.  

```{r}
str_extract_all(test, "A{2,4}")
```

With the quantifier `+`, groups of **one or more** are returned:  

```{r}
str_extract_all(test, "A+")
```

**Relative position**  

These express requirements for what precedes or follows a pattern. For example, to extract sentences, "two numbers that are followed by a period" (`""`).  (?<=\\.)\\s(?=[A-Z]) 

```{r}
str_extract_all(test, "")
```

Position statement | Matches to  
----------------- | --------------------------------------------------------------    
`"(?<=b)a"` | "a" that **is preceded** by a "b"  
`"(?<!b)a"` | "a" that **is NOT preceded** by a "b"  
`"a(?=b)"` | "a" that **is followed** by a "b"  
`"a(?!b)"` | "a" that **is NOT followed** by a "b"  





**Groups**  

Capturing groups in your regular expression is a way to have a more organized output upon extraction.  




**Regex examples**  

Below is a free text for the examples. We will try to extract useful information from it using a regular expression search term.  

```{r}
pt_note <- "Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute."
```

This expression matches to all words (any character until hitting non-character such as a space):  

```{r}
str_extract_all(pt_note, "[A-Za-z]+")
```

The expression `"[0-9]{1,2}"` matches to consecutive numbers that are 1 or 2 digits in length. It could also be written `"\\d{1,2}"`, or `"[:digit:]{1,2}"`.  

```{r}
str_extract_all(pt_note, "[0-9]{1,2}")
```

<!-- This expression will extract all sentences (assuming first letter is capitalized, and the sentence ends with a period). The pattern reads in English as: "A capital letter followed by some lowercase letters, a space, some letters, a space,     -->

<!-- ```{r} -->
<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->
<!-- ``` -->


You can view a useful list of regex expressions and tips on page 2 of [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)  

Also see this [tutorial](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432).  




<!-- ======================================================= -->
## Resources { }

A reference sheet for **stringr** functions can be found [here](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)


A vignette on **stringr** can be found [here](
https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)




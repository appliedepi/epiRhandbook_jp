# データクリーニングと主要関数 {#cleaning}

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

この章では、データクリーニング（データの前処理）の一般的な手順を示し、R を使ったデータ管理に不可欠な多くの機能を説明します。

症例データを含んだ未加工のラインリストを例として使用し、ラインリストのインポートを始め、段階的にデータクリーニングの手順を解説していきます。上の図のような処理は、R コードでは「パイプ（"pipe"）」チェーンとして明示され、「パイプ」演算子 `%>%`によって、対象のデータセットをある操作から次の操作に渡すことができます。

### 主要関数 {.unnumbered}

このハンドブックでは、R パッケージの一つである [**tidyverse**](https://www.tidyverse.org/) 系関数を主に使用します。以下の表は、本章で使用する基本の R パッケージおよびパッケージに含まれる関数の一覧です。

関数の多くは、データ操作に関する課題を解決するための「動詞」関数を提供する R パッケージ [**dplyr**](https://dplyr.tidyverse.org/) に属しています（**dplyr** という名前は"data frame-[plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)%22)." にちなんでいます）。**dplyr** パッケージは、**ggplot2**、**tidyr**、**stringr**、**tibble**、**purrr**、**magrittr**、**forcats** などの各パッケージを含む R パッケージである **tidyverse** ファミリーの一部です。

| **関数**                                            | 機能                                           | **パッケージ**            |
|-----------------------------------------------------|------------------------------------------------|---------------------------|
| `%>%`                                               | ある関数から次の関数へデータを「パイプで渡す」 | **magrittr**              |
| `mutate()`                                          | 列の作成、変換、再定義                         | **dplyr**                 |
| `select()`                                          | 列の保持、削除、選択、列名の変更               | **dplyr**                 |
| `rename()`                                          | 列名の変更                                     | **dplyr**                 |
| `clean_names()`                                     | 列名の構文を標準化                             | **janitor**               |
| `as.character()`, `as.numeric()`, `as.Date()`, etc. | 列のデータ型を変換                             | **base** R                |
| `across()`                                          | 複数の列を一度に変換                           | **dplyr**                 |
| **tidyselect** functions                            | 論理条件を使った列の選択                       | **tidyselect**            |
| `filter()`                                          | 特定の行を選択                                 | **dplyr**                 |
| `distinct()`                                        | 重複した行の削除                               | **dplyr**                 |
| `rowwise()`                                         | 各行の中の操作、または各行による操作           | **dplyr**                 |
| `add_row()`                                         | 手動で行を追加                                 | **tibble**                |
| `arrange()`                                         | 行の並べ替え                                   | **dplyr**                 |
| `recode()`                                          | 列の値を再定義                                 | **dplyr**                 |
| `case_when()`                                       | 複数の論理基準を使用し列値を再コーディング     | **dplyr**                 |
| `replace_na()`, `na_if()`, `coalesce()`             | 再コーティングのための専用関数                 | **tidyr**                 |
| `age_categories()` and `cut()`                      | 数値列からカテゴリグループを作成               | **epikit** and **base** R |
| `clean_variable_spelling()`                         | データ辞書を使用した値の再定義・処理           | **linelist**              |
| `which()`                                           | 論理的基準を適用し、インデックスを抽出         | **base** R                |

これらの関数を Stata や SAS のコマンドと比較したい場合は、[Excel・Stata・SASとの比較](#transition-to-R) の章を参照してください。

また、R パッケージの **data.table** では、`:=` のような演算子や角括弧 `[ ]` が頻繁に使用されており、別の形のデータ管理フレームワークを目にすることがあるかもしれません。この手法と構文については、[データテーブル](#data-table) の章で簡単に説明しています。

### 用語体系 {.unnumbered}

このハンドブックでは、一般的に「変数」や「観測値」の代わりに「列」や「行」を使用します。["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html) の入門書で説明されているように、疫学統計データセットのほとんどは、行、列、値の構造で構成されています。

「変数」は、同じ基本属性について測定された値（年齢層、アウトカム、発症日など）を示しています。「観測値」は、同じ単位（人、場所、ラボのサンプルなど）で測定されたすべての値を示します。そのため、これらの値を明確に定義することは困難です。

"tidy" データセット（綺麗に整理されたデータセット）では、各列が変数、各行が観測値、そして各セルが 1 つの値となっています。しかし、この型に当てはまらないデータセットもあります。"wide" 型（横型）のデータセットでは、1 つの変数が複数の列に分かれて記録されていることがあります（詳細は、[データの縦横変換](#pivoting) の章で紹介する例をご参照ください）。同様に、観測値が複数の行に分かれていることもあります。

このハンドブックでは、主にデータの管理と変換について取り扱うため、抽象的な観測値や変数よりも、行や列といった具体的なデータ構造を示す呼び方を使用していきます。例外として、データ分析のページでは、変数や観測値と呼ぶことがあります。

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## パイプラインによるデータクリーニング

**このページでは、代表的なデータクリーニングの手順を実行し、パイプに処理を順次追加しながら進めていきます。**

疫学的な分析やデータ処理では、クリーニングを行う際、複数の手順が連続して実行されることが多く、手順どうしが互いに関連していることがよくあります。Rでは多くの場合、このように連続した手順はクリーニングを行う一貫したパイプラインとして作成され、データが処理されます。作成されたパイプラインでは、未加工のデータセットが 1 つのデータ処理のステップから別のデータ処理のステップに渡されます。

このような連続処理には、**dplyr** パッケージの「動詞」関数と **magrittr** パッケージのパイプ演算子 `%>%` が使用されます。パイプ処理は、始めに未加工データ（"linelist_raw.xlsx"）を扱い、最終的に、使用や保存、エクスポートなどが行えるクリーニングされた R データフレーム（`linelist`）を作成することを目標としています。

パイプラインのデータ処理は、各手順の順番が重要です。クリーニングの手順には以下のようなものがあります。

-   データをインポートする\

-   列名を修正、または変更する\

-   重複したデータを排除する\

-   列を作成し、変換する（例：値の再定義または標準化）\

-   行を抽出、または追加する\

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## パッケージの読み込み

以下のコードを実行すると、分析に必要なパッケージが読み込まれます。このハンドブックでは、パッケージを読み込むために、**pacman** パッケージの `p_load()` を主に使用しています。`p_load()` は、必要に応じてパッケージをインストールし、現在の R セッションで使用するためにパッケージを読み込む関数です。また、既にインストールされたパッケージは、R の基本パッケージである **base** の `library()` を使用して読み込むこともできます。R パッケージに関する詳細は、[R の基礎](#basics) の章をご覧ください。

```{r, message = F}
pacman::p_load(
  rio,        # データを読み込むためのパッケージ  
  here,       # 相対ファイルパスを設定するためのパッケージ  
  janitor,    # データ前処理と表の作成のためのパッケージ  
  lubridate,  # 日付操作のためのパッケージ  
  epikit,     # age_categories()を含むパッケージ  
  tidyverse   # データ管理と可視化のためのパッケージ  
  )
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## データのインポート

### データをインポートする {.unnumbered}

ここでは、**rio** パッケージの `import()` を使って、未加工の症例リスト（Excel ファイル）をインポートします。**rio** パッケージは、様々な形式のファイル（.xlsx、.csv、.tsv、.rds など）に対応できます。**rio** パッケージの詳細や、通常とは異なる状況（行のスキップ、欠損値の設定、Googleシートのインポートなど）での対処法を知りたい方は、[インポートとエクスポート](#importing) の章をご覧ください。

お手元の環境でこの章の内容を実行したい方は、[こちら](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx) から「未加工の」ラインリストをダウンロードしてください（.xlsx ファイルとしてダウンロードされます）。

データサイズが大きいためにインポートに時間がかかる場合は、インポートするためのコードを、インポート後のデータ前処理を行うパイプラインとは別の場所に書き、未加工データを元データとしてオブジェクトに保存しておくと便利です。コードを分けて書くことで、未加工データと前処理済みのデータの比較が容易になります。

```{r, echo=F, message=F}
# HIDDEN FROM READER（このコードチャンクは、ウェブ版には表示されない）
# 実際にデータをロードするには here() を使用する
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

データフレームの最初の 50 行を確認してみましょう。

注釈：R の基本パッケージ **base** に含まれている関数 `head(n)` を使うと、R コンソールに最初の `n` 行が表示されます。

```{r message=FALSE, echo=F}
# ラインリストのデータを表で表示する
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### インポートしたデータを確認する {.unnumbered}

**skimr** パッケージの `skim()` を使うと、データフレーム全体の概要を把握することができます（詳しくは、[記述統計表の作り方](#tables-descriptive) を参照ください）。列は、文字値や数値などのデータ型別にまとめられています。

注釈："POSIXct" は未加工の日付データ型の一つです（詳細は、[日付型データ](#dates) の章をご覧ください）。

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 列名

Rでは、データセットの「ヘッダー」または各列の「一番上」の値が列名になります。列名は、コード内で列を参照するために使用されるほか、図を作成する際はデフォルトのラベルとして使用されます。

SAS や STATA など他の統計ソフトでは、短い列名を具体的に説明する「ラベル」が列名と共に使用されることが多いですが、R ではほとんど使用されません（R でもデータに列ラベルを追加することは可能です）。列名を図の表示に合わせて変更したい場合は、通常、図をプロットするコードの中で調整します（例えば、図の軸や凡例のタイトル、表示される表のヘッダーなどを調整したい場合です。詳細は、[ggplot のヒントの章の 31.2 スケール](#ggplot_tips_scales)と[見やすい表の作り方](#tables-presentation) のページを参照してください）。データに列ラベルを付けたい場合は、[こちら](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) と [こちら](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html) のページをご覧ください。

R の列名はデータ分析やデータ管理において非常に頻繁に使用されるため、「きれいに」整えられている必要があります。列名を設定する際の一般的なルールとして、以下のように提案します。

-   短い名前にする

-   スペースを使わない（スペースが必要な場合は、アンダースコア \_ に置き換えてください）

-   &、\#、\< \> などの特殊な文字を使用しない

-   各列似たようなスタイルの用語を使用する（例：異なる種類の日付データを含む列が複数ある場合に、date_onset、date_report、date_death とするなど）

以下に、R の基本パッケージである **base** の `names()` を使用して `linelist_raw` の列名を表示しました。表示された列名には、次のような特徴がみられます。

-   スペースを含む名前がある（例：`infection date`）

-   日付データを含む列が複数あるが、各列異なるルールで名付けられている　(例：`date onset` と `infection date`）

-   最後の 2 列の名前（"merged_header" と "...28"）を見ると、ダウンロードされた元の .xlsx ファイルの最後の 2 列には、マージされたヘッダーがあったことがわかります。2 つの列がマージされてできた列が R によって分割され、マージされてできた列の名前（"merged_header"）は元々の最初の列に割り当てられ、元々の 2 番目の列にはセルを保持するために一時的に "...28" が割り当てられています（マージされる前は空欄の列であり、28番目の列であるため）。

```{r}
names(linelist_raw)
```

[**注釈**：スペースを含む列名を参照するには、その名前をバックティック（\`）で囲みます。例えば、linelist\$`` ` '\x60infection date\x60'` `` というように使用します。キーボードでは、バックティック（\`）とシングルクォーテーションマーク（'）が異なることに注意してください。]{style="color: black;"}

### ラベル {.unnumbered}

SAS などの他の統計ソフトでは、変数のラベルが付いていることに注意してください。

### 自動クリーニング {.unnumbered}

**janitor** パッケージの `clean_names()` は、以下のように列名を標準化し、ユニークにします。

-   すべての列名をアンダースコア（\_）、数字、文字のみで構成されるように変換します。\

-   アクセント記号付きの文字は ASCII に音訳されます（例：ドイツ語のウムラウト記号付きの o は単に "o" に変換され、スペイン語の "enye "は "n "に変換されます）。\

-   変換後の列名の大文字と小文字の区別は、`case =` 引数を使って指定できます（デフォルトは "snake" になっていますが、他に "sentence"、"title"、"small_camel" などがあります）。\

-   `replace =` 引数にベクトルを与えることで、特定の名前の置き換えを指定することができます（例：`replace = c(onset = "date_of_onset")`)

-   `clean_names()` に関する公式ドキュメントは、[こちら](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning)をご覧ください。

では、前処理のパイプラインを作成していきます。まず初めに、以下では、未加工のラインリストに対して `clean_names()` を使用し、列名を整えていきます。

```{r clean_names}
# 未加工のデータセットを clean_names() にパイプし、出力結果を linelist として保存する
linelist <- linelist_raw %>% 
  janitor::clean_names()

# 新しく作成された linelist の列名を確認する
names(linelist)
```

[[**注釈**]{.ul}**：最終列の列名** "...28" が "x28" に変化したことに注目してください。]{style="color: black;"}

### 手動による列名のクリーニング {.unnumbered}

上で行った自動クリーニングによる列名の標準化の後に、列名を個別に、一つずつ変更することが必要な場合があります。 `rename()` は `NEW = OLD` というスタイルを採用しており、新しい列名を既存の列名の前に書く必要があります。

以下では、上で作成した自動クリーニングのパイプラインに名前を個別に変更するコマンドを追加しています。コードを読みやすくするため、戦略的にスペースを追加しています。

```{r}
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################
linelist <- linelist_raw %>%
    
    # 列名の標準化
    janitor::clean_names() %>% 
    
    # 列名を個別に変更
           # 新しい列名            # 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
```

これで、列名が変更されていることがわかります。

```{r message=FALSE, echo=F}
names(linelist)
```

### 列の位置による名前の変更 {.unnumbered}

列名ではなく、列の位置によって列の名前を変更することもできます。

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### `select()` および `summarise()` による列名の変更 {.unnumbered}

ショートカットとして、**dplyr** パッケージの `select()` や `summarise()` でも列の名前を変更することができます。`select()` は特定の列だけを残すために使用します（本章で後述します）。`summarise()` については、[データのグループ化](#grouping) の章や、[記述統計表の作り方](#tables-descriptive) の章で説明します。これらの関数も `rename()` と同様に、`new_name = old_name` というフォーマットを使用します。以下はその例です。

```{r, eval=F}
linelist_raw %>% 
  select(#新しい列名             # 既存の列名
         date_infection       = `infection date`,    # rename and KEEP ONLY these columns#列名を変更して変更した列だけを残す。
         date_hospitalisation = `hosp date`)
```

### その他の課題 {.unnumbered}

#### 空白の Excel 列名 {.unnumbered}

R は、列名（ヘッダー）のないデータセット列を処理することはできません。したがって、データはあるが列のヘッダーがない Excel データセットをインポートした場合、R は "...1" や "...2" といった名前でヘッダーを埋めることになります。数字は列番号を表します（例：データセットの 4 列目にヘッダーがない場合、R はその列を "...4" と命名します）。

付与された名前は、ポジション番号（上記の例を参照）または割り当てられた名前（`linelist_raw$...1`）を参照することで、手動でクリーニングすることができます。

#### Excel の列名とセルの結合 {.unnumbered}

Excel ファイル中のマージされたセルは、データを受け取る際によく問題になります。[Excel・Stata・SASとの比較](#transition-to-R) の章で説明したように、マージされたセルは、人間がデータを読むときには良いのですが、 コンピュータにとっては「整頓されたデータ」ではなく、 データを読み込む際に多くの問題が発生します。R はマージされたセルに対応できないからです。

人間が読めるデータとコンピュータが読めるデータは別物であることを、データ入力をした担当者に伝えてください。また、整頓されたデータの原則をユーザーに教えるよう努めてください。可能な限り、セルが結合されていない整頓されたフォーマットでデータが手元に届くように、データ入力や収集の手順を変更しましょう。

-   各変数はそれぞれ別の列でなければなりません。\
-   各観測値は、それぞれ別の行である必要があります。\
-   それぞれの値は、それぞれ別のセルに入力されていなければなりません。

**rio** パッケージの `import()` を使用した場合、マージされたセルの値は最初のセルに割り当てられ、それ以降のセルは空になります。

結合されたセルを処理するための一つの解決策は、**openxlsx** パッケージの `readWorkbook()` を使用してデータをインポートすることです。引数 `fillMergedCells = TRUE` を設定します。これにより、マージされたセルの値を、マージ範囲内のすべてのセルに入れることができます。

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

[警告：`readWorkbook()` で列名をマージすると、列名が重複してしまうので、手動で修正する必要があります。R は列名が重複するとうまく動作しません！手動による列名のクリーニングのセクションで説明したように、列の位置（例えば 5 列目）を参照し、列名を再設定することができます。]{style="color: red;"}

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 列の選択と並び替え

**dplyr** パッケージの `select()` を使って、残したい列を選択し、データフレーム内における列の順番を指定します。

[[**注意**]{.ul}**：**以下の例では、`linelist` データフレームを `select()` で変更して表示していますが、これはデモンストレーションのためであり、保存はされていないことに注意してください。変更された列名は、データフレームを `names()` にパイプすることで表示されます。]{style="color: orange;"}

ここでは、前処理パイプラインの現時点での [`linelist`]{style="color: orange;"} の全列名を表示しています。

```{r}
names(linelist)
```

### 列を保持 {.unnumbered}

**残しておきたい列のみを選択します。**

`select()` の中で、列の名前を引用符（" "）を使わずに指定します。列は、指定された順序でデータフレームに表示されます。存在しない列を入れた場合、R がエラーを返すことに注意してください（このような場合にエラーを出さないようにするには、後述の `any_of()` の使い方を参照してください）。

```{r}
# ラインリストのデータセットはselect()に渡され、name()は列名だけを表示する
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # 列名を表示する
```

### "tidyselect" ヘルパー関数 {#clean_tidyselect .unnumbered}

**tidyverse** パッケージに含まれる **tidyselect** パッケージのヘルパー関数は、保持や除外、または変換する列を簡単に指定するための関数であり、**dplyr** 系関数で列を選択する方法の基礎となっています。

例えば、列の順番を変更したい場合、`everything()` は「記載されていない他のすべての列」を意味する便利な関数です。以下のコードは、`date_onset` と `date_hospitalisation` の列をデータセットの最初（左）に移動させますが、それ以降の他の列はすべてそのままにします。`everything()` は空の括弧で書かれていることに注意してください。

```{r}
# date_onsetとdate_hospitalisationを先頭に移動させる。
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

以下に、`select()`、`across()`、`summary()` などの **dplyr** 系関数内で使える他の "tidyselect" ヘルパー関数を紹介します。

-   `everything()` - 記載されていない他のすべての列を指定します。\

-   `last_col()` - 最後の列を指定します。\

-   `where()` - すべての列に関数を適用し、TRUEとなるものを選択します。\

-   `contains()` - ある文字列を含む列を指定します。\

    -   例：`select(contains("time"))`\

-   starts_with() - 指定された接頭語を指定します。

    -   例：`select(starts_with("date_"))`\

-   `ends_with()`- 指定された接尾語を指定します。\

    -   例：`select(ends_with("_post"))`\

-   `matches()` - 正規表現（regex）を適用し指定します。\

    -   例：`select(matches("[pt]al"))`\

-   `num_range()` - x01、x02、x03 のような数値の範囲を指定します。\

-   `any_of()` - 関数内で使用した場合、指定する列が存在する場合は、その関数が適用され、存在しない場合は適用されず、エラーを表示しません。\

    -   例：`select(any_of(date_onset, date_death, cardiac_arrest))`\

さらに、複数の列を列挙する場合には `c()`、連続した列には `:`、反対の列には `!`、`AND` には `&`、`OR` には `|` などの通常の演算子が使用できます。

列の論理的な条件を指定したい場合は、`where()` を使用します。`where()` の中に関数を入れる場合は、関数の後に空の括弧は入れないでください。以下のコードは、 数値型データの列を選択します。

```{r}
# 数値型データの列を選択する
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

ある特定の文字列が含まれている列のみを選択したい場合は、`contains()` を使用します。 また、`ends_with()` や `starts_with()` を使用すると、より詳細な情報を得ることができます。

```{r}
# 特定の文字を含む列を選択する
linelist %>% 
  select(contains("date")) %>% 
  names()
```

さらに、`contains()` と同様の動作をする`matches()` は、括弧内の OR バー（\|）で区切られた複数の文字列などの正規表現を指定することができます（正規表現の詳細については、[文字列型データ](#characters-strings) の章を参照ください）。

```{r}
# 複数の文字に当てはまる列を検索する
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

[注意：指定した列名がデータセットに存在しない場合、エラーが返されてコードの処理が停止することがあります。存在するかどうかわからない列を指定したい場合は、`any_of()` を使用することをおすすめします。`any_of()` は、列の除外などの、特に否定的なれ列の選択をする場合において有用です。]{style="color: orange;"}

以下のコードでは、指定されている列のうち 1 つの列だけがデータセットに存在しますが、エラーは発生せず、コードは処理を停止することなく実行されます。

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### 列の除外 {.unnumbered}

データセットから除外したい列がある場合は、列名の前にマイナス記号（-）を付ける（例：`select(-outcome)`）、または以下のように列名のベクトルの前にマイナス記号（-）を付けて指定すると、除外できます。その他の列はすべて残ります。

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>%
     # date_onsetと、feverからvomitまでのすべての列を削除する
  names()
```

R の基本的な構文を使用し、NULLと定義して列を削除することもできます。例えば、以下のようになります。

```{r, eval=F}
linelist$date_onset <- NULL   # Rの基本的な構文で列を削除する
```

### 独立型 {.unnumbered}

`select()` は、パイプ内で使用するだけでなく、独立したコマンドとして使用することもできます。この場合、最初の引数は前処理したい元のデータフレームを指定します。

```{r}
# IDと年齢に関連した列を持つ新しいラインリストを作成する
linelist_age <- select(linelist, case_id, contains("age"))

# 列名の表示
names(linelist_age)
```

#### パイプチェーンに追加 {.unnumbered}

`linelist_raw` データセットには、`row_num`、`merged_header`、`x28` という必要のない列があり、前処理パイプラインの `select()` コマンドで削除する例を以下に示します。

```{r}
# パイプライン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################


# パイプラインを開始する
###########################
linelist <- linelist_raw %>%
    

     # 列名の標準化
    janitor::clean_names() %>% 
    

     # 列名を個別に変更
     
     　　　#新しい列名　　　　　　#既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # 上記は、すでに説明した上流側の処理手順
    #####################################################

 　 #列の除外
    select(-c(row_num, merged_header, x28))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 重複データの削除

重複したデータを削除する方法の詳細については、このハンドブックの [重複データの排除](#deduplication) の章を参照してください。本章では、重複した行の削除について、非常に簡単な例のみを紹介します。

**dplyr** パッケージの `distinct()` は、データフレーム内のすべての行をチェックし、重複していない行のみを残します。つまり、完全に重複している行をデータフレームから削除します。

重複する行をチェックする際には、列の範囲を指定できますが、デフォルトではデータフレーム内のすべての列が含まれます。[重複データの排除](#deduplication) の章にあるように、この列の範囲を調整して特定の列に関してのみ、重複した行があるかをチェックすることもできます。

以下の単純な例では、空のコマンド `distinct()` をパイプチェーンに追加するだけです。これにより、他の行と完全に同一である行がない（重複している行がない）ことが保証されます（データフレーム内のすべての列がチェックされます）。

まず、現時点の `linelist` データフレームには、全部で `nrow(linelist)` 行が含まれています。

```{r}
linelist <- linelist %>% 
  distinct()
```

上のコードを実行して重複削除すると、データフレームの行数は `nrow(linelist)` になります。他の行と完全に同一である行が削除されました。

以下では、パイプラインに `distinct()` コマンドを追加しています。

```{r}
# 前処理パイプライン(未加工データがクリーニングステップを経てパイプに送られる)
##################################################################################

# パイプラインを開始する
###########################
linelist <- linelist_raw %>%
    

     # 列名の標準化
    janitor::clean_names() %>% 
    
     # 列名を個別に変更
           # 新しい列名            # 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # 列の除去
    select(-c(row_num, merged_header, x28)) %>% 
  
    #上記は、すでに説明した上流側のクリーニング手順
    #####################################################
    
    # 重複の除去
    distinct()
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 列の作成と変換

　新しい列を追加したり、既存の列を修正したりするには、**dplyr**の関数 `mutate()`を使うことをお勧めします。

　以下は、`mutate()`を使って新しい列を作成する例です。構文は次のとおりです： `mutate(new_column_name = value or transformation)`

　Stataでは、これは`generate`コマンドに似ていますが、Rの`mutate()`は既存の列を修正するためにも使用できます。

### 新しい列の作成 {.unnumbered}

　新しい列を作成する最も基本的な`mutate()`コマンドは次のようになります。以下では、すべての行の値が10である新しい列`new_col`を作成します。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

　また、他の列の値を参照して、計算を行うこともできます。以下では、新しい列 `bmi`が作成され、各ケースのBody mass index（BMI）を格納しています。これは、列`ht_cm`と列`wt_kg`を使用して、BMI = kg/m\^2の式で計算されたものです。

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

　複数の新しい列を作成する場合は、それぞれをコンマで区切って改行します。以下は、**stringr**パッケージの `str_glue()`を使って他列の値を組み合わせたものなど、新しい列の例です（[Characters and strings](https://epirhandbook.com/en/characters-and-strings.html#characters-and-strings) のページを参照）。

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             #新しい列＝重複削/存在する他の列をコピー
    new_var_static = 7,                   # 新しい列＝全ての値が同じ
    new_var_static = new_var_static + 5,  # 列を上書きしたり、他の変数を使って計算したりすることがでる。
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") 
    # 新しい列 = 他の列の値を貼り付ける
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        
# デモ用に新しい列のみを表示
```

　新しい列を確認します。デモのために、新しい列とそれを作成するために使用された列のみが表示されています。

```{r message=FALSE, echo=F}
# ラインリストのデータを表にして表示する。
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***ヒント:*** `mutate()`のバリエーションとして、`transmute()`という関数があります。この関数は、`mutate()`と同じように新しい列を追加しますが、括弧の中に書かれていない他のすべての列を削除または取り除きます。]{style="color: darkgreen;"}

```{r, eval=F}
# HIDDEN FROM READER
# removes new demo columns created above

# linelist <- linelist %>% 
#   select(-contains("new_var"))
```

### 列クラスの変換 {.unnumbered}

　日付、数字、理論値（TRUE/FALSE）を含む列は、正しく分類されれば期待通の動きをします。文字クラスの"2"と数字クラスの2は異なります。

　インポートコマンド中に列クラスを設定する方法もありますが、扱いにくい場合が多いです。オブジェクトや列のクラスを変換する方法については、[R Basics](https://epirhandbook.com/en/r-basics.html#r-basics) のオブジェクトクラスの項を参照してください。

　まず、重要な列について、正しいクラスであるかどうかのチェックを行ってみましょう。これは最初に`skim()`を実行したときに確認しました。

　現在、`age`の列のクラスはcharacter型です。定量的な分析を行うためには、これらの数字が数値として認識される必要があります!

```{r}
class(linelist$age)
```

`date_onset`列のクラスも文字です! 分析を行うには、これらの日付を日付として認識する必要があります。

```{r}
class(linelist$date_onset)
```

　これを解決するには、mutate()の機能を使って、変換で列を再定義します。列をそれ自体として定義し、異なるクラスに変換します。ここでは、基本的な例として、列`age`がクラスNumeric型に変換または適正化します。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

　同様に、`as.character()`や`as.logical()`を使うこともできます。factor型に変換するには、**base R**の`factor()`やforcatsの`as_factor()`が使えます。詳しくは [Factors](https://epirhandbook.com/en/factors.html#factors) のページをご覧ください。

Date型 への変換には注意が必要です。いくつかの方法は [Working with dates](https://epirhandbook.com/en/working-with-dates.html#working-with-dates-1) のページで説明されています。通常、変換が正しく行われるためには、未加工の日付値がすべて同じ形式である必要があります (例: "MM/DD/YYYY"、または "DD MM YYYY")。クラスの日付に変換した後、データをチェックして、各値が正しく変換されたことを確認してください。

### グループ化されたデータ {.unnumbered}

　 データフレームがすでにグループ化されている場合（[Grouping data](https://epirhandbook.com/en/grouping-data.html#grouping-data)のページを参照）、`mutate()`の動作はグループ化されていない場合とは異なるかもしれません。`mean()`、`median()`、`max()`などの要約関数は、すべての行ではなく、グループごとに計算されます。

```{r, eval=F}
# 全行の平均値で正規化された年齢
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# 年齢を病院グループの平均値で正規化
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

　グループ化されたデータフレームでの `mutate ()`の使用については、この [tidyverse mutate documentation](https://dplyr.tidyverse.org/reference/mutate.html) ドキュメントで詳しく説明しています。

### 複数のカラムの変換 {#clean_across .unnumbered}

　簡潔なコードを書くために、同じ変換を複数の列に一度に適用したいことがあります。**dplyr**パッケージ（ **Tidyverse** パッケージにも含まれています）の `across()` 関数を使用して、変換を複数の列に一度に適用することができます。 `across()`はどの **dplyr** 関数で使用することができますが、一般的には`select()`、`mutate()`、`filter()`、`summarise()`内で使用されます。`summarise()`にどのように適用されるかは、[Descriptive tables](https://epirhandbook.com/en/descriptive-tables.html#descriptive-tables) のページを参照してください。

　引数`.cols =`には列を指定し、`.fns =`には適用する関数を指定します。`.fns`関数に与える追加の引数は、カンマの後に含めることができます。

#### `across()`列選択 {.unnumbered}

　引数`.cols =` に列を指定します。 個別に名前を付けることもできますし、"tidyselect" ヘルパー関数を使用することもできます。関数を`.fns =`に指定します。 以下に示す関数機能を使用すると、関数はその括弧（ ）なしで記述することに注意してください。

ここでは、`as.character()`という変換が、 `across()`で指定された特定の列に適用されています。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

　"tidyselect"ヘルパー関数は、列の指定する際に参考になります。これらの関数は上記の列の選択と並び替えのセクションで詳述されており、次のものが含まれます：`everything()`、`last_col()`、`where()`、`starts_with()`、`ends_with()`、`contains()`、`matches()`、`num_range()`、`any_of()`。

ここでは、すべての列をcharacter型に変更する例を示します。

```{r, eval=F}
#全ての列をcharactor型に変換する。
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

　名前に "date "という文字列が含まれるすべての列を文字に変換します（カンマと括弧の配置に注意してください）。

```{r, eval=F}
#全ての列をcharactor型に変換する。
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

　以下は、現在POSIXct型（タイムスタンプを示す未加工のdatetime型）である列、つま `is.POSIXct()`関数の評価値が`TRUE`である列を変換する例です。次に、これらの列に `as.Date()`という関数を適用して、通常のDate型に変換したいと思います。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

-   is.POSIXctがTRUEまたはFALSEに評価されるように、`across()`内では`where()`という関数も使用していることに注意してください。

-   `is.POSIXct()`は **lubridate** パッケージのものであることに注意してください。`is.character()`、`is.numeric()`、`is.logical()`のような他の類似した"is"関数は **base R** のものです。

#### `across()`関数 {.unnumbered}

`across()`に関数を提供する方法の詳細については、`?across`のドキュメントをお読みください。要約すると、列に対して実行する関数を指定する方法はいくつかあり、独自の関数を定義することもできます。

-   関数名のみを指定することができます（例：`mean`または `as.character`）。

-   関数を **purrr** スタイルで提供することができます（例：`~ mean(.x, na.rm = TRUE))`( [本ページ](https://epirhandbook.com/en/iteration-loops-and-lists.html#iteration-loops-and-lists)参照 )

-   リストを指定することで，複数の関数を指定することができます（例：`list(mean = mean, n_miss = ~ sum(is.na(.x)))`）．

-   複数の関数を指定した場合は、入力列ごとに複数の変換後の列が返され、`col_fn`という形式で一意の名前が付けられます。新しい列の名前を調整するには、`.names =` 引数で**glue**の構文（[Characters and strings](https://epirhandbook.com/en/characters-and-strings.html#characters-and-strings) のページを参照）を使用します。`{.col}`と`{.fn}`は入力列と関数の省略形です。

### `coalesce()` {.unnumbered}

　この **dplyr** 関数は、各位置で最初の欠損値ではない値を見つけます。この関数は、指定された順序で、取得可能な最初の値で欠損値を埋めます。

　ここでは、データフレーム以外の例を示します。2つのベクトルがあるとします。1つは患者の発見された村、もう1つは患者の居住地の村です。coalesceを使って、各インデックスの最初の非欠損値を選ぶことができます。

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    #表示
```

　これは、データフレームの列を指定した場合にも同じように動作します。この関数は、各行ごとに、指定した列の中で最初に欠落していない値を新しい列の値として割り当てます（指定した順に）。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

　これは "row-wise "演算の一例です。より複雑な行単位の計算については、下記の "行単位の計算" の項をご覧ください。

### 累積計算 {.unnumbered}

　データフレーム行を計算し、その時点までの累積和/平均/最小/最大などを列に反映させたい場合は、以下の関数を使用します。

cumsum()は、以下のように、累積和を返します。

```{r}
sum(c(2,4,15,10))     # 1つの数字のみを返す。
cumsum(c(2,4,15,10))  # 各ステップでの累積和を返す。
```

　これは、データフレームで新しい列を作るときに使用できます。例えば、アウトブレイクにおける1日あたりの累積症例数を計算するには、次のようなコードを考えます。

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # 症例ラインリスト 
  count(date_onset) %>%                 #一日当たりの行数をカウント 　　
  mutate(cumulative_cases = cumsum(n))  #累積の新しい列
```

以下は、最初の10行です。

```{r}
head(cumulative_case_counts, 10)
```

　エピカーブで累積罹患率をプロットする方法については、[Epidemic curves](https://epirhandbook.com/en/epidemic-curves.html#epidemic-curves) のページを参照してください。

関連項目： `cumsum()`, `cummean()`,`cummin()`, `cummax()`, `cumany()`, `cumall()`

### R の基本パッケージ **base** の使い方 {.unnumbered}

**base** Rを使って新しい列を定義する（または列を再定義する）。新しい列（または修正する列）にデータフレームの名前を\$でつないで書きます。代入演算子`<-`を使って新しい値を定義します。**base** R を使用する際には、毎回、列名の前にデータフレーム名を指定しなければならないことを覚えておいてください（例：dataframe\$column ）。ここでは、**base** R を使って`bmi`カラムを作成する例を示します。

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

### パイプチェーンへの追加 {.unnumbered}

**以下では、パイプチェーンに新しい列を追加し、いくつかの型を変換しています。**

```{r }
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################


# パイプチェーンのクリーニング開始
###########################
linelist <- linelist_raw %>%
    
　　# 列カラム名の構文の標準化
    janitor::clean_names() %>% 
    
     #手動で列名を変更

     　　　#　新しい列名　　　　　　#既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    

　　#　列の除去
    select(-c(row_num, merged_header, x28)) %>% 
  
　　#重複削除
    distinct() %>% 
  
    #  上記は、すでに説明した上流側のクリーニング手順
    ###################################################
　　#新しい列の追加
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
　　#列の型を変換
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```

## 値の再定義

値を再定義（変更）する必要があるいくつかの方法があります。

-   特定の値を編集する場合（例：日付の年号や書式が間違っている場合など）。

-   同じ綴りでない値を調整する場合。

-   カテゴリー値の新しい列を作成する場合。

-   数値カテゴリーの新しい列を作成する（例：年齢カテゴリー）。

### 特定の値 {.unnumbered}

　値を手動で変更するには、`mutate()`関数の中の`recode()`関数を使用します。

　データの中に意味のない日付（例："2014-14-15"）があるとします。未加工のソースデータの中で手動で日付を修正することもできますし、`mutate()`と `recode()`を介してクリーニングパイプラインに変更を書き込むこともできます。後者の方がより透明性が高く、分析を理解しようとする他者や同じように分析しようとする人にとって再現性があります。

```{r, eval=F}
#不正な値の修正　　　　　　　　　　　　　　#既存の値　　　　　#新しい値
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

　上記の`mutate()`の行は、次のように読むことができます。OLD VALUE が NEW VALUE に変更されるように再定義された列 `date_onset`と同じになるように列date_onsetを変異させる "と読めます。`recode()`のこのパターン(OLD = NEW)は、ほとんどのRのパターン(new = old)とは逆であることに注意してください。Rの開発コミュニティでは、この点の修正に取り組んでいます。

**ここでは、1つの列の中の複数の値を再定義する別の例を紹介します。**

`linelist`では、列 "hospital "の値をクリーンアップする必要があります。いくつかの異なる記載があり、多くの欠損値があります。

```{r}
table(linelist$hospital, useNA = "always")  
 # 欠損値を含むすべてのユニークな値のテーブルを表示。
```

　以下の`recode()`コマンドは、列 "hospital "を現在の列 "hospital "として再定義しますが、指定されたrecodeの変更があります。それぞれの後にカンマを忘れないでください。

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # 参照　　　　: 既存 = 新
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```

　現在、 `hospital`のスペルが修正され、統合されているのがわかります。

```{r}
table(linelist$hospital, useNA = "always")
```

[**ヒント**：等号の前後のスペースの数は関係ありません。コードを読みやすくするために、すべての行またはほとんどの行で = を揃えてください。また、ハッシュ化されたコメント行を追加して、どちらが古いか、どちらが新しいかを将来の読み手に明確にすることも検討してください。]{style="color: darkgreen;"}

[**ヒント**：データセットの中に空白文字の値が存在することがあります（R の missing の値である NA として認識されません）。この値を参照するには、スペースを空けずに2つのクォーテーションマーク（""）を使用します。]{style="color: darkgreen;"}

### 論理条件 {.unnumbered}

以下では、論理条件と条件を使って列の値を再定義する方法を示します。

-   単純な論理条件には`replace()`、`ifelse()`、`if_else()`を使う

-   より複雑な論理条件には`case_when()`を使う

### シンプルな論理条件 {.unnumbered}

#### `replace()` {.unnumbered}

`replace()`は**base** Rの関数で、論理条件を使って変更する行を指定します。一般的な構文は次のとおりです。

`mutate(col_to_change = replace(col_to_change, criteria for rows, new value))`です。

`replace()`を使用する一般的な状況としては、一意の行識別子を使用して、1つの行の1つの値だけを変更する場合です。下の例では、`case_id`が "2195 "である行で、性別を "Female "に変更しています。

```{r, eval=F}
# 例：ある特定の観測データの性別を "Female "に変更する。
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

　Rの基本的な構文と索引括弧[ ]を使った同等のコマンドは以下の通りです。データフレームの `linelist`の列 `gender`の値を（`linelist`の列 `case_id`の値が'2195'である行について）'Female'に変更する"と読めます。

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```

#### `ifelse()` と `if_else()` {.unnumbered}

　 簡潔な論理条件のためのツールとして、`ifelse()`とそのパートナーである`if_else()`があります。しかし、ほとんどの場合、再定義のためには`case_when()`（以下に詳述）を使ったほうがわかりやすいでしょう。これらの"if else"コマンドは、`if`と`else`のプログラミング文を簡略化したものです。一般的な構文は次のとおりです： `ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)`

　下の例では、`source_known`という列が定義されています。ある行の列 `source`の値が欠損していなければ、その値は "known" に設定されます。sourceの値が欠落している場合、`source_known`の値は "unknown " に設定されます。

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

`if_else()`は、日付を扱う **dplyr** の特別バージョンです。真の値が日付の場合、"偽"の値も日付でなければならないことに注意してください。そのため、単に NA ではなく NA_real\_ という特別な値を使用しています。

```{r, eval=F}
#  患者が死亡していない場合はNAとなる死亡日列を作成。
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**ifelseコマンドをたくさん並べるのは避けましょう...**代わりに`case_when()`を使ってください！`case_when()`はずっと読みやすく、エラーも少なくなります。

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

　データフレーム以外で、コード内で使用するオブジェクトの値を切り替えたい場合は、**base** R の`switch()`の使用を検討してください。

### 複雑な論理条件 {#clean_case_when .unnumbered}

　多数の新しいグループに再定義する場合や、複雑な論理条件文を使って値を再定義する必要がある場合は、**dplyr** の `case_when()`を使用します。この関数は、データフレーム内のすべての行を計算し、その行が指定された基準を満たしているかどうかを評価して、正しい新しい値を割り当てます。

`case_when()`コマンドは、右手側(RHS)と左手側(LHS)を"チルダ"～で区切ったステートメントで構成されています。各ステートメントの左側には論理条件が、右側には準拠値が記述されています。ステートメントはコンマで区切られています。

例えば、ここでは`age`と`age_unit`の列を利用して`age_years`の列を作成しています。

```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # 年齢が年単位の場合
            age_unit == "months" ~ age/12,    # 年齢が月単位の場合
            is.na(age_unit)      ~ age,       #年齢の単位が見つからない場合は、年を仮定
            TRUE                 ~ NA_real_)) #その他の状況では、不足分を割り当る。
```

　データの各行が計算されるとき、基準は `case_when()`ステートメントが書かれた順に、上から下へと適用/評価されます。ある行で一番上の基準が `TRUE`と評価された場合、RHSの値が割り当てられ、残りの基準はその行では確認されません。したがって、最も明確な基準を最初に書き、最も一般的な基準を最後に書くのがよいでしょう。

　このようにして、最後の文では、左側に`TRUE`を置くことで、前の基準のどれにも当てはまらない行を捕捉することができます。この文の右側には、 "check me!" や missing のような値を割り当てることができます。

[要注意：右辺のVvalues はすべて同じクラスでなければなりません。欠落（NA）を割り当てるには、`NA_character_`、`NA_real_`（数値やPOSIXの場合）、`as.Date(NA)`など、NAの特別なバリエーションを使用する必要があるかもしれません。詳しくは[Working with dates](https://epirhandbook.com/en/working-with-dates.html#working-with-dates-1)をご覧ください]{style="color: red;"}

### 欠損値 {.unnumbered}

　以下は、データクリーニングの観点から欠損値を処理するための特別な関数です。

　欠損値の識別と処理に関するより詳細なヒントは、[Missing data](https://epirhandbook.com/en/missing-data.html#missing-data) のページを参照してください。例えば、論理的に欠損をテストする`is.na()`関数などです。

**`replace_na()`**

欠損値（NA）を"Missing"などの特定の値に変更するには、`mutate()`内の**dply**r関数`replace_na()`を使用します。これは、上記の`recode`と同じ方法で使用されることに注意してください 。変数の名前は`replace_na()`内で繰り返されなければなりません。

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

**fct_explicit_na()**

　これは、**forcats** パッケージの関数です。**forcats** パッケージはFactor型の列を扱います。ファクターは、`c("First", "Second", "Third")`のような順序付きの値を扱うためのRの方法であり、表やプロットに表示される値（病院など）の順序を設定します。[Factors](https://epirhandbook.com/en/factors.html#factors)のページを参照してください。

データがFactor型で、`replace_na()`を使ってNAを "Missing "に変換しようとすると、次のようなエラーが表示されます： `invalid factor level, NA generated.` 因子の可能なレベルとして定義されていない "Missing" を値として追加しようとしたため、拒否されます。

この問題を解決する最も簡単な方法は、forcats の関数`fct_explicit_na()`を使用することです。この関数は、列をFactor型に変換し、NA値を文字"(Missing)"に変換します。

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

　よりゆっくりとした方法としては、`fct_expand()`を用いてFactor型を追加し、その後、欠損値を変換する方法があります。

**`na_if()`**

　特定の値を NA に変換するには、**dplyr** の `na_if()`を使います。以下のコマンドは `replace_na()`の逆の操作を行います。以下の例では、列 `hospital` の "Missing" の値はすべて `NA`に変換されます。

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

　注意： `na_if()`は論理的条件（例：" "all values \> 99""）には使用できません。これには`replace()`または`case_when()`を使用してください。

```{r, eval=F}
#40以上の温度をNAに変換。 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# 2000年1月1日以前の発症日を欠損に変換する。
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

### クリーニング辞書 {.unnumbered}

　Rパッケージ **linelist** とその関数 `clean_variable_spelling()`を使って、データフレームをクリーニング辞書でクリーニングします。 **linelis**t は[RECON](https://github.com/reconhub/linelist) - the R Epidemics Consortiumによって開発されたパッケージです。

1.  3つの列でクリーニング辞書を作成します。

-   from "カラム（不正な値）

-   to "カラム（正しい値）

-   変更を適用する列を指定する列（または、すべての列に適用する場合は".global"）。

注意：.globalの辞書項目は、列固有の辞書項目によって上書きされます。

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```

2)  この例題は、[Download handbook and data](https://epirhandbook.com/en/download-handbook-and-data.html#download-handbook-and-data)のページにある手順でダウンロードできます。

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3)  未加工のラインリストを `clean_variable_spelling()`に渡し、wordlists = クリーニング辞書データフレームに指定します。spelling_vars = 引数は、辞書のどの列を参照するかを指定するために使用することができます（デフォルトでは3番目）。また、辞書をすべてのcharactor列とfactor列に適用するためにNULLを設定することもできます。この関数の実行には時間がかかることに注意してください。

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        
     #列名を含むdict列、デフォルトではdictの3番目の列になる。
  )
```

　右側にスクロールすると、値がどのように変化したかがわかります。特に性別（小文字→大文字）や、すべての症状の列がYes/noから1/0に変化しています。

```{r message=FALSE, echo=F}
# ラインリストのデータを表として表示する
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

　クリーニング辞書の列名は、クリーニングスクリプトのこの時点での名前に対応していなければならないことに注意してください。詳細については、linelistパッケージの[online reference for the linelist package](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html)を参照してください。

#### パイプチェーンへの追加 {.unnumbered}

以下では、いくつかの新しい列と列変換がパイプチェーンに追加されています。

```{r}
#クリーニングパイプチェーン (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################

# パイプチェーンの処理開始
###########################
linelist <- linelist_raw %>%
    
 
     # 列名の構文の標準化
    janitor::clean_names() %>% 

     # 手動で列名を変更
           # 新しい列名             # 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
     # 列の除去
    select(-c(row_num, merged_header, x28)) %>% 
  
　　#　重複除去
    distinct() %>% 
  
    # add column
　　#　列を追加
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

      # 列の型を変換
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
  
     
     # 列の追加: 入院の遅れ
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
     # 上記は、すでに説明した上流側のクリーニング方法です。
   ###################################################

　　# 病院の列の値をきれいにする。
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

       # age_yearsカラムの作成(from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 数値カテゴリー {#num_cats}

　ここでは、数値列からカテゴリを作成するための特別なアプローチを説明します。一般的な例としては、年齢のカテゴリー、検査値のグループなどがあります。ここでは、以下について説明します。

-   `age_categories()`( **epikit** パッケージより)

-   `cut()`, base Rより

-   `case_when(`)

-   `quantile()`と`ntile()`を使った分位値分割

### レビュー分布 {.unnumbered}

この例では、`age_years`列を使って`age_cat`列を作成します。

```{r}
#linelist変数ageの列をチェックする。
class(linelist$age_years)
```

　まず、データの分布を調べて、適切なカットポイントを作ります。[ggplot basics](https://epirhandbook.com/en/ggplot-basics.html#ggplot-basics) のページをご覧ください。

```{r, out.height='50%'}
# 分布を調べる。
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

[**注意**：数値の変数型が"character"としてインポートされることがあります。これは、値の一部に数字以外の文字が含まれている場合に発生します。例えば、年齢を"2ヶ月"と入力した場合や、（Rのロケール設定にもよりますが）小数点以下の位置にコンマが使用されている場合などです（例："4.5"は4年半の意味）。]{style="color: orange;"}

<!-- ======================================================= -->

### `age_categories()` {.unnumbered}

**epikit** パッケージでは、`age_categories()`関数を使って、数値列の分類やラベル付けを簡単に行うことができます（注：この関数は、年齢以外の数値変数にも適用できます）。その結果、出力される列は自動的に順序付けられたカテゴリーとなります。

必要な入力は以下の通りです。

-   数字のベクトル（列）

-   `breakers =` 引数 - 新しいグループのブレークポイントの数値ベクトルを提供する。

まず、最も簡単な例を示します。

```{r}
# Simple example
# 簡単な例
################
pacman::p_load(epikit)                    　#パッケージのロード

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             
         　　　　　　　　　　　　　　　　　# 新しい列の作成
      age_years,                            # グループを作るための数値列
      breakers = c(0, 5, 10, 15, 20,        # ブレークポイント
                   30, 40, 50, 60, 70)))

# テーブルを表示
table(linelist$age_cat, useNA = "always")
```

　指定したブレーク値は、デフォルトでは下限含めます。つまり、"上位"のグループに含まれ、グループが下/左に"開いて"いる状態になります。下図のように、各ブレーク値に1を加えることで、上/右で開いたグループにすることができます。

```{r}
# 同じカテゴリーの上端を含める
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

#　テーブルを表示
table(linelist$age_cat, useNA = "always")
```

`separator =` で、ラベルの表示方法を調整できます。 デフォルトは "-" です。

`ceiling =`で、上位の数字の扱い方を調整できます。上限値を設定するには `ceiling = TRUE` とします。この使用方法では、提供された最も高いブレーク値は"上限"であり、カテゴリー"XX+"は作成されません。ブレーク値の上限（または定義されている場合は上限＝）を超える値は、`NA`に分類されます。以下は、`ceiling = TRUE`の例で、XX+のカテゴリーはなく、70（最も高いブレーク値）を超える値は`NA`として割り当てられます。

```{r}
# 上限をTRUEに設定した場合
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 is ceiling, all above become NA

# テーブルを表示
table(linelist$age_cat, useNA = "always")
```

また、`breakers＝`の代わりに、`lower＝`、`upper＝`、`by＝`のすべてを指定することもできます。

-   `lower =`考慮したい最低の数値 - デフォルトは0

-   `upper =`考慮したい最も高い数値

-   `by =`グループ間の年の数

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# テーブルの表示
table(linelist$age_cat, useNA = "always")
```

詳細は、この関数のヘルプページをご覧ください（Rコンソールで`?age_categories`と入力してください）。

<!-- ======================================================= -->

### `cut()` {.unnumbered}

`cut()`は`age_categories()`に代わる R のベースとなるものですが、この処理を簡単にするために `age_categories()`が開発された理由がわかります。`age_categories()`との注目すべき違いは以下のとおりです。

-   別のパッケージをインストール/ロードする必要がない。

-   グループが右か左に開いているか閉じているかを指定できる。

-   正確なラベルを自分で用意する必要がある。

-   一番下のグループに"0"を入れたい場合は、このように指定する必要がある。

`cut()`の基本的な構文は、まずカットしたい数値列 `(age_years)`を指定し、次に breaks の引数として分割ポイントの数値ベクトル`c()`を指定します。`cut()`を使用すると、結果として列は順序付けられたカテゴリーとなります。

　デフォルトでは、右/上側が"オープン"で包括的（左/下側が"クローズ"で排他的）になるように分類されます。これは、`age_categories()`関数とは逆の動作です。デフォルトのラベルでは"(A, B] "という表記が使われていますが、これは"Aは含まれないがBは含まれる"という意味です。`right = TRUE`という引数を与えることで、この動作を逆にします。したがって、デフォルトでは、"0 "の値は低いグループから除外され、`NA`に分類されます。"0 "の値は、乳幼児が0歳としてコード化される可能性があるので、注意が必要です。これを変更するには、引数 `include.latest = TRUE`を追加して、"0 "の値が最低グループに含まれるようにします。この場合、自動的に作成される低いカテゴリーのラベルは "[A],B]" となります。なお、`include.latest = TRUE`を指定し、かつ`right = TRUE`を指定した場合、含まれるのは最低値ではなく最高値の分割ポイント値とカテゴリーに適用されます。

`labels =` 引数を使って、カスタマイズされたラベルのベクトルを提供することができます。これらは手作業で書かれているので、正確さには十分注意してください。後述するように、クロス集計を用いて作業を確認してください。

`age_years`に`cut()`を適用して、新しい変数`age_cat`を作成した例を以下に示します。

```{r}
# 年齢という数字の変数を切り取って新しい変数を作る。
# 下限値のブレイクは除外されるが、上限のブレイクは各カテゴリーに含まれる。
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         
      ))　　　　　　　　　　　　　　# 一番下のグループに0を入れる。

# グループごとの観測値の数を集計。
table(linelist$age_cat, useNA = "always")
```

**作業を確認してください!!!** 数値列とカテゴリー列をクロス集計して、各年齢値が正しいカテゴリーに割り当てられていることを確認します。境界値の割り当てを検証します（例：隣接するカテゴリーが 10-15 と 16-20 の場合、15の値）。

```{r}
# 数値列とカテゴリー列のクロス集計
table("Numeric Values" = linelist$age_years,   # 分かりやすくするために、表の中に名前を入れる
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # NA値の検証を忘れずに
```

**`NA`値の再ラベル付け**

`NA`値に "Missing "などのラベルを付けたい場合があります。新しい列はFactor型(制限付き値)なので、この値は拒否されるので、単純に`replace_na()`で変異させることはできません。代わりに、[Factors](https://epirhandbook.com/en/factors.html#factors) ページで説明されているように、`forcats`の `fct_explicit_na()`を使用してください。

```{r}
linelist <- linelist %>% 
  
   # cut()すると、Factor型スのage_catが自動的に作成される。 
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # 欠損値を明示する
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  
  )    # ラベルを指定することができる。

# テーブルからビューカウント
table(linelist$age_cat, useNA = "always")
```

**切れ目やラベルを素早く作る**

　ベクトルの改行やラベルを素早く作成するには、以下のような方法があります。`seq()`や`rep()`については、[basics](https://epirhandbook.com/en/r-basics.html#r-basics) のページを参照してください。

```{r, eval=F}
# 0から90までのブレークポイントを5で割る。
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# デフォルトのcut()の設定を前提に、上記のカテゴリのラベルを作成する。
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# 両方のベクトルが同じ長さであることを確認する。
length(age_seq) == length(age_labels)
```

`cut()`の詳細については、Rコンソールで`?cut`と入力して、ヘルプページを参照してください。

### 分位値ブレーク {.unnumbered}

　一般的な理解では、"クォンタイル"または"パーセンタイル"は、通常、値の割合が下になる値を指します。例えば、`linelist`の年齢の95パーセンタイルは、年齢の95%が該当する年齢になります。

しかし、一般的には、"4分位値"や"10分位値"は、データのグループを4つまたは10のグループに均等に分けたものを指すことがあります（グループよりも分割ポイントが1つ多いことに注意してください）。

　分位点を取得するには、Rの基本パッケージである **stats** の `quantile()`を使用します。データセットの列などの数値ベクトルと、0から1.0までの確率の数値ベクトルを指定します。分割ポイントは、数値ベクトルとして返されます。`?quantile`を入力すると、統計的手法の詳細を調べることができます。

入力された数値ベクトルに欠損値がある場合は、`na.rm = TRUE` を設定することをお勧めします。

`names = FALSE`を設定すると、名前のない数値ベクトルが得られます。

```{r}
quantile(linelist$age_years,           　　# 演算する数値ベクトルを指定。
  probs = c(0, .25, .50, .75, .90, .95),  # 欲しいパーセンタイルを指定。
  na.rm = TRUE)                         　# 欠損値を無視する。 
```

`quantile()`の結果は、`age_categories()`や`cut()`の分割ポイントとして使用できます。以下では、`cut()`を使って新しい列`deciles`を作成し、`age_years`に対して`quantiles()`を使って区切りを定義しています。**janitor**の`tabyl()`を使って結果を表示し、パーセンテージを見ることができます（[Descriptive tables](https://epirhandbook.com/en/descriptive-tables.html#descriptive-tables) ページを参照）。各グループで正確に10%ではないことに注意してください。

```{r}
linelist %>%                              #linelistから開始。
  mutate(deciles = cut(age_years,        # 新しい列を作る。 age_years列をcut()でdecileに格納。
    breaks = quantile(                   # quantile()を使ってカットオフを定義する。
      age_years,                         # age_yearsの操作。
      probs = seq(0, 1, by = 0.1),       # 0.0から1.0へ0.1倍。
      na.rm = TRUE),                  　 # 欠損値を無視する
    include.lowest = TRUE)) %>%          # cut()でage 0を含む。
  janitor::tabyl(deciles)                # 表示するテーブルへのパイプ。
```

### 均等な大きさのグループ {.unnumbered}

　数値グループを作成するもう1つのツールは、**dplyr** の関数 `ntile()`で、データをn個の均等な大きさのグループに分けようとします。数値ベクトルとグループの数を指定します。作成される新しい列の値は、グループの"番号"（例：1から10）だけで、`cut()`を使ったときのように値の範囲そのものではありません。

```{r}
# ntile()でグループを作る。
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# グループ別の数と割合の表を作る。
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# 範囲を示すために最小値と最大値を添付する。
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# 結合して表示 - 値が複数のグループに存在することに注意。
left_join(ntile_table, ntile_ranges, by = "even_groups")
```

<!-- ======================================================= -->

### `case_when()` {.unnumbered}

**dplyr**の関数 `case_when()`を使って数値列からカテゴリを作成することは可能ですが、**epikit** の`age_categories()`や`cut()`を使った方が、自動的に順序付けられた要素を作成してくれるので、より簡単です。

`case_when()`を使用する場合は、このページの"値の再定義"で前述した適切な使用方法を確認してください。また、すべての右辺の値は同じクラスでなければならないことに注意してください。したがって、右辺の値を`NA`にしたい場合は、"Missing "と書くか、特別な`NA`値`NA_character_`を使用する必要があります。

### パイプチェーンへの追加 {.unnumbered}

以下では、2つのカテゴリー化された年齢列を作成するコードを、クリーニング・パイプ・チェーンに追加しています。

```{r}
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################


# パイプチェーンのクリーニング開始
###########################
linelist <- linelist_raw %>%
    
    #列名の構文の標準化
    janitor::clean_names() %>% 

     
     # 手動で列名を変更
           # 新しい列名             # 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
     # 列を削除
    select(-c(row_num, merged_header, x28)) %>% 
  
     # 重複除去
    distinct() %>% 

     # 列の追加
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
     # 列の型を変換
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
     # 列の追加:入院の遅延
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
     # 病院の列の値をきれいにする
    mutate(hospital = recode(hospital,
                      　　　　　　　# 既存 = 新
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

     # age_yearsカラムの作成（from age and age_unit）
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 

     # 上記は、すでに説明した上流側のクリーニング方法です
    ###################################################   
    mutate(
         # 年齢別カテゴリー: 慣習
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # 年齢カテゴリー 0～85歳までの5段階
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

<!-- ======================================================= -->

## 列の追加

### 一行ずつ {.unnumbered}

　手作業で一行ずつ追加するのは面倒ですが、**dplyr** の `add_row()`を使えば可能です。各列は1つの型（factor型、numeric型、logic型など）の値のみを含む必要があることを覚えておいてください。そのため、行の追加にはこれを維持するための微妙な差異が必要です。

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

`.before`と`.after.`を使って、追加したい行の配置を指定します。`.before = 3`は、新しい行を現在の3行目の前に配置します。デフォルトの動作では、行を最後に追加します。指定されていない列は空欄（NA）になります。

　新しい**行番号**は奇妙に見えるかもしれませんが（"...23"）、既存の行の行番号は**変更されています**。そのため、このコマンドを2回使用する場合は、挿入を慎重に検討/テストしてください。

用意したクラスが外れている場合は、以下のようなエラーが表示されます。

    Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.

(日付の値を持つ行を挿入する際には、as.Date("2020-10-10")のようにas.Date()という関数で日付を囲うことを忘れないでください)。

### 行の結合 {.unnumbered}

あるデータフレームの行を別のデータフレームの下部に結合してデータセットを結合するには、**dplyr**の `bind_rows()`を使用します。これについては、[Joining data](https://epirhandbook.com/en/joining-data.html#joining-data) のページで詳しく説明しています。

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 行のフィルタリング

　列を整理し、値を再定義した後の典型的なクリーニングステップは、**dplyr**の動詞 `filter()`を使ってデータフレームの特定の行をフィルタリングすることです。

`filter()`では、データセット内のある行を抜き出すために`TRUE`でなければならない論理を指定します。以下では、単純な論理条件と複雑な論理条件に基づいて行をフィルタリングする方法を示します。

<!-- ======================================================= -->

### 単純なフィルタ {.unnumbered}

　この単純な例では、論理的な条件を満たすように行をフィルタリングした上で、データフレームのラインリストを自分自身として再定義します。括弧内の論理条件が評価されて`TRUE`となる行のみが保持されます。

この例では、論理条件は`gender == "f "`で、列`gender`の値が`"f "`に等しいかどうかを問いています（大文字小文字を区別します）。

フィルタを適用する前の `linelist`の行数は `nrow(linelist)`です。

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # 性別が "f "である行だけを残す。
```

フィルタを適用した後の `linelist`の行数は`linelist %>% filter(gender == "f") %>% nrow()` となります。

### 欠損値のフィルタリング {.unnumbered}

　欠損値のある行をフィルタリングしたいというのはよくあることです。`filter(!is.na(column) & !is.na(column))`と書きたい気持ちを抑えて、代わりにこの目的のためにカスタマイズされた **tidyr** の関数、`drop_na()`を使いましょう。空の括弧をつけて実行すると、欠損値のある行を削除します。あるいは、欠落を評価する特定の列の名前を指定したり、[上述の](https://epirhandbook.com/en/cleaning-data-and-core-functions.html#clean_tidyselect)"tidyselect "ヘルパー関数を使用することもできます。

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  
# case_idやage_yearsの値が欠損している行を削除する。
```

　データの欠落を分析・管理するための多くのテクニックについては、[Missing data](https://epirhandbook.com/en/missing-data.html#missing-data) のページをご覧ください。

### 行番号によるフィルタリング {.unnumbered}

　データフレームや Tibble では、各行には通常"行番号"があり、R Viewerで見ると最初の列の左側に表示されます。これは、それ自体はデータの真の列ではありませんが、`filter()`のステートメントで使用することができます。

"行番号"に基づいてフィルタリングするには、論理的なフィルタリング文の一部として、**dplyr**の関数`row_number()`を開いた括弧で囲んで使用します。多くの場合、以下のように、論理的なステートメントの一部として、`%in%`演算子と数値の範囲を使用します。最初のN行を表示するには、特別な **dplyr** 関数 `head()`を使用することもできます。

```{r, eval=F}
# 最初の100行を表示。
linelist %>% head(100)     
# またはtail()を使って最後のn行を見る。

# 5列目のみ表示。
linelist %>% filter(row_number() == 5)

# 2行目から20行目までと、3つの特定の列を見る。
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

また、データフレームを **tibble** 関数 `rownames_to_column()`にパイプすることで、行番号を真の列に変換することができます（括弧の中には何も入れないでください）。

<!-- ======================================================= -->

### 複雑なフィルタ {.unnumbered}

　括弧（`）`、OR`｜`、ネゲート`！`、`％in％`、AND`＆`の各演算子を使って、より複雑な論理条件を作ることができます。その例を以下に示します。

注： 論理的条件の前に`!` 演算子を使うと、それを否定することができます。例えば、`！is.na(column)`は、列の値が欠損していない場合に真と評価されます。同様に、`！column %in% c("a", "b", "c")`は、列の値がベクトルに含まれていない場合に真と評価されます。

#### データを調べる {.unnumbered}

　以下は、発症日のヒストグラムを作成するためのシンプルな1のコマンドです。2012～2013年に発生した2つ目の小規模なアウトブレイクもこの未加工データセットに含まれていることがわかります。今回の分析では、この初期アウトブレイクを削除したいと思います。

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```

#### 数値や日付の欠損をフィルターで処理する方法 {.unnumbered}

　date_onsetで2013年6月以降の行をフィルタリングすることはできるでしょうか。注意してください。`filter(date_onset > as.Date("2013-06-01")))`というコードを適用すると、発症日が欠落している後期流行の行がすべて削除されてしまいます!

[要注意：日付や数値の"大"（\>）または"小"（\<）にフィルタリングすると、欠損値（NA）のある行が削除されてしまいます。これは、NAが無限に大きい、または小さいものとして扱われるためです。]{style="color: red;"}

[(日付とパッケージ**lubridate**を使った作業については、[Working with dates](https://epirhandbook.com/en/working-with-dates.html#working-with-dates-1)のページを参照してください）。]{.ul}

#### フィルターの設計 {.unnumbered}

　クロス集計を見て、正しい行だけを除外していることを確認して下さい。

```{r}
table(Hospital  = linelist$hospital,                     #病院名
      YearOnset = lubridate::year(linelist$date_onset),  #発症した年
      useNA     = "always")                              #欠損値の表示
```

　データセットから最初の発生（2012年と2013年）を除外するために、他にどのような基準でフィルタリングできるでしょうか。次のことがわかりました。

-   2012年と2013年に発生した最初の流行は、A病院とB病院で発生し、ポート病院でも10件の症例がいます。

-   2回目の流行では、A病院とB病院には患者がいませんでしたが、ポート病院には患者がいました。

除外したい項目：

-   病院A、B、Portのいずれかで2012年と2013年に発症した`nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))` の行。

-   2012年および2013年に発症した`nrow(linelist %>% filter(date_onset < as.Date("2013-06-01"))` の行。

-   `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))`発症日が欠落している病院AおよびBの行。

-   `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))`発症日が見つからない他の行。

nrow(linelist)\`のラインリストを用意から始めます。これがフィルター文です。

```{r}
linelist <- linelist %>% 
 # 発症日が2013年6月1日以降の行、または発症日が不明でA病院またはB病院以外の病院であった行を残す。
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

　クロス集計を作り直すと、A病院とB病院が完全に取り除かれ、2012年と2013年の港区の病院の10件が取り除かれ、その他の値はすべて同じになっていることがわかります。

```{r}
table(Hospital  = linelist$hospital,                     # 病院名
      YearOnset = lubridate::year(linelist$date_onset),  # 発症した年
      useNA     = "always")                              # 欠損値の表示
```

　複数のステートメントを1つのfilterコマンドの中に含めることができます（カンマで区切ってください）。また、分かりやすくするために、常に別のfilter()コマンドにパイプすることもできます。

注：読者の中には、`date_hospitalisation`でフィルタリングする方が簡単だと思われる方もいるかもしれません。これは事実です。しかし、`date_onset`は複雑なフィルタを実際に見せる目的で使用されています。

### 独立型 {.unnumbered}

　フィルタリングは、（パイプチェーンの一部ではなく）独立したコマンドとしても実行できます。他の`dplyr`の動詞と同様に、この場合、第1引数はデータセットそのものでなければなりません。

```{r, eval=F}
# dataframe <- filter(dataframe, condition(s) for rows to keep)

linelist <- filter(linelist, !is.na(case_id))
```

**base** Rを使って、保持したい[行、列]を反映した角括弧を使ってサブセットすることもできます。

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```

### レコードを素早く確認 {.unnumbered}

　数列だけのレコードを素早く確認したいことがよくあります。R の基本関数である `View()`は、RStudio で表示できるようにデータフレームを表示します。

RStudio でラインリストを表示します。

```{r, eval=F}
View(linelist)
```

特定のセル（特定の行、特定の列）を表示する2つの例を紹介します。

**dplyrの関数 `filter()`と`select()`を使用します。**

`View()`の中で、データセットを　`filter()`にパイプして特定の行を残し、`select()`にパイプして特定の列を残します。例えば、3つの特定のケースの発症日と入院日を確認する場合です。

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```

Rの基本的な構文でも同じことができ、見たいサブセットには[ ]を使ってください。

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```

#### パイプチェーンに追加 {.unnumbered}

```{r}
# パイプチェーン処理 (未加工データから始まり、クリーニングステップを経てパイプに送られる)
##################################################################################


# パイプチェーンのクリーニング開始
###########################
linelist <- linelist_raw %>%
    
     #列名構文の標準化
    janitor::clean_names() %>% 
    
    # 手動で列名を変更
           #新しい列名            　　# 既存の列名
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # 列の除去
    select(-c(row_num, merged_header, x28)) %>% 
  
    # 重複除去
    distinct() %>% 

    # 列を追加する
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # 列のクラスを変換
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # 列の追加: 入院までの時間
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
     # 病院列の値を整える
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
      # age_years 列を作成 (ageとage_unit列から)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    mutate(
         # 年齢別カテゴリー: 慣例
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
　　　# 年齢カテゴリー 0～85歳までの5段階
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))%>% 
    
      # 上記は既に説明した上流側のクリーニング方法です。
   
    ###################################################
    filter(
         # case_idが欠落していない行のみを残す
          !is.na(case_id),  
          
           #2回目の感染発生分だけを残すようにフィルターをかける
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## 行単位の計算

　行内で計算を行いたい場合は、**dplyr** の`rowwise()`を利用することができます。例えば、このコードでは `rowwise()`を適用し、行リストの各行について、値が"はい"である指定された症状の列の数を合計する新しい列を作成しています。`rowwise()`は本質的に特別な種類の `group_by()`であるため、終わったら `ungroup()を`使うのがベストです（ [Grouping data](https://epirhandbook.com/en/grouping-data.html#grouping-data) ページを参照）。

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # 表示のため
```

　評価する列を指定する際に、このページの `select()`セクションで説明されている "tidyselect" ヘルパー関数を使用したいと思うかもしれません。1つだけ調整が必要です（ `select()`や `summarise()`のような dplyr関数内で使用していないため）。

　列指定の基準を **dply**r 関数の`c_across()`の中に入れます。これは、`c_across（`[documentation](https://dplyr.tidyverse.org/reference/c_across.html)`）`が、特に`rowwise()`と連動するように設計されているからです。例えば、次のようなコードです。

-   `rowwise()`を適用して、各行の中で以下の演算(`sum()`)が適用されます(列全体の合計ではありません)。

-   新しい列 `num_NA_dates` を作成します。これは、各行について、`is.na()` が TRUE と評価された列 (名前が "date" を含むもの) の数として定義されます (これらはデータが欠損しています)。

-   `ungroup()`により、後続のステップで `rowwise()`の影響を取り除きます。

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # for display
```

また、max() のような他の関数を用意して、各行の最新または直近の日付を取得することもできます。

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # for display
```

## アレンジとソート（並び替え）

**dplyr**の関数 `arrange()`を使って、列の値で行を並べ替えたり、順番に並べたりします。

　単純に、ソートされるべき順に列を列挙します。データに適用されたグループ化によって最初にソートを行いたい場合は、`.by_group = TRUE` を指定します（ [Grouping data](https://epirhandbook.com/en/grouping-data.html#grouping-data) のページを参照）。

デフォルトでは、列は "昇順 "でソートされます（これは、数字や文字の列にも適用されます）。変数を`desc()`で囲むと、"降順"でソートできます。

`arrange()`によるデータのソートは、[プレゼンテーション用のテーブル]を作成するときや、`slice()`を使ってグループごとに"上位"の行を取り出すとき、あるいはファクタレベルの順序を出現順に設定するときなどに特に便利です。

例えば、linelistの行を病院別にソートし、次にdate_onsetで降順にソートするには、次のようにします。

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```

```{r, echo=F}
# HIDDEN
#
# 残りの既存の感染発生行を簡単にmissingに変換します。
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```

```{r echo=F}
# エクスポート用に列を再配置
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}

# クリーニングされたラインリストファイルを "data "フォルダにエクスポートする
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"))
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

# 因子（ファクタ）型データ

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Factors_1500x500.png"))
```

R では、[因子]{.ul}は、許容値の固定セットで順序付けされたカテゴリを可能にするデータのクラス（分類）です。

一般的に、列を文字または数値クラスから係数に変換し、値（"[レベル]{.ul}"）に固有の順序を設定すると、プロットやテーブルにアルファベット以外の形式で表示できるようなります。因子のもう1つの一般的な使用法としては、プロットの凡例を標準化し、特定の値がデータに一時的に存在しない場合にも変動しないようにすることができます。

このページでは、**forcats**（"**For c**ategorical variables" の略）パッケージの関数と、**base** R 関数の使い方を説明します。また、疫学週に関する特殊要因の場合の **lubridate** や **aweek** の使用についても触れています。

**forcats** の関数一覧は、[こちら](https://forcats.tidyverse.org/reference/index.html)からオンラインでご覧ください。以下に、代表的なものをいくつか紹介します。

<!-- ======================================================= -->

## 準備

### パッケージを読み込む {.unnumbered}

以下のコードは、分析に必要なパッケージの読み込みを示しています。 このハンドブックでは、**pacman** の `p_load()` を推奨しています。このパッケージを使うことにより、必要なパッケージが自動的にインストールされ・読み込まれます。また、インストールされたパッケージは、**base** R から `library()` で読み込むことができます。R のパッケージについては、\[R の基礎\] のページを参照してください。

```{r}
pacman::p_load(
  rio,           # インポート・エクスポート
  here,          # ファイルパス
  lubridate,     # 日付
  forcats,       # 因子型データ
  aweek,         # 自動的な因子レベルを持つエピウィークの作成
  janitor,       # 表
  tidyverse      # データ管理・可視化
  )
```

### データのインポート {.unnumbered}

エボラ出血熱の流行をシミュレーションした症例データセットをインポートします。フォローしたい場合は、<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>クリックして "clean" ラインリストをダウンロード</a>（.rdsファイルとして）。 `import()` 関数を使用して **rio** パッケージからデータをインポートします（.xlsx、.rds、.csv など多くのファイルタイプのインポート可能です。詳細については、\[データのインポート・エクスポート\] ページを参照してください）。

```{r, echo=F}
# ラインリストを R にインポートする
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# データセットをインポートする
linelist <- import("linelist_cleaned.rds")
```

### 新しいカテゴリー変数 {#fct_newcat .unnumbered}

このページでは、一般的なシナリオである新しいカテゴリカル変数の作成を例に説明します。

数値列を因子型データに変換した場合、その列の数値計算はできなくなることに注意してください。

#### 列の作成 {.unnumbered}

既存の `days_onset_hosp` （症状発現から入院までの日数）列を用いて、各行をカテゴリーのいずれかに分類し、新しい `delay_cat` 列を作成します。**dplyr** の関数 `case_when()` を使い、各行に論理基準（右側）をに順次適用し、新しい列 `delay_cat` に対応する左側の値が得られます。`case_when()` については、\[データクリーニングと主要関数\] で詳しく説明しています。

```{r}
linelist <- linelist %>% 
  mutate(delay_cat = case_when(
    # 基準                                   # 基準が TRUE の場合 delay_cat に指定される値
    days_onset_hosp < 2                        ~ "<2 days",
    days_onset_hosp >= 2 & days_onset_hosp < 5 ~ "2-5 days",
    days_onset_hosp >= 5                       ~ ">5 days",
    is.na(days_onset_hosp)                     ~ NA_character_,
    TRUE                                       ~ "Check me"))  
```

#### 初期値の順序 {.unnumbered}

`case_when()` で作成されたように、新しい列 `delay_cat` のは、文字型クラスであり、まだ因子では[ありません]{.ul}。したがって、度数分布表では、デフォルトの英数字の順序で値が表示されます - 直感的にはあまり意味のない順序です。

```{r}
table(linelist$delay_cat, useNA = "always")
```

同様に、棒グラフを作成すると、値も x 軸にこの順序で表示されます（ R で最も一般的な視覚化パッケージである **ggplot2** の詳細については、\[ggplot の基礎\] ページを参照してください）。

```{r, warning=F, message=F}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = delay_cat))
```

## 因子型データへの変換

文字や数字の列を[因子]{.ul}に変換するには、**forcats** パッケージの任意の関数を使用することができます（多くの関数は[以下](#fct_adjust)で詳しく説明します）。このパッケージをを使い因子型データに変換でき、因子レベルの特定の順序を指定することができます。たとえば、 `fct_relevel()` を使用すると、レベルの順序を手動で指定できます。関数 `as_factor()` は、それ以上の機能はなく、単に因子型データへの変換に使用されます。

**base** R の関数である `factor()` は、列を因子に変換し、`levels =` 因数で指定された文字ベクトルにより、因子レベルの順序を手動で指定することができます。

以下では、`mutate()` と `fct_relevel()` を使用して、列 `delay_cat` を文字型データから因子型データに変換します。列 `delay_cat` は、上記の[準備](#fct_newcat)セクションで作成されされたものです。

```{r}
linelist <- linelist %>%
  mutate(delay_cat = fct_relevel(delay_cat))
```

[ここで、この列の "値"（重複のない形で取り出された値）は、因子の "レベル" と見なされます。]{.ul}レベルには順序があり、これは**base** R 関数 `levels()` で確認するか、**base** R の `table()` または **janitor** の `tabyl()` でカウントテーブルでとして表示することもできます。デフォルトでは、レベルの順序は以前と同様に英数字になります。 `NA` は因子レベルではないことに注意してください。

```{r}
levels(linelist$delay_cat)
```

`fct_relevel()` 関数を使ってレベルの順序を手動で指定することもできます。以下のように、レベルの値を引用符で囲み、カンマで区切って順番に記述するだけです。スペルは値と正確に一致する必要があることに注意してください。データに存在しないレベルを作成する場合は、代わりに [代わりに fct_expand()](#fct_add) を使用してください。

```{r}
linelist <- linelist %>%
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", "2-5 days", ">5 days"))
```

これで、前のコマンドで指定したように、レベルが感覚的に並べられることが確認できます。

```{r}
levels(linelist$delay_cat)
```

これで、プロットの順序もより直感的に理解できるようになりました。

```{r, warning=F, message=F}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = delay_cat))
```

## レベルの追加または削除

### レベルの追加 {#fct_add .unnumbered}

因子にレベルを追加する必要がある場合、 `fct_expand()` で実行することができます。列名の後に新しいレベル（コンマで区切る）を入力するだけです。値を表にすることで、新しく指定されたレベルとそのレベルのゼロカウントが確認できます。**base** Rの `table()` や、**janitor** の `tabyl()` で表を表示できます。

```{r}
linelist %>% 
  mutate(delay_cat = fct_expand(delay_cat, "Not admitted to hospital", "Transfer to other jurisdiction")) %>% 
  tabyl(delay_cat)   # 表の表示
```

注: 欠損値（`NA`）を簡単にレベルとして追加するための特別な **forcats** 関数があります。以下の[欠損値](#fct_missing)に関するセクションを参照してください。

### レベルの削除 {.unnumbered}

`fct_drop()` を使用すると、カウントがゼロの "未使用" レベルがレベルのセットから削除されます。上記で追加したレベル（"入院していない"）はレベルとして存在しますが、実際にその値を持つ行はありません。したがって、因子列に `fct_drop()` を適用すると、こういった値は削除されます。

```{r}
linelist %>% 
  mutate(delay_cat = fct_drop(delay_cat)) %>% 
  tabyl(delay_cat)
```

## レベルの順序の調整 {#fct_adjust}

パッケージ **forcats** には、因子のレベルの順序を簡単に調整するための便利な関数があります（列が因子型データとして定義された後）。

これらの関数は、次の2つの文脈で因子列に適用できます。

1)  通常通り、データフレームの列に対しての適用（その後のデータ利用時に利用できるようにします）\
2)  [プロット内で]{.ul}*、*変更がプロット内でのみ適用されるようにします

### 手動での調整 {.unnumbered}

この関数は、因子レベルを手動で順序付けるために使用されます。非因子列で使用された場合、その列は最初に因子型データに変換される。

括弧の中にまず因子列名を記入し、次に以下のどちらかを記入します。

-   希望する順序のすべてのレベル（文字ベクトル `c()` として）、または\
-   1つのレベルで - `after =` 引数を使用し配置が指定されます

ここで、列 `delay_cat`（これはすでに因子型データである）を再定義し、希望するレベルの順序をすべて指定する例を示します。

```{r}
# レベルの順序を再定義する
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, c("<2 days", "2-5 days", ">5 days")))
```

1つのレベルのみを移動する場合は、それを `fct_relevel()` にて単独で指定し、`after =` 引数に番号を指定し、順序のどこに配置するかを指定することが可能です。例えば、以下のコマンドでは、"\<2 days" を2番目の位置に移動させます。

```{r, eval=F}
# レベルの順序を再定義する
linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", after = 1)) %>% 
  tabyl(delay_cat)
```

### プロット内で {.unnumbered}

**forcats** コマンドを使用して、データフレーム内、またはプロット内でのみレベルの順序を設定できます。`ggplot()` プロットコマンド[内で]{.ul}列名を "指定" するコマンドを使用することにより、反転/レベル変換/等をそのプロット内でのみ適用させることができます。

以下に、 `ggplot()` を使用して2つのプロットを作成します（\[ggplotの基礎\] ページを参照）。最初の例では、 `delay_cat` の列がプロットの x 軸にプロットされ、データ `linelist` のようにデフォルトのレベルオーダーで表示されます。2番目の例では、`fct_relevel()` の内で `delay_cat` の列が指定され、プロットの中で順序が変更されています。

```{r, echo =F}
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, c("2-5 days", "<2 days", ">5 days")))

```

```{r, warning=F, message=F, out.width = c('50%', '50%'), fig.show='hold'}
# 英数字のデフォルトの順序- ggplot 内での調整なし
ggplot(data = linelist)+
    geom_bar(mapping = aes(x = delay_cat))

# ggplot 内で調整された因子レベルの順序
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c("<2 days", "2-5 days", ">5 days"))))
```

デフォルトの x 軸のタイトルが非常に複雑になっていることに注意してください。このタイトルは **ggplot2** の `labs()` 引数で上書きすることができます。

### 反転 {.unnumbered}

レベルの順番を逆にしたい場合は、因子を `fct_rev()` で囲むだけです。

プロットの凡例[のみ]{.ul}を反転し、実際の因子レベルは反転させたくない場合は、`guides()` を使用して反転できることに注意してください（\[ggplot の基礎\] を参照）。

### 頻度別 {.unnumbered}

値がデータに表示される頻度で並べ替えるには、`fct_infreq()` を使用します。欠損値(`NA`)は、明示的なレベルに変換されない限り、自動的に最後に含まれます（[このセクション](#fct_missing)を参照）。さらに `fct_rev()` で囲むと、順序を反転することができます。

この関数は、以下に示すように、`ggplot()` 内で使用できます。

```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# 頻度順に並べる
ggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+
  geom_bar()+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by frequency")

# 頻度順を反転させる
ggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+
  geom_bar()+
  labs(x = "Delay onset to admission (days)",
       title = "Reverse of order by frequency")
```

### 出現順序別 {.unnumbered}

`fct_inorder()` を使用して、最初の行から開始して、データ内の出現順序と一致するようにレベルの順序を設定します。この関数は、データフレーム内のデータを配列し（`arrange()` を用いて）、因子の順序を設定する場合に有効です。

### 別の列の要約統計別 {.unnumbered}

`fct_reorder()` を使用して、列のレベルを[別の列の要約統計量で]{.ul}並べ替えることができます。視覚的にも、プロット上でバーやポイントが安定して上昇または下降するような美しいプロットになります。

以下の例では、x 軸は `delay_cat`、y 軸は数値列 `ct_blood`（サイクル閾値）です。ボックスプロットでは、 `delay_cat` グループごとの CT 値の分布を示しています。グループの中央値CT値の昇順でボックスプロットを並べ替えます。

以下の最初の例では、デフォルトの順序の英数字レベルの順序が使用されています。ボックスプロットの高さが乱雑で、特定の順序ではないことがわかります。2番目の例では、 `delay_cat` 列（x 軸にプロットされている）が `fct_reorder()`で指定され、列 `ct_blood` が2番目の引数として指定され、"median" が3番目の引数として指定されています（"max"、"mean"、"min"など）。したがって、 `delay_cat` のレベルの順序は、各 `delay_cat` グループの中央値 CT 値の昇順の中央値 CT 値を反映するようになります。これは2番目のプロットに反映されています - ボックスプロットは上昇するように再配置されています。明示的なレベルに変換されない限り、最後に `NA` （欠損値）が表示されることに注意。

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# 元の因子レベル順で並べられたボックスプロット
ggplot(data = linelist)+
  geom_boxplot(
    aes(x = delay_cat,
        y = ct_blood, 
        fill = delay_cat))+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by original alpha-numeric levels")+
  theme_classic()+
  theme(legend.position = "none")


# CT 値の中央値順に並べられた箱ひげ図
ggplot(data = linelist)+
  geom_boxplot(
    aes(x = fct_reorder(delay_cat, ct_blood, "median"),
        y = ct_blood,
        fill = delay_cat))+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by median CT value in group")+
  theme_classic()+
  theme(legend.position = "none")
```

この例では、 `ggplot()` 呼び出しの前に必要なステップがないことに注意してください - グループ化と計算は、すべて ggplot コマンドの内部で行われています。

### "終了" 値別 {.unnumbered}

グループ化された折れ線グラフには、`fct_reorder2()` を使用してください。プロットの "終わり" にある線の縦方向の順序と一致するようにレベル（したがって凡例）を順序付けます。"最大の x 値に関連付けられた y 値で並べ替え" ます。

たとえば、時間の経過に伴う病院ごとの症例数を示す線がある場合、 `aes()` の`color =` 引数に`fct_reorder2()` を適用して、凡例に現れる病院の縦の順序がプロットの終端の線の順序と一致するようにすることができます。 詳しくは、[オンラインドキュメント](https://forcats.tidyverse.org/reference/fct_reorder.html)をご覧ください。

```{r, warning=F, message=F}
epidemic_data <- linelist %>%         # linelistから始める   
    filter(date_onset < as.Date("2014-09-21")) %>%    # 見やすくするためのカットオフ日を指定
    count(                                            # 週ごとおよび病院ごとの症例数を取得する
      epiweek = lubridate::floor_date(date_onset, "week"),  
      hospital                                            
    ) 
  
ggplot(data = epidemic_data)+                       # プロットを開始
  geom_line(                                        # 折れ線グラフを作る
    aes(
      x = epiweek,                                  # x-軸 エピウィーク
      y = n,                                        # y-軸は1週間あたりの症例数
      color = fct_reorder2(hospital, epiweek, n)))+ # 病院ごとにグループ化および色付けされたデータ、プロット終了時の高さによる因子順
  labs(title = "Factor levels (and legend display) by line height at end of plot",
       color = "Hospital")                          # 凡例のタイトルを変更する
```

## 欠損値 {#fct_missing}

因子の列に `NA` 値がある場合は、`fct_explicit_na()` を使用して "Missing" などの名前付きレベルに簡単に変換できます。NA 値は、デフォルトで因子のレベルオーダーの最後に "(Missing)" に変換されます。引数 `na_level =` でレベル名を調整することができます。

以下では、この操作を `delay_cat` 列に対して行い、`NA` を "Missing delay "に変換した表を `tabyl()` で表示する。

```{r}
linelist %>% 
  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = "Missing delay")) %>% 
  tabyl(delay_cat)
```

## レベルを組み合わせる

### 手動で {.unnumbered}

`fct_recode()` を使い、レベルの表示を手動で調整することができます。これは、**dplyr** 関数 `recode()`（\[データクリーニングと主要関数\] を参照）に似ていますが、この関数は新しい因子レベルを作成できます。因子に `recode()` を使用する場合、新しく因子として指定された値は以前に許容レベルとして設定されていない限り、拒否されます。

このツールは、複数のレベルに同じく新たに因子として指定された値を割り当てることにより、レベルを "結合" するためにも使用できます。ここでは、情報が失われないように注意してください。この組み合わせのステップを新しい列で行うことを検討してください（既存の列を上書きしないでください）。

`fct_recode()` の構文は `recode()` とは異なります。`recode()` は`OLD = NEW` を使用しますが、`fct_recode()` は `NEW = OLD` を使用します。

`delay_cat` の現在のレベルは次のとおりです。

```{r, echo=F}
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", after = 0))
```

```{r}
levels(linelist$delay_cat)
```

新しいレベルは、構文 `fct_recode(column, "new" = "old", "new" = "old", "new" = "old")` を使用して作成されます。

```{r}
linelist %>% 
  mutate(delay_cat = fct_recode(
    delay_cat,
    "Less than 2 days" = "<2 days",
    "2 to 5 days"      = "2-5 days",
    "More than 5 days" = ">5 days")) %>% 
  tabyl(delay_cat)
```

ここでは、それらを手動で `fct_recode()` と組み合わせています。新しいレベル "Less than 5 days" の作成時にエラーが発生しないことに注意してください。

```{r, warning=F, message=F}
linelist %>% 
  mutate(delay_cat = fct_recode(
    delay_cat,
    "Less than 5 days" = "<2 days",
    "Less than 5 days" = "2-5 days",
    "More than 5 days" = ">5 days")) %>% 
  tabyl(delay_cat)
```

### "その他" として縮小 {.unnumbered}

`fct_other()` を使用して、因子レベルを "その他" レベルに手動で割り当てることができます。以下では、"Port Hospital" と "Central Hospital" を除く、`hospital` 列のすべてのレベルが "その他" にまとめられています。（`keep =`）または（`drop =`）のいずれかを使用してベクトルで指定できます。`other_level =` で "その他" レベルの表示を変更できます。

```{r}
linelist %>%    
  mutate(hospital = fct_other(                      # レベルの
    hospital,
    keep = c("Port Hospital", "Central Hospital"),  # これらを別々にキープする
    other_level = "Other Hospital")) %>%            # 他のすべては "Other Hospital" として 
  tabyl(hospital)                                   # 表を表示

```

### 頻度が少ないレベルを組み合わせる {.unnumbered}

`fct_lump()` を用いて、最も頻度の低い因子レベルを自動的に結合することができます。

多くの低頻度のレベルを "その他" グループに "ひとまとめ" にするには、以下のいずれかを行います。

-   保持したいグループの数として `n =` を設定します。 最も頻度の高い n 個のレベルが保持され、他のすべてのレベルは "その他" に結合されます。\
-   維持したいレベル以上の閾値頻度の割合として、 `prop =` を設定します。それ以外の値は "その他" に結合されます。

`other_level =` で "その他" レベルの表示を変更できます。 以下では、最も頻度の高い2つの病院を除くすべての病院が "Other Hospital" に統合されています。

```{r, warning=F, message=F}
linelist %>%    
  mutate(hospital = fct_lump(                      # レベルの調整
    hospital,
    n = 2,                                          # 上位2レベルをキープ
    other_level = "Other Hospital")) %>%            # 他のすべては "Other Hospital" として
  tabyl(hospital)                                   # 表を表示

```

, warn ## Show all levels

因子を使用する利点の1つは、データセットに実際に存在する値に関係なく、プロットの凡例や表の外観を標準化することです。

多くの図表を作成する場合（複数の法域に対応するためなど）、データの完成度や構成が異なっていても、凡例や表が同じように表示されるようにしたいものです。

### プロット内で {.unnumbered}

`ggplot()` の図では、該当する`scale_xxxx()` 関数に `drop = FALSE` の引数を追加するだけです。データ中に存在するかどうかにかかわらず、すべての因子レベルが表示されます。因子列のレベルが `fill =` で表示される場合、scale_fill_discrete() で `drop = FALSE` を指定すると、以下のようになります。レベルが `x =` （x 軸に対して） `color =` または `size =` で表示される場合は、それに応じて `scale_color_discrete()` または `scale_size_discrete()` で指定します。

この例は、病院ごとの年齢カテゴリの積み上げ棒グラフです。`scale_fill_discrete(drop = FALSE)`を追加すると、データに存在しない場合でも、すべての年齢グループが凡例に表示されるようになります。

```{r}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +
  scale_fill_discrete(drop = FALSE)+                        # すべての年齢層を凡例に表示する
  labs(
    title = "All age groups will appear in legend, even if not present in data")
```

### 表で {.unnumbered}

**janitor** の `tabyl()` と **base** R の `table()` の両方では、すべての因子レベル（未使用レベルも）が表示されます

**dplyr** の `count()` や `summarise()` を使って表を作成する場合は、引数 `.drop = FALSE` を追加して、使われていないものも含めてすべての因子レベルのカウントを含めるようにします。

詳細については、\[記述統計表の作り方\] のページ、[scale_discrete についての説明](https://ggplot2.tidyverse.org/reference/scale_discrete.html)、または [count() についての説明](https://dplyr.tidyverse.org/reference/count.html)を参照してください。\[接触者の追跡\] のページで別の例を見ることができます。

## エピウィーク

エピウィークの作成方法については、\[データのグループ化\] のページで詳しく説明していますので、そちらをご覧ください。\
また、\[日付型データ\] のページでは、エピウィークの作成方法と書式を紹介していますので、あわせてご覧ください。

### プロット内でのエピウィーク {.unnumbered}

エピウィークを作成してプロットに表示することが目的である場合は、\[データのグループ化\] のページで説明したように、**lubridate** の `floor_date()` で簡単に行うことができます。これにより得られる値は、YYYY-MM-DD 形式の日付クラスになります。この列をプロットで使用する場合、日付は正しく順序付けられ、レベルや因子への変換を気にする必要はありません。以下の発症日の `ggplot()` ヒストグラムを参照してください。

このアプローチでは、 `scale_x_date()` を使用して軸上の日付の[表示]{.ul}を調整できます。詳細については、\[流行曲線（エピカーブ）\] のページを参照してください。

`scale_x_date()` の `date_labels =` 引数に "strptime" 表示形式を指定できます。これらのフォーマットは "%" プレースホルダーを使用し、\[日付型データ\]のページで説明されています。"％Y" を使用して4桁の年を表し、"％W" または "％U" を使用して週番号（それぞれ月曜日または日曜日の週）を表します。

```{r, warning=F, message=F}
linelist %>% 
  mutate(epiweek_date = floor_date(date_onset, "week")) %>%  # 週の列を作成
  ggplot()+                                                  # ggplotを開始
  geom_histogram(mapping = aes(x = epiweek_date))+           # 発症日のヒストグラム
  scale_x_date(date_labels = "%Y-W%W")                       # 日付の表示をYYYY-WWwに調整
```

### データ内のエピウィーク {.unnumbered}

ただし、ファクタリングの目的がプロット[ではない]{.ul}場合は、次の2つの方法のいずれかを使うことができます。

1)  [表示を細かく制御するには]{.ul}、[データフレーム自体の中で]{.ul} **lubridate** エピウィークの列（YYYY-MM-DD）を目的の表示形式（YYYY-WWw）に変換してから、因子型データに変換します。

まず、**base** R の `format()` を使用して、日付表示を YYYY-MM-DD から YYYY-Www 表示に変換します（\[日付型データ\] のページを参照）。このプロセスでは、クラスは文字型データに変換されます。 次に、`factor()`を使用し文字型データから因子型データに変換します。

```{r}
linelist <- linelist %>% 
  mutate(epiweek_date = floor_date(date_onset, "week"),       # エピウィークを作成する（YYYY-MM-DD）
         epiweek_formatted = format(epiweek_date, "%Y-W%W"),  # （YYYY-WWw）表示に変換
         epiweek_formatted = factor(epiweek_formatted))       # 因子に変換

# レベルの表示
levels(linelist$epiweek_formatted)
```

[[危険:]{.ul} 週を年（"Www-YYYY"）より前に配置すると（"%W-%Y"）、デフォルトの英数字レベルの順序がおかしくなります（例：01-2015は35-2014より前になる）。順序を手動で調整する必要がある場合がありますが、これは非常に面倒なプロセスになります。]{style="color: red;"}

2)  [デフォルトの表示を高速化するには]{.ul}、**aweek** パッケージとその関数 `date2week()` を使用します。`week_start =` を設定でき、`factor = TRUE` を設定すると、アウトプットされる列は順序付けられた因子になります。また、その週に症例がない場合でも、因子には期間内の[すべての]{.ul}可能な週が含まれます。

```{r, eval=F}
df <- linelist %>% 
  mutate(epiweek = date2week(date_onset, week_start = "Monday", factor = TRUE))

levels(df$epiweek)
```

**aweek** については、\[日付型データ\] のページを参照してください。また、逆関数の `week2date()` についても触れられています。

<!-- ======================================================= -->

## 資料

[R for Data Science のページ - 因子型データについて](https://r4ds.had.co.nz/factors.html)\
[aweek パッケージについて](https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html)

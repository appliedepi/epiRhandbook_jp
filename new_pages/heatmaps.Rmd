# ヒートマップ

「ヒートプロット」や「ヒートタイル」とも呼ばれるヒートマップは3つの変数（x軸、y軸、色）を表示しようとするときに便利なビジュアライゼーションです。以下では、2つの例を示します：

-   年齢別の感染イベント（「誰から誰への感染か」）のビジュアルマトリクス\
-   多施設の報告率を時系列で追跡

```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "transmission_matrix.png"))

knitr::include_graphics(here::here("images", "heat_tile.png"))

```

<!-- ======================================================= -->

## 準備

### パッケージのロード {.unnumbered}

このコードチャンクは、解析に必要なパッケージの読み込みを示しています。このハンドブックでは **pacman** の `p_load()` の使用を推奨しています。まずはパッケージをインストールし、使用するためにロードする必要があります。インストールされたパッケージは ベース R から `library()` でロードすることもできます。R のパッケージについては \[Rの基礎\] のページを参照してください。

```{r}
pacman::p_load(
  tidyverse,       # データ操作と可視化
  rio,             # データのインポート
  lubridate        # 日付処理
  )
```

データセット

このページでは、感染伝播マトリックスのセクションではシミュレーションアウトブレイクの症例ラインリストを使用し、施設ごとの報告率の追跡のセクションでは、日別のマラリア患者数のデータセットを使用しています。これらのデータの読み込みとクリーニングは、それぞれのセクションで行います。

## 感染伝播マトリックス

ヒートマップは、マトリックスを視覚化するのに便利です。一つの例として、アウトブレイクにおける「誰から誰に感染がうつったか」を図示することが出来ます。これは、感染イベントに関するデータがあることが前提となっています。

なお、\[接触者の追跡\]ページには、別の（より単純な）データセットを用いて、ヒートマップによる接触マトリックスを作成する別の例が掲載されています。また、この同じデータを使って、\[ggplotの基礎\]のページで密度マップを作成しています。今回の例は、症例のラインリストから始まるので、プロット可能なデータフレームを得る前にかなりのデータ操作が必要ですが、その結果として多くのシナリオから選ぶことが可能になっています。。。

まずはエボラ出血熱の流行をシミュレーションしたラインリストを用います。[こちら](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds)から「綺麗な」ラインリスト（.rdsファイル）をダウンロードすることが出来ます。**rio** パッケージの `import()` 関数でデータをインポートすることが出来ます（.xlsx, .rds, .csv など多くのファイル形式のインポートが可能です - 詳しくは \[データのインポート・エクスポート\] ページを参照してください）。

ラインリストの最初の50行を以下に表示します：

```{r, echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```

このラインリストでは：

-   `case_id` が振られた1症例ごとに1行となっています。
-   `infector` 列には、感染者の `case_id` が含まれており、その感染者もラインリストの症例です。

```{r message=FALSE, echo=F}
# ラインリストを表で表示
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### データ準備 {.unnumbered}

**目的：** 全ての年代の組み合わせの感染ペアの行ごとに、ラインリストで観測されたすべての感染ペアに占める割合を持つ、「long」型のデータフレームを作成する必要があります。

これを実現するには、いくつかのデータ操作のステップが必要です：

#### 感染先のデータフレームの作成 {.unnumbered}

まず症例ID、年代、感染源のIDを含むデータフレームを作成し、`case_ages` という変数名をつけます。最初の50行は以下のように表示されます。

```{r}
case_ages <- linelist %>% 
  select(case_id, infector, age_cat) %>% 
  rename("case_age_cat" = "age_cat")
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(case_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### 感染源のデータフレームの作成 {.unnumbered}

次に、感染源のデータフレームを作成します。この時点では感染源ID のみの1列から構成されています。全ての症例の感染源が判明している訳ではないので、欠損値を削除しています。最初の50行は以下のように表示されます。

```{r}
infectors <- linelist %>% 
  select(infector) %>% 
  drop_na(infector)
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(infectors, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

次に、感染源の年代を取得します。これは簡単には出来ません。なぜなら、ラインリストには感染源の症例の年代がそのままは記載されていないからです。そのため、ラインリストと感染源IDを結合する必要があります。感染源のデータフレームから始めて、左側の「ベースライン」のデータフレームの感染者 ID 列と右側のラインリストの `case_id` 列を紐づけて、ラインリストを `left_join()` （追加）します。

このように、ラインリスト内の感染源の症例のデータ（年代）が、感染源の行に追加されます。最初の50行を以下に表示します。

```{r}
infector_ages <- infectors %>%             # 感染源のデータフレームから始める
  left_join(                               # それぞれの感染源の行にラインリストデータを追加する
    linelist,
    by = c("infector" = "case_id")) %>%    # infector列とcase id 列で紐付ける
  select(infector, age_cat) %>%            # 必要な列のみを抽出する
  rename("infector_age_cat" = "age_cat")   # 分かりやすいように列名を変更
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(infector_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Then, we combine the cases and their ages with the infectors and their ages. Each of these data frame has the column `infector`, so it is used for the join. The first rows are displayed below:

次に、感染先症例とその年代を、感染源症例とその年代と結合します。これらのデータフレームはそれぞれ `infector` という列を持っているので、この列で紐付けます。最初の行は以下のように表示されます。

```{r}
ages_complete <- case_ages %>%  
  left_join(
    infector_ages,
    by = "infector") %>%        # infector 列で紐付け
  drop_na()                     # 欠損値のある行を削除
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(ages_complete, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

以下は、感染先症例と感染源症例の年代階級別の症例数を単純にクロス集計したものです。分かりやすくするためにラベルをつけています。

```{r}
table(cases = ages_complete$case_age_cat,
      infectors = ages_complete$infector_age_cat)
```

この表をデータフレームに変換するには、base R の `data.frame()` を使います。これにより自動で「long」型のデータフレームとなり、`ggplot()` に適した形となります。最初の行は以下のようになります。

```{r}
long_counts <- data.frame(table(
    cases     = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat))
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(long_counts, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

さらに、base R の `prop.table()` をテーブルに適用して、数の代わりに全体の割合を出します。最初の50行は以下のようになります。

```{r}
long_prop <- data.frame(prop.table(table(
    cases = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat)))
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(long_prop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### ヒートマップの作成 {.unnumbered}

さて、いよいよ **ggplot2** パッケージで `geom_tile()` 関数を用いてヒートマップを作成します。色/塗りつぶしスケール、特に `scale_fill_gradient()` 関数についてより広範囲に学ぶには、 \[ggplotの基礎\] ページを参照して下さい。

-   `geom_tile()` の `aes()` で、x と y を case age と infector age に設定します。\

-   また、`aes()` では、引数 `fill =` を `Freq` 列に指定します - これはタイルの色に変換される値です\

-   `scale_fill_gradient()` でスケールカラーを設定します - ハイ/ローカラーを指定することが出来ます。

    -   `scale_color_gradient()` は違うことに注意してください! 今回は塗りつぶしが必要です。

-   色は 「fill」を介して作られるので、 `labs()` の `fill =` 引数を使えば、凡例のタイトルを変更することが出来ます。

```{r}
ggplot(data = long_prop)+       # 割合が Freq 列に格納された「long」データを使用
  geom_tile(                    # タイルで可視化
    aes(
      x = cases,         # x軸は感染先の年代
      y = infectors,     # y軸は感染源の年代
      fill = Freq))+            # タイルの色分けを Freq 列で決定する
  scale_fill_gradient(          # タイルの色を調整する
    low = "blue",
    high = "orange")+
  labs(                         # ラベル
    x = "Case age",
    y = "Infector age",
    title = "Who infected whom",
    subtitle = "Frequency matrix of transmission events",
    fill = "Proportion of all\ntranmsission events"     # 凡例タイトル
  )
  
```

<!-- ======================================================= -->

## Reporting metrics over time

Often in public health, one objective is to assess trends over time for many entities (facilities, jurisdictions, etc.). One way to visualize such trends over time is a heat plot where the x-axis is time and on the y-axis are the many entities.

### Data preparation {.unnumbered}

We begin by importing a dataset of daily malaria reports from many facilities. The reports contain a date, province, district, and malaria counts. See the page on \[Download handbook and data\] for information on how to download these data. Below are the first 30 rows:

```{r, echo=F}
facility_count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  select(location_name, data_date, District, malaria_tot)
```

```{r, eval=F}
facility_count_data <- import("malaria_facility_count_data.rds")
```

```{r, echo=F}
DT::datatable(head(facility_count_data,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

#### Aggregate and summarize {.unnumbered}

**The objective in this example** is to transform the daily facility *total* malaria case counts (seen in previous tab) into *weekly* summary statistics of facility reporting performance - in this case *the proportion of days per week that the facility reported any data*. For this example we will show data only for **Spring District**.

To achieve this we will do the following data management steps:

1)  Filter the data as appropriate (by place, date)\

2)  Create a week column using `floor_date()` from package **lubridate**

    -   This function returns the start-date of a given date's week, using a specified start date of each week (e.g. "Mondays")\

3)  The data are grouped by columns "location" and "week" to create analysis units of "facility-week"\

4)  The function `summarise()` creates new columns to reflecting summary statistics per facility-week group:

    -   Number of days per week (7 - a static value)\
    -   Number of reports received from the facility-week (could be more than 7!)\
    -   Sum of malaria cases reported by the facility-week (just for interest)\
    -   Number of *unique* days in the facility-week for which there is data reported\
    -   **Percent of the 7 days per facility-week for which data was reported**\

5)  The data frame is joined with `right_join()` to a comprehensive list of all possible facility-week combinations, to make the dataset complete. The matrix of all possible combinations is created by applying `expand()` to those two columns of the data frame as it is at that moment in the pipe chain (represented by `.`). Because a `right_join()` is used, all rows in the `expand()` data frame are kept, and added to `agg_weeks` if necessary. These new rows appear with `NA` (missing) summarized values.

Below we demonstrate step-by-step:

```{r, message=FALSE, warning=FALSE}
# Create weekly summary dataset
agg_weeks <- facility_count_data %>% 
  
  # filter the data as appropriate
  filter(
    District == "Spring",
    data_date < as.Date("2020-08-01")) 
```

Now the dataset has `nrow(agg_weeks)` rows, when it previously had `nrow(facility_count_data)`.

Next we create a `week` column reflecting the start date of the week for each record. This is achieved with the **lubridate** package and the function `floor_date()`, which is set to "week" and for the weeks to begin on Mondays (day 1 of the week - Sundays would be 7). The top rows are shown below.

```{r}
agg_weeks <- agg_weeks %>% 
  # Create week column from data_date
  mutate(
    week = lubridate::floor_date(                     # create new column of weeks
      data_date,                                      # date column
      unit = "week",                                  # give start of the week
      week_start = 1))                                # weeks to start on Mondays 
```

The new week column can be seen on the far right of the data frame

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Now we group the data into facility-weeks and summarise them to produce statistics per facility-week. See the page on \[Descriptive tables\] for tips. The grouping itself doesn't change the data frame, but it impacts how the subsequent summary statistics are calculated.

The top rows are shown below. Note how the columns have completely changed to reflect the desired summary statistics. Each row reflects one facility-week.

```{r, warning=F, message=F}
agg_weeks <- agg_weeks %>%   

  # Group into facility-weeks
  group_by(location_name, week) %>%
  
  # Create summary statistics columns on the grouped data
  summarize(
    n_days          = 7,                                          # 7 days per week           
    n_reports       = dplyr::n(),                                 # number of reports received per week (could be >7)
    malaria_tot     = sum(malaria_tot, na.rm = T),                # total malaria cases reported
    n_days_reported = length(unique(data_date)),                  # number of unique days reporting per week
    p_days_reported = round(100*(n_days_reported / n_days)))      # percent of days reporting
```

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Finally, we run the command below to ensure that ALL possible facility-weeks are present in the data, even if they were missing before.

We are using a `right_join()` on itself (the dataset is represented by ".") but having been expanded to include all possible combinations of the columns `week` and `location_name`. See documentation on the `expand()` function in the page on \[Pivoting\]. Before running this code the dataset contains `nrow(agg_weeks)` rows.

```{r, message=F, warning=F}
# Create data frame of every possible facility-week
expanded_weeks <- agg_weeks %>% 
  mutate(week = as.factor(week)) %>%         # convert date to a factor so expand() works correctly
  tidyr::expand(., week, location_name) %>%  # expand data frame to include all possible facility-week combinations
                                             # note: "." represents the dataset at that moment in the pipe chain
  mutate(week = as.Date(week))               # re-convert week to class Date so the subsequent right_join works
```

Here is `expanded_weeks`:

```{r, echo=F}
DT::datatable(expanded_weeks, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Before running this code, `agg_weeks` contains `nrow(agg_weeks)` rows.

```{r}
# Use a right-join with the expanded facility-week list to fill-in the missing gaps in the data
agg_weeks <- agg_weeks %>%      
  right_join(expanded_weeks) %>%                            # Ensure every possible facility-week combination appears in the data
  mutate(p_days_reported = replace_na(p_days_reported, 0))  # convert missing values to 0                           
```

After running this code, `agg_weeks` contains `nrow(agg_weeks)` rows.

<!-- ======================================================= -->

### Create heat plot {.unnumbered}

The `ggplot()` is made using `geom_tile()` from the **ggplot2** package:

-   Weeks on the x-axis is transformed to dates, allowing use of `scale_x_date()`\
-   `location_name` on the y-axis will show all facility names\
-   The `fill` is `p_days_reported`, the performance for that facility-week (numeric)\
-   `scale_fill_gradient()` is used on the numeric fill, specifying colors for high, low, and `NA`\
-   `scale_x_date()` is used on the x-axis specifying labels every 2 weeks and their format\
-   Display themes and labels can be adjusted as necessary

<!-- ======================================================= -->

### Basic {.unnumbered}

A basic heat plot is produced below, using the default colors, scales, etc. As explained above, within the `aes()` for `geom_tile()` you must provide an x-axis column, y-axis column, **and** a column for the the `fill =`. The fill is the numeric value that presents as tile color.

```{r}
ggplot(data = agg_weeks)+
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported))
```

### Cleaned plot {.unnumbered}

We can make this plot look better by adding additional **ggplot2** functions, as shown below. See the page on \[ggplot tips\] for details.

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                  # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```

<!-- ======================================================= -->

### Ordered y-axis {.unnumbered}

Currently, the facilities are ordered "alpha-numerically" from the bottom to the top. If you want to adjust the order the y-axis facilities, convert them to class factor and provide the order. See the page on \[Factors\] for tips.

Since there are many facilities and we don't want to write them all out, we will try another approach - ordering the facilities in a data frame and using the resulting column of names as the factor level order. Below, the column `location_name` is converted to a factor, and the order of its levels is set based on the total number of reporting days filed by the facility across the whole time-span.

To do this, we create a data frame which represents the total number of reports per facility, arranged in ascending order. We can use this vector to order the factor levels in the plot.

```{r}
facility_order <- agg_weeks %>% 
  group_by(location_name) %>% 
  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %>% 
  arrange(tot_reports) # ascending order
```

See the data frame below:

```{r, echo=F}
DT::datatable(facility_order, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Now use a column from the above data frame (`facility_order$location_name`) to be the order of the factor levels of `location_name` in the data frame `agg_weeks`:

```{r, warning=F, message=F}
# load package 
pacman::p_load(forcats)

# create factor and define levels manually
agg_weeks <- agg_weeks %>% 
  mutate(location_name = fct_relevel(
    location_name, facility_order$location_name)
    )
```

And now the data are re-plotted, with location_name being an ordered factor:

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                  # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```

<!-- ======================================================= -->

### Display values {.unnumbered}

You can add a `geom_text()` layer on top of the tiles, to display the actual numbers of each tile. Be aware this may not look pretty if you have many small tiles!

The following code has been added: `geom_text(aes(label = p_days_reported))`. This adds text onto every tile. The text displayed is the value assigned to the argument `label =`, which in this case has been set to the same numeric column `p_days_reported` that is also used to create the color gradient.

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  # text
  geom_text(
    aes(
      x = week,
      y = location_name,
      label = p_days_reported))+      # add text on top of tile
  
  # fill scale
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                    # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```

<!-- ======================================================= -->

## Resources

[scale_fill_gradient()](https://ggplot2.tidyverse.org/reference/scale_gradient.html)

[R graph gallery - heatmap](https://ggplot2.tidyverse.org/reference/scale_gradient.html)

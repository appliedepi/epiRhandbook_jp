# ヒートマップ

「ヒートプロット」や「ヒートタイル」とも呼ばれるヒートマップは3つの変数（x軸、y軸、色）を表示しようとするときに便利なビジュアライゼーションです。以下では、2つの例を示します：

-   年齢別の感染イベント（「誰から誰への感染か」）のビジュアルマトリクス\
-   多施設の報告率を時系列で追跡

```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "transmission_matrix.png"))

knitr::include_graphics(here::here("images", "heat_tile.png"))

```

<!-- ======================================================= -->

## 準備

### パッケージのロード {.unnumbered}

このコードチャンクは、解析に必要なパッケージの読み込みを示しています。このハンドブックでは **pacman** の `p_load()` の使用を推奨しています。まずはパッケージをインストールし、使用するためにロードする必要があります。インストールされたパッケージは ベース R から `library()` でロードすることもできます。R のパッケージについては \[Rの基礎\] のページを参照してください。

```{r}
pacman::p_load(
  tidyverse,       # データ操作と可視化
  rio,             # データのインポート
  lubridate        # 日付処理
  )
```

データセット

このページでは、感染伝播マトリックスのセクションではシミュレーションアウトブレイクの症例ラインリストを使用し、施設ごとの報告率の追跡のセクションでは、日別のマラリア患者数のデータセットを使用しています。これらのデータの読み込みとクリーニングは、それぞれのセクションで行います。

## 感染伝播マトリックス

ヒートマップは、マトリックスを視覚化するのに便利です。一つの例として、アウトブレイクにおける「誰から誰に感染がうつったか」を図示することが出来ます。これは、感染イベントに関するデータがあることが前提となっています。

なお、\[接触者の追跡\]ページには、別の（より単純な）データセットを用いて、ヒートマップによる接触マトリックスを作成する別の例が掲載されています。また、この同じデータを使って、\[ggplotの基礎\]のページで密度マップを作成しています。今回の例は、症例のラインリストから始まるので、プロット可能なデータフレームを得る前にかなりのデータ操作が必要ですが、その結果として多くのシナリオから選ぶことが可能になっています。。。

まずはエボラ出血熱の流行をシミュレーションしたラインリストを用います。[こちら](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds)から「綺麗な」ラインリスト（.rdsファイル）をダウンロードすることが出来ます。**rio** パッケージの `import()` 関数でデータをインポートすることが出来ます（.xlsx, .rds, .csv など多くのファイル形式のインポートが可能です - 詳しくは \[データのインポート・エクスポート\] ページを参照してください）。

ラインリストの最初の50行を以下に表示します：

```{r, echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```

このラインリストでは：

-   `case_id` が振られた1症例ごとに1行となっています。
-   `infector` 列には、感染者の `case_id` が含まれており、その感染者もラインリストの症例です。

```{r message=FALSE, echo=F}
# ラインリストを表で表示
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### データ準備 {.unnumbered}

**目的：** 全ての年代の組み合わせの感染ペアの行ごとに、ラインリストで観測されたすべての感染ペアに占める割合を持つ、「long」型のデータフレームを作成する必要があります。

これを実現するには、いくつかのデータ操作のステップが必要です：

#### 感染先のデータフレームの作成 {.unnumbered}

まず症例ID、年代、感染源のIDを含むデータフレームを作成し、`case_ages` という変数名をつけます。最初の50行は以下のように表示されます。

```{r}
case_ages <- linelist %>% 
  select(case_id, infector, age_cat) %>% 
  rename("case_age_cat" = "age_cat")
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(case_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### 感染源のデータフレームの作成 {.unnumbered}

次に、感染源のデータフレームを作成します。この時点では感染源ID のみの1列から構成されています。全ての症例の感染源が判明している訳ではないので、欠損値を削除しています。最初の50行は以下のように表示されます。

```{r}
infectors <- linelist %>% 
  select(infector) %>% 
  drop_na(infector)
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(infectors, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

次に、感染源の年代を取得します。これは簡単には出来ません。なぜなら、ラインリストには感染源の症例の年代がそのままは記載されていないからです。そのため、ラインリストと感染源IDを結合する必要があります。感染源のデータフレームから始めて、左側の「ベースライン」のデータフレームの感染者 ID 列と右側のラインリストの `case_id` 列を紐づけて、ラインリストを `left_join()` （追加）します。

このように、ラインリスト内の感染源の症例のデータ（年代）が、感染源の行に追加されます。最初の50行を以下に表示します。

```{r}
infector_ages <- infectors %>%             # 感染源のデータフレームから始める
  left_join(                               # それぞれの感染源の行にラインリストデータを追加する
    linelist,
    by = c("infector" = "case_id")) %>%    # infector列とcase id 列で紐付ける
  select(infector, age_cat) %>%            # 必要な列のみを抽出する
  rename("infector_age_cat" = "age_cat")   # 分かりやすいように列名を変更
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(infector_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

次に、感染先症例とその年代を、感染源症例とその年代と結合します。これらのデータフレームはそれぞれ `infector` という列を持っているので、この列で紐付けます。最初の行は以下のように表示されます。

```{r}
ages_complete <- case_ages %>%  
  left_join(
    infector_ages,
    by = "infector") %>%        # infector 列で紐付け
  drop_na()                     # 欠損値のある行を削除
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(ages_complete, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

以下は、感染先症例と感染源症例の年代階級別の症例数を単純にクロス集計したものです。分かりやすくするためにラベルをつけています。

```{r}
table(cases = ages_complete$case_age_cat,
      infectors = ages_complete$infector_age_cat)
```

この表をデータフレームに変換するには、base R の `data.frame()` を使います。これにより自動で「long」型のデータフレームとなり、`ggplot()` に適した形となります。最初の行は以下のようになります。

```{r}
long_counts <- data.frame(table(
    cases     = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat))
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(long_counts, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

さらに、base R の `prop.table()` をテーブルに適用して、数の代わりに全体の割合を出します。最初の50行は以下のようになります。

```{r}
long_prop <- data.frame(prop.table(table(
    cases = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat)))
```

```{r message=FALSE, echo=F}
# 表として表示
DT::datatable(head(long_prop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### ヒートマップの作成 {.unnumbered}

さて、いよいよ **ggplot2** パッケージで `geom_tile()` 関数を用いてヒートマップを作成します。色/塗りつぶしスケール、特に `scale_fill_gradient()` 関数についてより広範囲に学ぶには、 \[ggplotの基礎\] ページを参照して下さい。

-   `geom_tile()` の `aes()` で、x と y を case age と infector age に設定します。\

-   また、`aes()` では、引数 `fill =` を `Freq` 列に指定します - これはタイルの色に変換される値です\

-   `scale_fill_gradient()` でスケールカラーを設定します - ハイ/ローカラーを指定することが出来ます。

    -   `scale_color_gradient()` は違うことに注意してください! 今回は塗りつぶしが必要です。

-   色は 「fill」を介して作られるので、 `labs()` の `fill =` 引数を使えば、凡例のタイトルを変更することが出来ます。

```{r}
ggplot(data = long_prop)+       # 割合が Freq 列に格納された「long」データを使用
  geom_tile(                    # タイルで可視化
    aes(
      x = cases,         # x軸は感染先の年代
      y = infectors,     # y軸は感染源の年代
      fill = Freq))+            # タイルの色分けを Freq 列で決定する
  scale_fill_gradient(          # タイルの色を調整する
    low = "blue",
    high = "orange")+
  labs(                         # ラベル
    x = "Case age",
    y = "Infector age",
    title = "Who infected whom",
    subtitle = "Frequency matrix of transmission events",
    fill = "Proportion of all\ntranmsission events"     # 凡例タイトル
  )
  
```

<!-- ======================================================= -->

## 報告率の時系列

公衆衛生では、多くの施設、管轄区域などにおける経時的な傾向を評価することが目的の一つであることがよくあります。このような経時的な傾向を可視化する方法の1つが、横軸を時間、縦軸を各施設としたヒートマップです。

### データ準備 {.unnumbered}

まず、多施設におけるマラリアに関する日々の報告のデータセットをインポートします。データには、日付、州、地区、マラリアの症例数が含まれています。これらのデータをダウンロードする方法については、\[ハンドブックとデータのダウンロード\]のページを参照してください。以下は、最初の30行です。

```{r, echo=F}
facility_count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  select(location_name, data_date, District, malaria_tot)
```

```{r, eval=F}
facility_count_data <- import("malaria_facility_count_data.rds")
```

```{r, echo=F}
DT::datatable(head(facility_count_data,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

#### 集計とサマリー {.unnumbered}

**このセクションの目的**は、日別の施設ごとのマラリア患者数（前のタブで表示されています）を、週単位の施設ごとの報告率（この場合は、施設が何らかのデータを報告した日数の割合）に変換することです。以下の例では、**Spring 地区**のデータのみを表示します。

以下のステップを実行します：

1)  データを適切にフィルタリング（場所、日付ごと）します。\

2)  **lubridate** パッケージの `floor_date()` を使って week 列を作成します。

    -   この関数は、指定した日付の週の開始日を、指定した曜日（例："Mondays"）で返します。

3)  データは「場所」と「週」の列でグループ化され、"施設-週 "の分析単位が作成されます。\

4)  `summarise()` 関数は、施設-週グループごとの統計サマリーを反映させるための新しい列を作成します。

    -   1 週間の日数 (固定値7)\
    -   施設-週からの報告回数（7件以上の可能性もあります！）\
    -   施設-週で報告されたマラリア患者数の合計 (興味がある場合)\
    -   データが報告された施設-週における日数\
    -   **施設-週の7日間のうち、データが報告された日数の割合**

5)  このデータフレームを `right_join()` で、全ての施設-週の組み合わせを包括的なリストとして結合し、データセットを完成させます。全ての組み合わせの行列は、データフレーム（.で表されます）の2列に対して `expand()` 関数を適用することで作成されます。`right_join()` が使用されているので、`expand()` されたデータフレームのすべての行は保持され、必要であれば `agg_weeks` に追加されます。これらの新しい行は、`NA`（欠損値）の要約された値で表示されます。

以下順を追って説明します：

```{r, message=FALSE, warning=FALSE}
# 週別の集計を作成する
agg_weeks <- facility_count_data %>% 
  
  # データのフィルタリング
  filter(
    District == "Spring",
    data_date < as.Date("2020-08-01")) 
```

これでデータセットの行数が `nrow(agg_weeks)` となりました。

次に、各行の週の開始日を示す `week` 列を作成します。これは、**lubridate** パッケージと `floor_date()` 関数を使って行います。この関数は「週」に設定され、週の始まりが月曜日（週の1日目、日曜日は7日目）になるように設定されています。

```{r}
agg_weeks <- agg_weeks %>% 
  # data_date 列から week 列を作成
  mutate(
    week = lubridate::floor_date(                     # week 列を新たに作成
      data_date,                                      # 日付列
      unit = "week",                                  # 週の開始を指定
      week_start = 1))                                # 月曜スタートに指定 
```

新しい week 列は、データフレームの一番右に表示されます。

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

ここで、データを施設-週にグループ分けし、施設-週ごとの統計データを作成するために集計を行います。詳細は\[記述統計表の作り方\]のページを参照してください。グループ化自体はデータフレームを変更しませんが、その後の要約統計の計算に影響を与えます。

最初の30行を以下に示します。目的の要約統計量を反映するために、列が完全に変更されたことに注意してください。各行は、1つの施設-週を反映しています。

```{r, warning=F, message=F}
agg_weeks <- agg_weeks %>%   

  # 施設-週でグループ化
  group_by(location_name, week) %>%
  
  # グループ化されたデータに対して要約統計量の列を作成
  summarize(
    n_days          = 7,                                          # 1週間の日数（7日）
    n_reports       = dplyr::n(),                                 # 施設-週からの報告回数（7件以上の可能性あり）
    malaria_tot     = sum(malaria_tot, na.rm = T),                # 施設-週で報告されたマラリア患者数の合計
    n_days_reported = length(unique(data_date)),                  # データが報告された施設-週における日数
    p_days_reported = round(100*(n_days_reported / n_days)))      # 施設-週の7日間のうち、データが報告された日数の割合
```

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

最後に、以下のコマンドを実行して、報告のなかった週も含めて、可能性のある全ての施設-週の組み合わせがデータ中に存在することを確認します。

これは、`week` と `location_name` の列の全ての組み合わせを含むように拡張された、それ自身（データセットは「. 」で表されます）の `right_join()` を使用しています。詳細は\[データの縦横変換\]のページにある `expand()` 関数のドキュメントを参照してください。このコードを実行する前の段階ではデータセットには `nrow(agg_weeks)` 行が含まれています。

```{r, message=F, warning=F}
# 可能な全ての施設-週の組み合わせを作成
expanded_weeks <- agg_weeks %>% 
  mutate(week = as.factor(week)) %>%         # week 列をfactor型に変換
  tidyr::expand(., week, location_name) %>%  # 可能な全ての施設-週の組み合わせを含むようにデータを拡張
                                             # 注意: 「.」は%>%内のデータセットを意味します
  mutate(week = as.Date(week))               # week 列をDate型に変換
```

`expanded_weeks` は以下のようなデータになっています：

```{r, echo=F}
DT::datatable(expanded_weeks, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

以下のコードを実行する前の段階では、`agg_weeks` は `nrow(agg_weeks)` 行でした。

```{r}
# 拡張された施設週間リストと right-join して、データの欠損を補填
agg_weeks <- agg_weeks %>%      
  right_join(expanded_weeks) %>%                            # 可能な全ての施設-週の組み合わせが含まれるようにする
  mutate(p_days_reported = replace_na(p_days_reported, 0))  # 欠損値を0に変換
```

コードを実行した後は、`agg_weeks` は `nrow(agg_weeks)` 行に変わっています。

<!-- ======================================================= -->

### ヒートマップの作成 {.unnumbered}

`ggplot()` パッケージの `geom_tile()` を用いてグラフを作成します。

-   x軸の週はDate型に変換されているので、`scale_x_date()` が使用出来ます。\
-   y軸の `location_name` は全ての施設名を表示します。\
-   塗りつぶしは `p_days_reported` に対して行われ、その施設-週の報告率を示します。\
-   `scale_fill_gradient()` は数値の塗りつぶしに使用され、high, low, `NA` の色を指定します。\
-   x軸に `scale_x_date()` を使用し、2週間ごとのラベルとその形式を指定します。\
-   テーマやラベルを必要に応じて調整することが出来ます。

<!-- ======================================================= -->

### 基本プロット {.unnumbered}

基本的なヒートマップは、デフォルトの色やスケールなどを使用して、以下のように作成されます。上で説明したように、`geom_tile()` の `aes()` 内では、x軸、y軸、および `fill =` の列を指定する必要があります。 fill は色として表示される数値です。

```{r}
ggplot(data = agg_weeks)+
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported))
```

### 応用プロット {.unnumbered}

以下のように、**ggplot2** の関数を追加することで、このプロットをより良く出来ます。詳細は\[ggplotの基礎\]のページを参照して下さい。

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # データをタイルで表示
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # 罫線を白に指定
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # 日付軸
  scale_x_date(
    expand = c(0,0),             # 両端の余分なスペースを削除
    date_breaks = "2 weeks",     # 2週間ごとの日付ラベルを指定
    date_labels = "%d\n%b")+     # 月の上に日付を表示 (\n は改行を示す)
  
  # テーマ
  theme_minimal()+                                  # 背景を簡潔にする
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # 凡例の高さの指定
    legend.key.width  = grid::unit(0.6,"cm"),         # 凡例の幅の指定
    
    axis.text.x = element_text(size=12),              # 軸のテキストサイズの指定
    axis.text.y = element_text(vjust=0.2),            # 軸のテキストの場所の調整
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # 軸のタイトルのサイズの指定と太字フォントの指定
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # タイトルを右揃えにして、サイズを大きく、太字にする
    plot.caption = element_text(hjust = 0, face = "italic")  # 脚注を右揃えにしてイタリック体にする
    )+
  
  # 凡例
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # 凡例のタイトルを指定
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```

<!-- ======================================================= -->

### y軸の順番の調整 {.unnumbered}

現在、施設は下から上へ「アルファベット順」に並んでいます。y軸の施設の順番を調整したい場合は、因子型に変換して順番を指定してください。詳細は\[因子\]のページを参照して下さい。

施設数が多く、全てを書き出すのは大変なので、別の方法として、データフレームに施設を並べ、その結果得られる名前の列を因子レベルの順序とすることを試みます。以下では、`location_name` 列を因子に変換し、そのレベルの順序を、全期間における施設ごとの報告日の合計数に基づいて設定します。

そのために、まず施設ごとの総報告数を昇順に並べたデータフレームを作成します。このベクトルを使って、プロットにおける因子レベルの順序を決めることが出来ます。

```{r}
facility_order <- agg_weeks %>% 
  group_by(location_name) %>% 
  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %>% 
  arrange(tot_reports) # 昇順
```

データフレームは以下のようになります：

```{r, echo=F}
DT::datatable(facility_order, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

ここで、上記のデータフレームの列（`facility_order$location_name`）を使用して、データフレーム `agg_weeks` における `location_name` の因子レベルの順序とします。

```{r, warning=F, message=F}
# パッケージのロード
pacman::p_load(forcats)

# 因子を作成して、レベルを決める
agg_weeks <- agg_weeks %>% 
  mutate(location_name = fct_relevel(
    location_name, facility_order$location_name)
    )
```

そして、今度は location_name が順序付きの因子となるように、データを再プロットします。

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # データをタイルで表示
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # 罫線を白に指定
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # 日付軸
  scale_x_date(
    expand = c(0,0),             # 両端の余分なスペースを削除
    date_breaks = "2 weeks",     # 2週間ごとの日付ラベルを指定
    date_labels = "%d\n%b")+     # 月の上に日付を表示 (\n は改行を示す)
  
  # テーマ
  theme_minimal()+                                  # 背景を簡潔にする
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # 凡例の高さの指定
    legend.key.width  = grid::unit(0.6,"cm"),         # 凡例の幅の指定
    
    axis.text.x = element_text(size=12),              # 軸のテキストサイズの指定
    axis.text.y = element_text(vjust=0.2),            # 軸のテキストの場所の調整
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # 軸のタイトルのサイズの指定と太字フォントの指定
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # タイトルを右揃えにして、サイズを大きく、太字にする
    plot.caption = element_text(hjust = 0, face = "italic")  # 脚注を右揃えにしてイタリック体にする
    )+
  
  # 凡例
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # 凡例のタイトルを指定
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```

<!-- ======================================================= -->

### 値の表示 {.unnumbered}

タイルの上に `geom_text()`レイヤーを追加して、各タイルの数値を表示することが出来ます。小さなタイルがたくさんある場合、小さくてはっきり見えないかも知れないので注意して下さい!

以下のコードを追加しています： `geom_text(aes(label = p_days_reported))` これは、各タイルにテキストで数値を追加します。表示される数字は、引数 `label =` に割り当てられた値で、以下の例では色のグラデーションを作成するためにも使用されているのと同じ数値列 `p_days_reported` を指定しています。

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # データをタイルで表示
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # 罫線を白に指定
  
  # テキスト
  geom_text(
    aes(
      x = week,
      y = location_name,
      label = p_days_reported))+      # タイルの上に数値を表示
  
  # タイルの塗りつぶし
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # 日付軸
  scale_x_date(
    expand = c(0,0),             # 両端の余分なスペースを削除
    date_breaks = "2 weeks",     # 2週間ごとの日付ラベルを指定
    date_labels = "%d\n%b")+     # 月の上に日付を表示 (\n は改行を示す)
  
  # テーマ
  theme_minimal()+                                    # 背景を簡潔にする
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # 凡例の高さの指定
    legend.key.width  = grid::unit(0.6,"cm"),         # 凡例の幅の指定
    
    axis.text.x = element_text(size=12),              # 軸のテキストサイズの指定
    axis.text.y = element_text(vjust=0.2),            # 軸のテキストの場所の調整
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # 軸のタイトルのサイズの指定と太字フォントの指定
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # タイトルを右揃えにして
    plot.caption = element_text(hjust = 0, face = "italic")  # 脚注を右揃えにしてイタリック体にする
    )+
  
  # 凡例
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # 凡例のタイトルを指定
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```

<!-- ======================================================= -->

## リソース

[scale_fill_gradient()](https://ggplot2.tidyverse.org/reference/scale_gradient.html)

[R graph gallery - heatmap](https://ggplot2.tidyverse.org/reference/scale_gradient.html)

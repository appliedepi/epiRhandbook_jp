# ggplot の基本

```{r, out.width=c('100%', '100%'), fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "ggplot_basics_top.png"))
```

**ggplot2** は、最も人気のあるデータビジュアライゼーションの R パッケージです。`ggplot()` 関数はこのパッケージの中核であり、このアプローチ全体が "ggplot" として口語的に知られており、結果として得られる図は親しみを込めて "ggplots" と呼ばれることもあります。これらの名前の "gg" は、図を作成するために使用される "グラフィックスの文法" を反映しています。 ggplot2 は、その機能性をさらに向上させるさまざまな補助的な R パッケージの恩恵を受けています。

構文は **base** `R` のプロッティングとは大きく異なり、それに伴って知識を獲得できるまで時間がかかります。**ggplot2** を使用するには、一般的にユーザーは **Tidyverse** との互換性が高い方法でデータをフォーマットする必要があり、結果的にこれらのパッケージを一緒に使用することは非常に効果的です。

このページでは、**ggplot2** を使ったプロッティングの基礎を説明します。プロットをきれいに見せるための提案や高度なテクニックについては、\[ggplot tips\] のページを参照してください。

リソースセクションにリンクされているいくつかの広範な **ggplot2** チュートリアルがあります。また、RStudio のウェブサイトから [ggplot によるデータビジュアライゼーションのチートシート](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf)をダウンロードすることができます。データを創造的に可視化する方法のインスピレーションを得たい場合は、[R graph gallery](https://www.r-graph-gallery.com/) や[Data-to-viz](https://www.data-to-viz.com/caveats.html) のようなウェブサイトを参照することをお勧めします。

<!-- ======================================================= -->

## 準備

### パッケージの読み込み {.unnumbered}

このコードチャンクは、分析に必要なパッケージのロードを示しています。このハンドブックでは **pacman** の `p_load()` を重視しています。`p_load()` は必要に応じてパッケージをインストールし、使用するためにパッケージをロードします。インストールされたパッケージは **base** R の `library()` でもロードできます。R のパッケージに関する詳細は \[R basics\] のページをご覧ください。

```{r}
pacman::p_load(
  tidyverse,      # ggplot2 やその他データマネジメントに関するツールが含まれています
  rio,            # インポートとエクスポート
  here,           # ファイル・ロケーター
  stringr         # 文字列に関する作業   
)
```

### データのインポート {.unnumbered}

エボラ出血熱のシミュレーションによる症例のデータセットをインポートします。分析をフォローしたい方は、\<a href='<https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds'> class='download-button'>クリックして "クリーンな" ラインリストをダウンロードしてください\</a>（.rdsファイルとして）。**rio** パッケージの `import()` 関数を使ってデータをインポートします（.xlsx, .rds, .csv などの多くのファイルタイプを受け付けます。詳細は \[Import and export\] ページをご覧ください）。

```{r, echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.rds")
```

ラインリストの最初の 50 行を以下に表示します。ここでは、連続変数である `age`、`wt_kg`（キログラム単位の体重）、`ct_blood`（CT値）、`days_onset_hosp`（発症日と入院日の差）に注目します。

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### 一般的なクリーニング {.unnumbered}

プロット用のデータを準備する際には、できるだけ ["tidyな（整然とした）" データの基準](https://r4ds.had.co.nz/tidy-data.html)に沿うようにするのがよいでしょう。その方法については、本ハンドブックのデータ管理のページ、\[Cleaning data and core functions\] などで説明しています。

プロットに適したデータを準備する簡単な方法としては、データの内容を表示に適したものにすることが挙げられますが、これは必ずしもデータ操作に適しているとは限りません。例えば、次のようなことです。

-   文字列の `NA` 値を "Unknown" という文字列で置き換える。

-   列の値が所定の序列レベルになるように[因子]{.ul}クラスに変換することを検討する。

-   アンダースコアなどの "データに適した" 値を通常のテキストまたはタイトルケースに変更するように、一部の列をクリーニングする（ \[Cleaning data and core functions\] を参照）。

以下に、この作業の例を示します。

```{r, }
# 列の表示をより分かりやすい名前にする
linelist <- linelist %>%
  mutate(
    gender_disp = case_when(gender == "m" ~ "Male",        # m を Male に
                            gender == "f" ~ "Female",      # f を Female に
                            is.na(gender) ~ "Unknown"),    # NA を Unknown に
    
    outcome_disp = replace_na(outcome, "Unknown")          # outcome の NA を Unknown に置換
  )
```

### 縦長のデータへの転回 {.unnumbered}

データ構造の問題として、**ggplot2** ではデータを転回して[縦に長い]{.ul}フォーマットにしたいこともよくあります。詳しくは \[Pivoting data\] のページをご覧ください。

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```

For example, say that we want to plot data that are in a "wide" format, such as for each case in the `linelist` and their symptoms. Below we create a mini-linelist called `symptoms_data` that contains only the `case_id` and symptoms columns.

例えば、`linelist` に登録されている各症例とその症状のような、 "横に広い" フォーマットのデータについてプロットしたいとします。以下では、`symptoms_data` という mini-linelist を作成し、`case_id` とsymptomsのカラムのみを格納します。

```{r}
symptoms_data <- linelist %>% 
  select(c(case_id, fever, chills, cough, aches, vomit))
```

この mini-linelist の最初の 50 行は次のようになっています。それぞれの症状を列にして "横に広く" フォーマットされているのがわかります。

```{r, message=FALSE, echo=F}
# 表として linelist を表示する
DT::datatable(head(symptoms_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

特定の症状を持つ症例の数をプロットしたい場合、各症状が特定の列であるという事実によって制限されます。しかし、症状の列を[転回]{.ul}して、次のように縦に長いフォーマットにすることができます。

```{r, }
symptoms_data_long <- symptoms_data %>%    # symptoms_data と名付けた "mini" linelist から始める
  
  pivot_longer(
    cols = -case_id,                       # case_id を除いた全ての列（全ての症状に関する列）を転回する
    names_to = "symptom_name",             # 症状に関する新しい列の名前を割り当てる
    values_to = "symptom_is_present") %>%  #  「はい、もしくはいいえ」の値をもつ新しい列の名前を割り当てる
  
  mutate(symptom_is_present = replace_na(symptom_is_present, "unknown")) # NA を unknown に変換する

```

こちらが最初の 50 行です。case には 5 つの行があることに注意してください - それぞれの症状ごとに 1 つの列があります。新しい列である `symptom_name` と `symptom_is_present` は、転回した結果です。このフォーマットは、他の操作にはあまり役に立たないかもしれませんが、プロットには便利であることに注意してください。

```{r, message=FALSE, echo=F}
DT::datatable(head(symptoms_data_long, 50), rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## ggplotの基礎

**"グラフィックの文法" - ggplot2**

**ggplot2** でのプロットは、作図レイヤーやデザイン要素を重ねて "追加" することが基本で、各コマンドはプラス記号（`+`）で前のコマンドに追加されます。結果として、保存、修正、印刷、エクスポートなどが可能なマルチレイヤーの作図オブジェクトができあがります。

ggplot オブジェクトは非常に複雑になることがありますが、基本的なレイヤーの順番は、通常次のようになります。

1.  ベースラインの `ggplot()` コマンドから始めます。これは ggplot を "開く" もので、後続の関数を `+` で追加することができます。通常、データセットもこのコマンドで指定します。

2.  "geom" レイヤーの追加 - これらの関数は、データを棒グラフ、折れ線グラフ、散布図、ヒストグラムなどの[幾何学（図形）]{.ul}として視覚化します（組み合わせも可能です）。これらの関数は、すべて接頭辞として `geom_` で始まります。

3.  軸ラベル、タイトル、フォント、サイズ、配色、凡例、軸回転などのデザイン要素をプロットに追加する。

骨格となるコードの簡単な例を以下に示します。それぞれの要素については，以下のセクションで説明します。

```{r, eval=F}
# my_data の列を赤い点としてデータをプロットする
ggplot(data = my_data)+                   # "my_data" というデータを使う
  geom_point(                             # 点（ドット）のレイヤーを追加する
    mapping = aes(x = col1, y = col2),    # "map" の列を軸にする
    color = "red")+                       # geom の他の設定
  labs()+                                 # タイトル、軸ラベル、などを追加する
  theme()                                 # 色、フォント、サイズなどデータではない要素（軸やタイトルなど）を編集する
```

## `ggplot()`

ggplot2 のプロットの最初のコマンドは `ggplot()` です。このコマンドは、レイヤーを追加するための真っ白なキャンバスを作成します。さらに、`+` 記号でレイヤーを追加するための方法を "開放" します。

通常、`ggplot()` コマンドは、プロットのために `data =` 引数を含みます。これは、プロットの後続のレイヤーに使用されるデフォルトのデータセットを設定します。

このコマンドは、閉じた括弧の後に `+` を付けて終了します。これは、コマンドを "オープン" な状態にします。ggplot は、完全なコマンドが最後に + の[ない]{.ul}最後のレイヤーを含む場合にのみ、実行/表示されます。

```{r, eval=F}
# これは真っ白なキャンバスであるプロットを作成します
ggplot(data = linelist)
```

## Geoms

真っ白なキャンバスではもちろん十分ではありません。データから幾何学（図形）を作成する必要があります（例：棒グラフ、ヒストグラム、散布図、箱ひげ図）。

これは、最初の `ggplot()` コマンドにレイヤー "geom" を追加することで行います。"geom" を作成する多くの **ggplot2** 関数があります。これらの関数はそれぞれ "geom\_" で始まるので、ここでは `geom_XXXX()` と一般的に呼びます。**ggplot2** には 40 以上のジオムがあり、ファンが作ったものもたくさんあります。[ggplot2 gallery](https://exts.ggplot2.tidyverse.org/gallery/) でそれらを見ることができます。いくつかの一般的な geom を以下に示します。

-   ヒストグラム - `geom_histogram()`

-   棒グラフ - `geom_bar()` or `geom_col()` （棒グラフのセクションをご覧ください）

-   箱ひげ図 - `geom_boxplot()`

-   点（例：散布図） - `geom_point()`

-   折れ線グラフ - `geom_line()` or `geom_path()`

-   傾向線 - `geom_smooth()`

1つのプロットで、1つまたは複数の geom を表示できます。それぞれの geom は、前の **ggplot2** コマンドに `+` で追加され、後の geom が前の geom の上にプロットされるように、順次プロットされます。

## データをプロットにマッピング {#ggplot_basics_mapping}

ほとんどの geom 関数は、形状を作成するために[何を]{.ul}使用するかを指示する必要があります。つまり、軸、形状の色、形状のサイズなどのプロットの構成要素にどのように[データの列をマッピング（割り当て）]{.ul}するかを指示する必要があります。ほとんどの geom では、データの列にマッピングされなければならない[必要不可欠な]{.ul}要素は、X軸と（必要に応じて）Y軸です。

この "マッピング" は、`mapping =` という引数で行われます。`mapping` に与えるマッピングは、`aes()` 関数でラップしなければならないので、以下のように、`mapping = aes(x = col1, y = col2)` のように記述します。

以下、`ggplot()` コマンドでは、`linelist` の症例がデータとして設定されています。`mapping = aes()` の引数では、`age` 列が x 軸に、`wt_kg` 列が y 軸にマッピングされています。

`+` の後にプロットコマンドが続きます。"geom" 関数 `geom_point()` で図形を作成します。この geom は、上記の `ggplot()` コマンドのマッピングを[継承しています]{.ul}。つまり、軸と列の割り当てを知り、それらの関係をキャンバス上の[点]{.ul}として視覚化していきます。

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+
  geom_point()
```

別の例として、以下のコマンドでは、同じデータを使用して、わずかに異なるマッピングと異なる geom を使用しています。`geom_histogram()` 関数では、X軸にマッピングされた列が必要なだけで、Y軸のカウントは自動的に生成されます。

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()
```

### プロットの美学 {.unnumbered}

ggplotの用語では、プロットの "美学" には特定の意味があります。これは、[プロットされたデータ]{.ul}の視覚的特性を意味します。ここでの "美学" は、[プロットされたデータの幾何学的形状]{.ul}を意味しており、タイトル、軸ラベル、背景色など、一般的な英語で "美学" という言葉から連想されるような周辺の表示は含まれていないことに注意してください。ggplot では、これらの詳細は "theme" と呼ばれ、`theme()` コマンドで調整されます（[このセクション](#ggplot_basics_themes)を参照）。

したがって、プロットオブジェクトの[美学]{.ul}とは、[プロットされたデータ]{.ul}の色、サイズ、透過性、配置などのことです。すべての geom が同じ美観オプションを持つわけではありませんが、多くの geom で使用することができます。以下にいくつかの例を示します。

-   `shape =` `geom_point()` で指定した点を、点、星、三角、四角...のように表示します。

-   `fill =` 棒グラフや箱ひげ図などの内側の色

-   `color =` 棒グラフや箱ひげ図などの外郭線、または `geom_point()` を使用する場合は点の色。\

-   `size =` 大きさ（線の太さ、点の大きさなど）

-   `alpha =` 透過度（1 = 不透明、0 = 不可視）

-   `binwidth =` ヒストグラムのビンの幅

-   `width =` "棒グラフ" の列の幅

-   `linetype =` 線の種類 (例：実線、破線、点線)

これらのプロットオブジェクトの美しさは、2つの方法で値を割り当てることができます。

1.  静的な値（例：`color = "blue"`）を割り当て、プロットされたすべてのオブザベーションに適用する。

2.  データの列に割り当てられ（例：`color = "hospital"`）、各観測値の表示はその列の値に依存する。

<!-- *These non-axis aesthetics can be assigned static values (e.g. `size = 1`) or can be mapped to a column (e.g. `size = age`).* If you want the aesthetic to be assigned a static value, the assignment is placed *outside* the `mapping = aes()`. If you want the aesthetic to be scaled/depend on the value in each row of data, the assignment is made *inside* the `mapping = aes()`.   -->

### 静的な値の設定 {.unnumbered}

プロットオブジェクトの美的感覚を静的なものにしたい場合、つまり、データの中のすべての観測値に対して同じものにしたい場合は、geom の中にその割り当てを記述しますが、`mapping = aes()` の引数の外に記述します。これらの割り当ては、`size = 1` や `color = "blue"` のようになります。以下に2つの例を示します。

-   １つ目の例では、`mapping = aes()` は `ggplot()` コマンドの中にあり、軸にはデータの中の年齢と体重の列がマッピングされています。プロットの美学である `color =`, `size =`, `alpha =` （透明度）は静的な値に割り当てられています。わかりやすくするために、これは`geom_point()` 関数の中で行われていますが、後から他の geom を追加してプロットの美観に異なる値を設定することもできます。

-   ２つ目の例では、ヒストグラムでは X 軸のみを列にマッピングする必要があります。ヒストグラムの `binwidth =`, `color =`, `fill =`（内部色）, `alpha =` は、再び geom 内で静的な値に設定されます。

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# 散布図
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # データと軸のマッピングを設定
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)         # 静的な点の美観を設定

# ヒストグラム
ggplot(data = linelist, mapping = aes(x = age))+       # データと軸を設定
  geom_histogram(              # ヒストグラムを表示
    binwidth = 7,                # ビンの広さ
    color = "red",               # ビンの線の色
    fill = "blue",               # ビンの内側の色
    alpha = 0.1)                 # ビンの透過度
```

### 列の値に応じたスケーリング {.unnumbered}

もう一つの方法は、プロットオブジェクトの美しさを列の値でスケールすることです。この方法では、この美的感覚の表示は、データのその列における観測値に依存することになります。列の値が連続的であれば、その美的感覚の表示尺度（凡例）は連続的になります。列の値が離散的であれば、凡例には各値が表示され、プロットされたデータは明確に "グループ化" されているように見えます（詳しくはこのページの[グループ化](#ggplotgroups)のセクションをご覧ください）。

これを実現するには、プロットの美学を[列名]{.ul}（引用符で囲まれていないもの）にマッピングします。これは、[`mapping = aes()` 関数内で]{.ul}行う必要があります（注：[後述するように](##ggplot_basics_map_loc)、コード内にはマッピングの割り当てを行う場所がいくつかあります）。

以下に2つの例を示します。

-   １つ目の例では、（各ポイントの）`color =` が `age` の列にマッピングされ、凡例にスケールが表示されています。この例では、目盛りが存在していることを覚えておいてください。後ほどそれらを修正する方法を示します。

-   ２つ目の例では、2つの新しいプロットの美学が列にマッピングされています（`color =` と `size =`）。一方、プロットの美学である `shape =` と `alpha =` は、`mapping = aes()` 関数を使わずに、静的な値にマッピングされています。

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# 散布図
ggplot(data = linelist,   # データを設定
       mapping = aes(     # 列名をマッピング
         x = age,           # x 軸に age をマッピング
         y = wt_kg,         # y 軸に weight をマッピング
         color = age)
       )+     # color に age をマッピング
  geom_point()         # データを点として表示 

# 散布図
ggplot(data = linelist,   # データを設定
       mapping = aes(     # 列名をマッピング
         x = age,           # x 軸に age をマッピング           
         y = wt_kg,         # y 軸に weight をマッピング
         color = age,       # color に age をマッピング
         size = age))+      # size に age をマッピング
  geom_point(             # データを点として表示
    shape = "diamond",      # 点を菱形として表示
    alpha = 0.3)            # 点の透過度を30%として表示


```

注：軸の割り当ては、常にデータの列に割り当てられます（静的な値ではありません）。これは常に `mapping = aes()` 内で行われます。

複数の geom を持つプロットなど、より複雑なプロットを作成する場合には、プロットのレイヤーと美観を追跡することが重要になります。以下の例では、`size =` が `geom_point()` と `geom_smooth()` の2回割り当てられていますが、どちらも静的な値です。

```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(           # map aesthetics to columns
         x = age,
         y = wt_kg,
         color = age_years)
       ) + 
  geom_point(                   # データの各行に点を追加
    size = 1,
    alpha = 0.5) +  
  geom_smooth(                  # トレンドラインの追加
    method = "lm",              # 線形性に基づく方法
    size = 2)                   # サイズ（線の太さ）を2に
```

### マッピングのアサインをする場所 {#ggplot_basics_map_loc .unnumbered}

Aesthetic mapping within `mapping = aes()` can be written in several places in your plotting commands and can even be written more than once. This can be written in the top `ggplot()` command, and/or for each individual geom beneath. The nuances include:

`mapping = aes()` 内のエステティックマッピングは、プロットコマンドの中のいくつかの場所に書くことができ、また複数回書くこともできます。これは、一番最初の `ggplot()` コマンドの中に書くこともできますし、その下の個々の geom ごとに書くこともできます。ニュアンスは以下の通りです。

-   トップの `ggplot()` コマンドで作成されたマッピング割り当ては、 `x =` と `y =` が継承されるように、下にあるすべての geom でデフォルトとして継承されます。

-   1つのジオム内で行われたマッピング割り当ては、そのジオムにのみ適用されます。

同様に、トップの `ggplot()` で指定された `data =` は、それ以下のすべての geom にデフォルトで適用されますが、geom ごとにデータを指定することもできます（ただし、これはより難しいです）。

このように、以下の各コマンドは同じプロットを作成します。

```{r, eval=F, warning=F, message=F}
# これらのコマンドは、同じプロットを作成します。
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()

ggplot(data = linelist)+
  geom_histogram(mapping = aes(x = age))

ggplot()+
  geom_histogram(data = linelist, mapping = aes(x = age))
```

### グループ {#ggplotgroups .unnumbered}

データをグループ化して "グループ別にプロット" することも簡単にできます。実際に、あなたはすでにこれを行っています。

`mapping = aes()` の中で、"グループ化" 列を適切なプロットの美学に割り当てます。上の例では、連続値の場合、`age` 列にポイント `size =` を割り当てました。しかし、これは離散的・カテゴリカルな列にも同じように作用します。

例えば、ポイントを性別ごとに表示したい場合は、`mapping = aes(color = gender)` とします。凡例が自動的に表示されます。この割り当ては、トップの `ggplot()` コマンドの中の `mapping = aes()` の中で行うことができます（そして、geom に継承されます）。また、geom の中の別の `mapping = aes()` の中で設定することもできます。両方の方法を以下に示します。

```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg, color = gender))+
  geom_point(alpha = 0.5)
```

```{r, eval=F}
# この代替コードも、同じプロットを生成します。
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg))+
  geom_point(
    mapping = aes(color = gender),
    alpha = 0.5)

```

geom に応じて、データをグループ化するために異なる引数を使用する必要があることに注意してください。`geom_point()` の場合は、`color =`, `shape =`, `size =` のいずれかを使用することになるでしょう。 一方、`geom_bar()` の場合は、`fill =` を使用することになるでしょう。 これは、geom と、グループ化を反映させたいプロットの美しさに依存しています。

参考までに、データをグループ化する最も基本的な方法は、`mapping = aes()` の`group =` 引数のみを使用することです。しかし、これだけでは、色、塗りつぶし、形は変わりません。また、凡例も作成されません。しかし、データはグループ化されているので、統計表示には影響があるかもしれません。

プロット内のグループの順序を調整するには、\[ggplot tips\] のページまたは \[Factors\] のページを参照してください。グループ化されたプロットの例は、以下の連続データやカテゴリーデータのプロットのセクションにたくさんあります。

## Facets / Small-multiples {#ggplot_basics_facet}

ファセット、もしくは、"small-multiples" とは、1つのプロットを複数のパネルに分割するためのもので、データグループごとに1つのパネル（ "ファセット" ）が用意されている。同じ種類のプロットが複数回作成され、それぞれが同じデータセットのサブグループを使用してものになります。

ファセット化は **ggplot2** に付属する機能で、ファセット化された "パネル" の凡例と軸は自動的に整列します。\[ggplot tips\] のページで説明されている他のパッケージもあり、全く異なるプロット（**cowplot** や **patchwork** ）を1つの図にまとめるのにも使われます。

ファセット化は、以下の **ggplot2** 関数のいずれかで行います。

1.  `facet_wrap()` [一つの変数]{.ul}の各レベルごとに異なるパネルを表示する。この例としては、地域の病院ごとに異なる流行曲線を表示することができます。ファセットは、変数が他の順序が定義された因子でない限り、アルファベット順に並べられます。

-   ファセットのレイアウトを決定するために、特定のオプションを呼び出すことができます。例えば、`nrow = 1` または `ncol = 1` で、ファセット化されたプロットが配置される行または列の数を制御することができます。

2.  `facet_grid()` これは、第二の変数をファセットの配置に加えたいときに使用します。ここでは、グリッドの各パネルは、[2つの列]{.ul}の値の間の交点を示しています。例えば、病院と年齢グループの組み合わせごとに、病院が上（列）に、年齢グループが横（行）に沿った疫学曲線を示します。

-   サブグループがグリッドで表示されるため、`nrow` および `ncol` は関係ありません。

これらの関数はそれぞれ、ファセット化する列を指定するための数式シンタックスを受け付けます。両方とも、チルダ `~` の両側に 1 つずつ、最大 2 つの列を受け入れます。

-   `facet_wrap()`では、多くの場合、`facet_wrap(~hospital)` のようにチルダ `~` を先行させて1つの列だけを記述します。しかし、`facet_wrap(outcome ~ hospital)` のように2つの列を書くこともできます。それぞれのユニークな組み合わせは、別のパネルに表示されますが、グリッドには配置されません。見出しには結合された用語が表示され、これらは列と行の間の特定のロジックではありません。ファセット変数を1つだけ指定する場合は、ピリオド `.` が数式の反対側のプレースホルダーとして使用されます（コード例を参照）。

-   `facet_grid()` では、数式に1つまたは2つの列を指定することもできます（グリッドの `row ~ columns` ）。1つだけ指定したい場合は、`facet_grid(. ~ hospital)` や `facet_grid(hospital ~ .)` のように、チルダの反対側にピリオド `.` を置くことができます。

ファセットはすぐに圧倒的な量の情報を含むことができるので、ファセットを選択する各変数のレベルが多すぎないようにするのが良いでしょう。ここでは、malaria データセット（ \[Download handbook and data\] 参照）を使った簡単な例を紹介します。malaria データセットは、施設におけるマラリアの毎日の症例数を年齢層別に集計したものです。

以下では、インポートして、簡単な修正を行います。

```{r, , warning=F, message=F}
# これらのデータは、マラリアの症例を施設ごとに日ごとにカウントしたものです。
malaria_data <- import(here("data", "malaria_facility_count_data.rds")) %>%  # インポート
  select(-submitted_date, -Province, -newid)                                 # 不要な列の削除

```

malaria データの最初の 50 行を以下に示します。`malaria_tot` という列がありますが、年齢グループ別のカウントの列もあります（これらは 2 番目の `facet_grid()` の例で使用されます）。

```{r, message=FALSE, echo=F}
DT::datatable(head(malaria_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### `facet_wrap()` {.unnumbered}

とりあえず、`malaria_tot` と `District` の列に注目してみましょう。年齢別カウントの列は今回は無視します。`geom_col()` を使って流行曲線をプロットします。これは、`malaria_tot` 列で指定された y 軸の高さに、各日の列を生成します（データはすでに日ごとのカウントなので、`geom_col()` を使います - [棒グラフ](#ggplot_basics_bars)を参照）。

`facet_wrap()` コマンドを追加する際には、チルダを指定し、次にファセットする列を指定します（ここでは `District` ）。チルダの左側に別の列を配置することもできますが、これは各組み合わせに対して 1 つのファセットを作成することになりますので、代わりに `facet_grid()` で行うことをお勧めします。この使用例では、`District` のユニークな値ごとに 1 つのファセットが作成されます。

```{r, warning=F, message=F}
# District によってファセットされたプロット
ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1, fill = "darkred") +       # カウントデータを列としてプロットする
  theme_minimal()+                              # 背景のパネルを簡素化する
  labs(                                         # プロットのラベルやタイトルなどを追加する
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district") +
  facet_wrap(~District)                       # ファセットが作られる
```

### `facet_grid()` {.unnumbered}

`facet_grid()` を使って、2つの変数をクロスさせることができます。例えば、`District` と age を交差させたいとしましょう。さて、これらのデータをggplotが好む "縦に長い" フォーマットにするために、年齢の列にいくつかのデータ変換を行う必要があります。年齢グループはそれぞれ独自の列を持っていますが、ここでは `age_group` という1つの列と `num_cases` という別の列に分けます。このプロセスの詳細については、\[データのピボット\] のページを参照してください。

```{r, message=F, warning=F}
malaria_age <- malaria_data %>%
  select(-malaria_tot) %>% 
  pivot_longer(
    cols = c(starts_with("malaria_rdt_")),  # 縦長に転回する列を選ぶ
    names_to = "age_group",      # 列名を age_group になる
    values_to = "num_cases"      # 値を1つの列（num_cases）にまとめる
  ) %>%
  mutate(
    age_group = str_replace(age_group, "malaria_rdt_", ""),
    age_group = forcats::fct_relevel(age_group, "5-14", after = 1))
```

これで、最初の 50 行のデータは次のようになります。

```{r, message=FALSE, echo=F}
DT::datatable(head(malaria_age, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

When you pass the two variables to `facet_grid()`, easiest is to use formula notation (e.g. `x ~ y`) where x is rows and y is columns. Here is the plot, using `facet_grid()` to show the plots for each combination of the columns `age_group` and `District`.

2 つの変数を `facet_grid()` に渡すとき、x が行、y が列である数式表記 (例: `x ~ y` ) を使用するのが最も簡単です。ここでは、`facet_grid()` を使って、 `age_group` と`District` の列の組み合わせごとにプロットを表示しています。

```{r, message=F, warning=F}
ggplot(malaria_age, aes(x = data_date, y = num_cases)) +
  geom_col(fill = "darkred", width = 1) +
  theme_minimal()+
  labs(
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district and age group"
  ) +
  facet_grid(District ~ age_group)
```

### 自由軸または固定軸 {.unnumbered}

ファセット化の際に表示される軸のスケールは、デフォルトではすべてのファセットで同じ（固定）になっています。これは、相互比較には便利ですが、必ずしも適切ではありません。

`facet_wrap()` または `facet_grid()` を使用する場合、`scales = "free_y "` を追加して、"free" またはパネルの y 軸を解放して、そのデータサブセットに適切なスケールにすることができます。これは、サブカテゴリーの 1 つで実際のカウントが小さく、トレンドが見えにくい場合に特に有効です。また、"free_y" の代わりに "free_x" と書けば、x 軸（日付など）にも同じことができますし、両方の軸に "free" と書くこともできます。`facet_grid` では、同じ行のファセットでは y スケールが同じになり、同じ列のファセットでは x スケールが同じになることに注意してください。

`facet_grid` のみを使用する場合、`space = "free_y"` または `space = "free_x"` を追加することで、ファセットの実際の高さまたは幅が中の図の値に重み付けされます。これは、`scales = "free"`（ y または x ）がすでに適用されている場合にのみ機能します。

```{r, message=FALSE, warning=FALSE}

# 自由な y 軸
ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1, fill = "darkred") +       # カウントデータを列としてプロットする
  theme_minimal()+                              # 背景のパネルを簡素化する
  labs(                                         # プロットのラベルやタイトルなどを追加する
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district - 'free' x and y axes") +
  facet_wrap(~District, scales = "free")        # ファセットが作られる
```

<!-- ```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')} -->

<!-- # A) Facet hospitalsation date by hospital, free y axis -->

<!-- ggplot(data = linelist %>% filter(hospital != "Missing"), # filter removes unknown hospital -->

<!--        aes(x = date_hospitalisation ))+ -->

<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->

<!--   labs(title = "A) Histogram with free y axis scales")+ -->

<!--   facet_grid(hospital~., # Facet with hospital as the row  -->

<!--              scales = "free_y") # Free the y scale of each facet -->

<!-- # B) Facet hospitalisation date by hospital, free y axis and vertical spacing -->

<!-- ggplot(data = linelist %>% filter(hospital != "Missing"), # filter removes unknown hospital -->

<!--        aes(x = date_hospitalisation ))+ -->

<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->

<!--   labs(title = "B) Histogram with free y axis scales and spacing")+ -->

<!--   facet_grid(hospital~., # Facet with hospital as the row  -->

<!--              scales = "free_y", # Free the y scale of each facet -->

<!--              space = "free_y") # Free the vertical spacing of each facet to optimise space -->

<!-- ``` -->

### ファセット内の因子レベルの順序 {.unnumbered}

[ファセット内]{.ul}の因子レベルの順序を変更する方法については、こちらの[記事](https://juliasilge.com/blog/reorder-within/)を参照してください

## Storing plots

### Saving plots {.unnumbered}

By default when you run a `ggplot()` command, the plot will be printed to the Plots RStudio pane. However, you can also save the plot as an object by using the assignment operator `<-` and giving it a name. Then it will not print unless the object name itself is run. You can also print it by wrapping the plot name with `print()`, but this is only necessary in certain circumstances such as if the plot is created inside a *for loop* used to print multiple plots at once (see \[Iteration, loops, and lists\] page).

```{r, warning=F, message=F}
# define plot
age_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+
  geom_point(alpha = 0.1)

# print
age_by_wt    
```

### Modifying saved plots {.unnumbered}

One nice thing about **ggplot2** is that you can define a plot (as above), and then add layers to it starting with its name. You do not have to repeat all the commands that created the original plot!

For example, to modify the plot `age_by_wt` that was defined above, to include a vertical line at age 50, we would just add a `+` and begin adding additional layers to the plot.

```{r, warning=F, message=F}
age_by_wt+
  geom_vline(xintercept = 50)
```

### Exporting plots {.unnumbered}

Exporting ggplots is made easy with the `ggsave()` function from **ggplot2**. It can work in two ways, either:

-   Specify the name of the plot object, then the file path and name with extension

    -   For example: `ggsave(my_plot, here("plots", "my_plot.png"))`\

-   Run the command with only a file path, to save the last plot that was printed

    -   For example: `ggsave(here("plots", "my_plot.png"))`

You can export as png, pdf, jpeg, tiff, bmp, svg, or several other file types, by specifying the file extension in the file path.

You can also specify the arguments `width =`, `height =`, and `units =` (either "in", "cm", or "mm"). You can also specify `dpi =` with a number for plot resolution (e.g. 300). See the function details by entering `?ggsave` or reading the [documentation online](https://ggplot2.tidyverse.org/reference/ggsave.html).

Remember that you can use `here()` syntax to provide the desired file path. See the \[Import and export\] page for more information.

## Labels

Surely you will want to add or adjust the plot's labels. These are most easily done within the `labs()` function which is added to the plot with `+` just as the geoms were.

Within `labs()` you can provide character strings to these arguements:

-   `x =` and `y =` The x-axis and y-axis title (labels)\
-   `title =` The main plot title\
-   `subtitle =` The subtitle of the plot, in smaller text below the title\
-   `caption =` The caption of the plot, in bottom-right by default

Here is a plot we made earlier, but with nicer labels:

```{r, warning=F, message=F}
age_by_wt <- ggplot(
  data = linelist,   # set data
  mapping = aes(     # map aesthetics to column values
         x = age,           # map x-axis to age            
         y = wt_kg,         # map y-axis to weight
         color = age))+     # map color to age
  geom_point()+           # display data as points
  labs(
    title = "Age and weight distribution",
    subtitle = "Fictional Ebola outbreak, 2014",
    x = "Age in years",
    y = "Weight in kilos",
    color = "Age",
    caption = stringr::str_glue("Data as of {max(linelist$date_hospitalisation, na.rm=T)}"))

age_by_wt
```

Note how in the caption assignment we used `str_glue()` from the **stringr** package to implant dynamic R code within the string text. The caption will show the "Data as of: " date that reflects the maximum hospitalization date in the linelist. Read more about this in the page on \[Characters and strings\].

A note on specifying the *legend* title: There is no one "legend title" argument, as you could have multiple scales in your legend. Within `labs()`, you can write the argument for the plot aesthetic used to create the legend, and provide the title this way. For example, above we assigned `color = age` to create the legend. Therefore, we provide `color =` to `labs()` and assign the legend title desired ("Age" with capital A). If you create the legend with `aes(fill = COLUMN)`, then in `labs()` you would write `fill =` to adjust the title of that legend. The section on color scales in the \[ggplot tips\] page provides more details on editing legends, and an alternative approach using `scales_()` functions.

## Themes {#ggplot_basics_themes}

One of the best parts of **ggplot2** is the amount of control you have over the plot - you can define anything! As mentioned above, the design of the plot that is *not* related to the data shapes/geometries are adjusted within the `theme()` function. For example, the plot background color, presence/absence of gridlines, and the font/size/color/alignment of text (titles, subtitles, captions, axis text...). These adjustments can be done in one of two ways:

-   Add a [*complete theme*](https://ggplot2.tidyverse.org/reference/ggtheme.html) `theme_()` function to make sweeping adjustments - these include `theme_classic()`, `theme_minimal()`, `theme_dark()`, `theme_light()` `theme_grey()`, `theme_bw()` among others\
-   Adjust each tiny aspect of the plot individually within `theme()`

### Complete themes {.unnumbered}

As they are quite straight-forward, we will demonstrate the complete theme functions below and will not describe them further here. Note that any micro-adjustments with `theme()` should be made *after* use of a complete theme.

Write them with empty parentheses.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme classic")+
  theme_classic()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme bw")+
  theme_bw()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme minimal")+
  theme_minimal()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme gray")+
  theme_gray()
  


```

### Modify theme {.unnumbered}

The `theme()` function can take a large number of arguments, each of which edits a very specific aspect of the plot. There is no way we could cover all of the arguments, but we will describe the general pattern for them and show you how to find the argument name that you need. The basic syntax is this:

1.  Within `theme()` write the argument name for the plot element you want to edit, like `plot.title =`\
2.  Provide an `element_()` function to the argument\

-   Most often, use `element_text()`, but others include `element_rect()` for canvas background colors, or `element_blank()` to remove plot elements\

4.  Within the `element_()` function, write argument assignments to make the fine adjustments you desire

So, that description was quite abstract, so here are some examples.

The below plot looks quite silly, but it serves to show you a variety of the ways you can adjust your plot.

-   We begin with the plot `age_by_wt` defined just above and add `theme_classic()`\
-   For finer adjustments we add `theme()` and include one argument for each plot element to adjust

It can be nice to organize the arguments in logical sections. To describe just some of those used below:

-   `legend.position =` is unique in that it accepts simple values like "bottom", "top", "left", and "right". But generally, text-related arguments require that you place the details *within* `element_text()`.\
-   Title size with `element_text(size = 30)`\
-   The caption horizontal alignment with `element_text(hjust = 0)` (from right to left)\
-   The subtitle is italicized with `element_text(face = "italic")`

```{r, , warning=F, message=F}
age_by_wt + 
  theme_classic()+                                 # pre-defined theme adjustments
  theme(
    legend.position = "bottom",                    # move legend to bottom
    
    plot.title = element_text(size = 30),          # size of title to 30
    plot.caption = element_text(hjust = 0),        # left-align caption
    plot.subtitle = element_text(face = "italic"), # italicize subtitle
    
    axis.text.x = element_text(color = "red", size = 15, angle = 90), # adjusts only x-axis text
    axis.text.y = element_text(size = 15),         # adjusts only y-axis text
    
    axis.title = element_text(size = 20)           # adjusts both axes titles
    )     
```

Here are some especially common `theme()` arguments. You will recognize some patterns, such as appending `.x` or `.y` to apply the change only to one axis.

+-------------------------------------+-----------------------------------------------------------------+
| `theme()` argument                  | What it adjusts                                                 |
+=====================================+=================================================================+
| `plot.title = element_text()`       | The title                                                       |
+-------------------------------------+-----------------------------------------------------------------+
| `plot.subtitle = element_text()`    | The subtitle                                                    |
+-------------------------------------+-----------------------------------------------------------------+
| `plot.caption = element_text()`     | The caption (family, face, color, size, angle, vjust, hjust...) |
+-------------------------------------+-----------------------------------------------------------------+
| `axis.title = element_text()`       | Axis titles (both x and y) (size, face, angle, color...)        |
+-------------------------------------+-----------------------------------------------------------------+
| `axis.title.x = element_text()`     | Axis title x-axis only (use `.y` for y-axis only)               |
+-------------------------------------+-----------------------------------------------------------------+
| `axis.text = element_text()`        | Axis text (both x and y)                                        |
+-------------------------------------+-----------------------------------------------------------------+
| `axis.text.x = element_text()`      | Axis text x-axis only (use `.y` for y-axis only)                |
+-------------------------------------+-----------------------------------------------------------------+
| `axis.ticks = element_blank()`      | Remove axis ticks                                               |
+-------------------------------------+-----------------------------------------------------------------+
| `axis.line = element_line()`        | Axis lines (colour, size, linetype: solid dashed dotted etc)    |
+-------------------------------------+-----------------------------------------------------------------+
| `strip.text = element_text()`       | Facet strip text (colour, face, size, angle...)                 |
+-------------------------------------+-----------------------------------------------------------------+
| `strip.background = element_rect()` | facet strip (fill, colour, size...)                             |
+-------------------------------------+-----------------------------------------------------------------+

But there are so many theme arguments! How could I remember them all? Do not worry - it is impossible to remember them all. Luckily there are a few tools to help you:

The **tidyverse** documentation on [modifying theme](https://ggplot2.tidyverse.org/reference/theme.html), which has a complete list.

[***TIP:*** Run `theme_get()` from **ggplot2** to print a list of all 90+ `theme()` arguments to the console.]{style="color: darkgreen;"}

[***TIP:*** If you ever want to remove an element of a plot, you can also do it through `theme()`. Just pass `element_blank()` to an argument to have it disappear completely. For legends, set `legend.position = "none".`]{style="color: darkgreen;"}

## Colors

Please see this [section on color scales of the ggplot tips page](#ggplot_tips_colors).

## Piping into **ggplot2**

When using pipes to clean and transform your data, it is easy to pass the transformed data into `ggplot()`.

The pipes that pass the dataset from function-to-function will transition to `+` once the `ggplot()` function is called. Note that in this case, there is no need to specify the `data =` argument, as this is automatically defined as the piped-in dataset.

This is how that might look:

```{r, warning=F, message=F}
linelist %>%                                                     # begin with linelist
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns
  pivot_longer(                                                  # pivot longer
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # replace missing values
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  
  ggplot(                                                        # begin ggplot!
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )
```

## Plot continuous data

Throughout this page, you have already seen many examples of plotting continuous data. Here we briefly consolidate these and present a few variations.\
Visualisations covered here include:

-   Plots for one continuous variable:

    -   **Histogram**, a classic graph to present the distribution of a continuous variable.
    -   **Box plot** (also called box and whisker), to show the 25th, 50th, and 75th percentiles, tail ends of the distribution, and outliers ([important limitations](https://www.data-to-viz.com/caveat/boxplot.html)).\
    -   **Jitter plot**, to show all values as points that are 'jittered' so they can (mostly) all be seen, even where two have the same value.\
    -   **Violin plot**, show the distribution of a continuous variable based on the symmetrical width of the 'violin'.
    -   **Sina plot**, are a combination of jitter and violin plots, where individual points are shown but in the symmetrical shape of the distribution (via **ggforce** package).\

-   **Scatter plot** for two continuous variables.\

-   **Heat plots** for three continuous variables (linked to \[Heat plots\] page)

### Histograms {.unnumbered}

Histograms may look like bar charts, but are distinct because they measure the distribution of a *continuous* variable. There are no spaces between the "bars", and only one column is provided to `geom_histogram()`.

Below is code for generating **histograms**, which group continuous data into ranges and display in adjacent bars of varying height. This is done using `geom_histogram()`. See the ["Bar plot" section](#ggplot_basics_bars) of the ggplot basics page to understand difference between `geom_histogram()`, `geom_bar()`, and `geom_col()`.

We will show the distribution of ages of cases. Within `mapping = aes()` specify which column you want to see the distribution of. You can assign this column to either the x or the y axis.

The rows will be assigned to "bins" based on their numeric age, and these bins will be graphically represented by bars. If you specify a number of bins with the `bins =` plot aesthetic, the break points are evenly spaced between the minimum and maximum values of the histogram. If `bins =` is unspecified, an appropriate number of bins will be guessed and this message displayed after the plot:

    ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

If you do not want to specify a number of bins to `bins =`, you could alternatively specify `binwidth =` in the units of the axis. We give a few examples showing different bins and bin widths:

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# A) Regular histogram
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram()+
  labs(title = "A) Default histogram (30 bins)")

# B) More bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(bins = 50)+
  labs(title = "B) Set to 50 bins")

# C) Fewer bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(bins = 5)+
  labs(title = "C) Set to 5 bins")


# D) More bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(binwidth = 1)+
  labs(title = "D) binwidth of 1")

```

To get smoothed proportions, you can use `geom_density()`:

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# Frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age)) +
  geom_density(size = 2, alpha = 0.2)+
  labs(title = "Proportional density")

# Stacked frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age, fill = gender)) +
  geom_density(size = 2, alpha = 0.2, position = "stack")+
  labs(title = "'Stacked' proportional densities")
```

To get a "stacked" histogram (of a continuous column of data), you can do one of the following:

1)  Use `geom_histogram()` with the `fill =` argument within `aes()` and assigned to the grouping column, or\
2)  Use `geom_freqpoly()`, which is likely easier to read (you can still set `binwidth =`)\
3)  To see proportions of all values, set the `y = after_stat(density)` (use this syntax exactly - not changed for your data). Note: these proportions will show *per group*.

Each is shown below (\*note use of `color =` vs. `fill =` in each):

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# "Stacked" histogram
ggplot(data = linelist, mapping = aes(x = age, fill = gender)) +
  geom_histogram(binwidth = 2)+
  labs(title = "'Stacked' histogram")

# Frequency 
ggplot(data = linelist, mapping = aes(x = age, color = gender)) +
  geom_freqpoly(binwidth = 2, size = 2)+
  labs(title = "Freqpoly")

# Frequency with proportion axis
ggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +
  geom_freqpoly(binwidth = 5, size = 2)+
  labs(title = "Proportional freqpoly")

# Frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +
  geom_density(size = 2, alpha = 0.2)+
  labs(title = "Proportional, smoothed with geom_density()")
```

If you want to have some fun, try `geom_density_ridges` from the **ggridges** package ([vignette here](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html).

Read more in detail about histograms at the **tidyverse** [page on geom_histogram()](https://ggplot2.tidyverse.org/reference/geom_histogram.html).

### Box plots {.unnumbered}

Box plots are common, but have important limitations. They can obscure the actual distribution - e.g. a bi-modal distribution. See this [R graph gallery](https://www.r-graph-gallery.com/boxplot.html) and this [data-to-viz article](https://www.data-to-viz.com/caveat/boxplot.html) for more details. However, they do nicely display the inter-quartile range and outliers - so they can be overlaid on top of other types of plots that show the distribution in more detail.

Below we remind you of the various components of a boxplot:

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "boxplot.png"))
```

When using `geom_boxplot()` to create a box plot, you generally map only one axis (x or y) within `aes()`. The axis specified determines if the plots are horizontal or vertical.

In most geoms, you create a plot per group by mapping an aesthetic like `color =` or `fill =` to a column within `aes()`. However, for box plots achieve this by assigning the grouping column to the un-assigned axis (x or y). Below is code for a boxplot of *all* age values in the dataset, and second is code to display one box plot for each (non-missing) gender in the dataset. Note that `NA` (missing) values will appear as a separate box plot unless removed. In this example we also set the `fill` to the column `outcome` so each plot is a different color - but this is not necessary.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# A) Overall boxplot
ggplot(data = linelist)+  
  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)
  labs(title = "A) Overall boxplot")

# B) Box plot by group
ggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + 
  geom_boxplot()+                     
  theme(legend.position = "none")+   # remove legend (redundant)
  labs(title = "B) Boxplot by gender")      
```

For code to add a box plot to the edges of a scatter plot ("marginal" plots) see the page \[ggplot tips\].

### Violin, jitter, and sina plots {.unnumbered}

Below is code for creating **violin plots** (`geom_violin`) and **jitter plots** (`geom_jitter`) to show distributions. You can specify that the fill or color is also determined by the data, by inserting these options within `aes()`.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}


# A) Jitter plot by group
ggplot(data = linelist %>% drop_na(outcome),      # remove missing values
       mapping = aes(y = age,                     # Continuous variable
           x = outcome,                           # Grouping variable
           color = outcome))+                     # Color variable
  geom_jitter()+                                  # Create the violin plot
  labs(title = "A) jitter plot by gender")     



# B) Violin plot by group
ggplot(data = linelist %>% drop_na(outcome),       # remove missing values
       mapping = aes(y = age,                      # Continuous variable
           x = outcome,                            # Grouping variable
           fill = outcome))+                       # fill variable (color)
  geom_violin()+                                   # create the violin plot
  labs(title = "B) violin plot by gender")    
```

You can combine the two using the `geom_sina()` function from the **ggforce** package. The sina plots the jitter points in the shape of the violin plot. When overlaid on the violin plot (adjusting the transparencies) this can be easier to visually interpret.

```{r, warning=F, message=F}

# A) Sina plot by group
ggplot(
  data = linelist %>% drop_na(outcome), 
  aes(y = age,           # numeric variable
      x = outcome)) +    # group variable
  geom_violin(
    aes(fill = outcome), # fill (color of violin background)
    color = "white",     # white outline
    alpha = 0.2)+        # transparency
  geom_sina(
    size=1,                # Change the size of the jitter
    aes(color = outcome))+ # color (color of dots)
  scale_fill_manual(       # Define fill for violin background by death/recover
    values = c("Death" = "#bf5300", 
              "Recover" = "#11118c")) + 
  scale_color_manual(      # Define colours for points by death/recover
    values = c("Death" = "#bf5300", 
              "Recover" = "#11118c")) + 
  theme_minimal() +                                # Remove the gray background
  theme(legend.position = "none") +                # Remove unnecessary legend
  labs(title = "B) violin and sina plot by gender, with extra formatting")      


```

### Two continuous variables {.unnumbered}

Following similar syntax, `geom_point()` will allow you to plot two continuous variables against each other in a **scatter plot**. This is useful for showing actual values rather than their distributions. A basic scatter plot of age vs weight is shown in (A). In (B) we again use `facet_grid()` to show the relationship between two continuous variables in the linelist.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# Basic scatter plot of weight and age
ggplot(data = linelist, 
       mapping = aes(y = wt_kg, x = age))+
  geom_point() +
  labs(title = "A) Scatter plot of weight and age")

# Scatter plot of weight and age by gender and Ebola outcome
ggplot(data = linelist %>% drop_na(gender, outcome), # filter retains non-missing gender/outcome
       mapping = aes(y = wt_kg, x = age))+
  geom_point() +
  labs(title = "B) Scatter plot of weight and age faceted by gender and outcome")+
  facet_grid(gender ~ outcome) 

```

### Three continuous variables {.unnumbered}

You can display three continuous variables by utilizing the `fill =` argument to create a *heat plot*. The color of each "cell" will reflect the value of the third continuous column of data. See the \[ggplot tips\] page and the page on on \[Heat plots\] for more details and several examples.

There are ways to make 3D plots in R, but for applied epidemiology these are often difficult to interpret and therefore less useful for decision-making.

## Plot categorical data

Categorical data can be character values, could be logical (TRUE/FALSE), or factors (see the \[Factors\] page).

### Preparation {.unnumbered}

#### Data structure {.unnumbered}

The first thing to understand about your categorical data is whether it exists as raw observations like a linelist of cases, or as a summary or aggregate data frame that holds counts or proportions. The state of your data will impact which plotting function you use:

-   If your data are raw observations with one row per observation, you will likely use `geom_bar()`\
-   If your data are already aggregated into counts or proportions, you will likely use `geom_col()`

#### Column class and value ordering {.unnumbered}

Next, examine the class of the columns you want to plot. We look at `hospital`, first with `class()` from **base** R, and with `tabyl()` from **janitor**.

```{r}
# View class of hospital column - we can see it is a character
class(linelist$hospital)

# Look at values and proportions within hospital column
linelist %>% 
  tabyl(hospital)
```

We can see the values within are characters, as they are hospital names, and by default they are ordered alphabetically. There are 'other' and 'missing' values, which we would prefer to be the last subcategories when presenting breakdowns. So we change this column into a factor and re-order it. This is covered in more detail in the \[Factors\] page.

```{r}
# Convert to factor and define level order so "Other" and "Missing" are last
linelist <- linelist %>% 
  mutate(
    hospital = fct_relevel(hospital, 
      "St. Mark's Maternity Hospital (SMMH)",
      "Port Hospital", 
      "Central Hospital",
      "Military Hospital",
      "Other",
      "Missing"))

```

```{r}
levels(linelist$hospital)
```

### `geom_bar()` {#ggplot_basics_bars .unnumbered}

Use `geom_bar()` if you want bar height (or the height of stacked bar components) to reflect *the number of relevant rows in the data*. These bars will have gaps between them, unless the `width =` plot aesthetic is adjusted.

-   Provide only one axis column assignment (typically x-axis). If you provide x and y, you will get `Error: stat_count() can only have an x or y aesthetic.`\
-   You can create stacked bars by adding a `fill =` column assignment within `mapping = aes()`\
-   The opposite axis will be titled "count" by default, because it represents the number of rows

Below, we have assigned outcome to the y-axis, but it could just as easily be on the x-axis. If you have longer character values, it can sometimes look better to flip the bars sideways and put the legend on the bottom. This may impact how your factor levels are ordered - in this case we reverse them with `fct_rev()` to put missing and other at the bottom.

```{r, out.width=c('50%', '50%'), fig.show='hold'}
# A) Outcomes in all cases
ggplot(linelist %>% drop_na(outcome)) + 
  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +
  theme_minimal()+
  labs(title = "A) Number of cases by hospital",
       y = "Hospital")


# B) Outcomes in all cases by hosptial
ggplot(linelist %>% drop_na(outcome)) + 
  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +
  theme_minimal()+
  theme(legend.position = "bottom") +
  labs(title = "B) Number of recovered and dead Ebola cases, by hospital",
       y = "Hospital")

```

### `geom_col()` {.unnumbered}

Use `geom_col()` if you want bar height (or height of stacked bar components) to reflect pre-calculated *values* that exists in the data. Often, these are summary or "aggregated" counts, or proportions.

Provide column assignments for *both* axes to `geom_col()`. Typically your x-axis column is discrete and your y-axis column is numeric.

Let's say we have this dataset `outcomes`:

```{r, echo = F}
outcomes <- linelist %>% 
  drop_na() %>% 
  group_by(outcome) %>% 
  count %>% 
  ungroup() %>% # Ungroup so proportion is out of total
  mutate(proportion = n/sum(n)*100) # Caculate percentage
  
outcomes #View full table
```

Below is code using `geom_col` for creating simple bar charts to show the distribution of Ebola patient outcomes. With geom_col, both x and y need to be specified. Here x is the categorical variable along the x axis, and y is the generated proportions column `proportion`.

```{r, fig.height = 3, fig.width=4.5}
# Outcomes in all cases
ggplot(outcomes) + 
  geom_col(aes(x=outcome, y = proportion)) +
  labs(subtitle = "Number of recovered and dead Ebola cases")

```

To show breakdowns by hospital, we would need our table to contain more information, and to be in "long" format. We create this table with the frequencies of the combined categories `outcome` and `hospital` (see \[Grouping data\] page for grouping tips).

```{r, fig.height = 4, fig.width=6}
outcomes2 <- linelist %>% 
  drop_na(outcome) %>% 
  count(hospital, outcome) %>%  # get counts by hospital and outcome
  group_by(hospital) %>%        # Group so proportions are out of hospital total
  mutate(proportion = n/sum(n)*100) # calculate proportions of hospital total

head(outcomes2) # Preview data
```

We then create the ggplot with some added formatting:

-   **Axis flip**: Swapped the axis around with `coord_flip()` so that we can read the hospital names.
-   **Columns side-by-side**: Added a `position = "dodge"` argument so that the bars for death and recover are presented side by side rather than stacked. Note stacked bars are the default.
-   **Column width**: Specified 'width', so the columns are half as thin as the full possible width.
-   **Column order**: Reversed the order of the categories on the y axis so that 'Other' and 'Missing' are at the bottom, with `scale_x_discrete(limits=rev)`. Note that we used that rather than `scale_y_discrete` because hospital is stated in the `x` argument of `aes()`, even if visually it is on the y axis. We do this because Ggplot seems to present categories backwards unless we tell it not to.\
-   **Other details**: Labels/titles and colours added within `labs` and `scale_fill_color` respectively.

```{r, fig.height = 4, fig.width=8}

# Outcomes in all cases by hospital
ggplot(outcomes2) +  
  geom_col(
    mapping = aes(
      x = proportion,                 # show pre-calculated proportion values
      y = fct_rev(hospital),          # reverse level order so missing/other at bottom
      fill = outcome),                # stacked by outcome
    width = 0.5)+                    # thinner bars (out of 1)
  theme_minimal() +                  # Minimal theme 
  theme(legend.position = "bottom")+
  labs(subtitle = "Number of recovered and dead Ebola cases, by hospital",
       fill = "Outcome",             # legend title
       y = "Count",                  # y axis title
       x = "Hospital of admission")+ # x axis title
  scale_fill_manual(                 # adding colors manually
    values = c("Death"= "#3B1c8C",
               "Recover" = "#21908D" )) 

```

Note that the proportions are binary, so we may prefer to drop 'recover' and just show the proportion who died. This is just for illustration purposes.

If using `geom_col()` with dates data (e.g. an epicurve from aggregated data) - you will want to adjust the `width =` argument to remove the "gap" lines between the bars. If using daily data set `width = 1`. If weekly, `width = 7`. Months are not possible because each month has a different number of days.

### `geom_histogram()` {.unnumbered}

Histograms may look like bar charts, but are distinct because they measure the distribution of a *continuous* variable. There are no spaces between the "bars", and only one column is provided to `geom_histogram()`. There are arguments specific to histograms such as `bin_width =` and `breaks =` to specify how the data should be binned. The section above on continuous data and the page on \[Epidemic curves\] provide additional detail.

## Resources

There is a huge amount of help online, especially with ggplot. See:

-   [ggplot2 cheat sheet](http://r-statistics.co/ggplot2-cheatsheet.html)
-   [another cheat sheet](https://biostats.w.uib.no/the-ggplot2-cheat-sheet-by-rstudio/)
-   [tidyverse ggplot basics page](https://ggplot2.tidyverse.org/reference/)\
-   [plotting continuous variables](http://www.sthda.com/english/articles/32-r-graphics-essentials/131-plot-two-continuous-variables-scatter-graph-and-alternatives/)\
-   R for Data Science pages on [data visualization](https://r4ds.had.co.nz/data-visualisation.html)
-   [graphics for communicaton](https://r4ds.had.co.nz/graphics-for-communication.html)


# 重複データの排除 {}  

```{r, out.width=c("50%"), echo=F}
knitr::include_graphics(here::here("images", "deduplication.png"))
```

このページでは、重複データの排除に関する以下のテクニックを扱います：  

1. 重複する行の特定と削除  
2. 各行のグループから特定の行（最小値や最大値など）のみを残す「行のスライス」  
3. 「ロールアップ」、つまり複数の行の値を1つの行にまとめる  


<!-- ======================================================= -->
## 準備 { }


### パッケージの読み込み {.unnumbered}

このコードチャンクは、このページに必要なパッケージのロードを示しています。このハンドブックでは **pacman** の `p_load()` を利用しています。これは必要に応じてパッケージのインストールとロードを<u>と同時に</u>行います。また、インストールされているパッケージを **base** R の `library()` でロードすることもできます。R のパッケージについては、[R の基礎](#basics)のページを参照してください。  

```{r}
pacman::p_load(
  tidyverse,   # 重複排除、グループ化、スライスの関数
  janitor,     # 重複部分の確認をする関数
  stringr)      # 文字列検索で、値の "ロールアップ"に使用
```

### データのインポート {.unnumbered}

ここでは、以下のRコードで作成されたデータセットの例を使ってデモを行います。  

データはCOVID-19の電話調査の記録で、接触者と感染者の記録が含まれます。`recordID`（コンピュータで生成）、`personID`、`name`、`date`、`time`、`purpose`（接触者か感染者か）、`symptoms_ever`（その人が、症状があったことを*一度でも*報告したかどうか）といった列があります。  

以下は、`obs` データセットを作成するコードです：

```{r}
obs <- data.frame(
  recordID  = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),
  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),
  name      = c("adam", "adam", "amrish", "amrish", "mariah", "amrish", "nikhil", "brian", "smita", "raquel", "amrish",
                "adam", "mariah", "mariah", "nikhil", "brian", "brian", "raquel", "natalie"),
  date      = c("1/1/2020", "1/1/2020", "2/1/2020", "2/1/2020", "5/1/2020", "5/1/2020", "5/1/2020", "5/1/2020", "5/1/2020","5/1/2020", "2/1/2020",
                "5/1/2020", "6/1/2020", "6/1/2020", "6/1/2020", "6/1/2020", "7/1/2020", "7/1/2020", "7/1/2020"),
  time      = c("09:00", "09:00", "14:20", "14:20", "12:00", "16:10", "13:01", "15:20", "14:20", "12:30", "10:24",
                "09:40", "07:25", "08:32", "15:36", "15:31", "07:59", "11:13", "17:12"),
  encounter = c(1,1,1,1,1,3,1,1,1,1,2,
                2,2,3,2,2,3,2,1),
  purpose   = c("contact", "contact", "contact", "contact", "case", "case", "contact", "contact", "contact", "contact", "contact",
                "case", "contact", "contact", "contact", "contact", "case", "contact", "case"),
  symptoms_ever = c(NA, NA, "No", "No", "No", "Yes", "Yes", "No", "Yes", NA, "Yes",
                    "No", "No", "No", "Yes", "Yes", "No","No", "No")) %>% 
  mutate(date = as.Date(date, format = "%d/%m/%Y"))
```


#### これが元のデータセットです {#dedup_data .unnumbered}  

上部のフィルターボックスを使って、各人の記録を確認します。  

```{r message=FALSE, echo=F}
DT::datatable(obs, rownames = FALSE, filter = "top", options = list(pageLength = nrow(obs), scrollX=T), class = 'white-space: nowrap' )
```


データを確認する際に注意すべき点がいくつかあります：  

* 最初の 2 つのレコードは100%完全な重複で、`recordID` も重複している（コンピュータの不具合でしょう！）  
* 2 番目の 2 行は、<u>`recordID` を除く</u>すべての列で重複している  
* 何人かの人が、様々な日時に、接触者や感染者として、複数の電話での調査があったこと  
* それぞれの調査で、その人が**今まで**症状があったかどうかを尋ねられ、この情報の一部が欠損している  


**janitor** の `tabyl()` を使って、名前と目的を簡単にまとめました：  

```{r}
obs %>% 
  tabyl(name, purpose)
```
<!-- ======================================================= -->
## 重複排除 { }


ここでは、データフレーム内の重複する行を確認し、削除する方法を説明します。また、ベクトル内の重複する要素を処理する方法も示します。  


<!-- ======================================================= -->
### 重複する行を調べる {.unnumbered}  


重複している行を素早く確認するには、 **janitor** パッケージの `get_dupes()` を使います。<u>通常</u>この関数が返す行は、<u>すべての</u>列の値を考慮した 100% の重複です。  

`obs` データフレームでは、最初の 2 行が<u> 100% 重複</u>しています。これらはすべての列で同じ値を持っています（一意であることが<u>想定される</u> `recordID` 列を含む）。データフレームには、右側に新しい列 `dupe_count` が自動的に追加され、重複した値の組み合わせを持つ行の数が表示されます。 

```{r, eval=F}
# すべての列で 100％ 重複
obs %>% 
  janitor::get_dupes()
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes() %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = nrow(obs), scrollX = T), class = 'white-space: nowrap')
```

[元のデータセット](#dedup_data)をご覧ください。  

しかし，`recordID`を無視して考えると，3行目と4行目の行も重複していることになります。つまり，`recordID`を<u>除く</u>すべての列で同じ値を持つことになります。関数の中で無視する列を指定するには、マイナス記号`-`を使います。  

```{r, eval=F}
# recordID 列を考慮しない場合すべて重複している
obs %>% 
  janitor::get_dupes(-recordID)         # 複数の列がある場合は、c() で囲む
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes(-recordID) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = nrow(obs), scrollX = T), class = 'white-space: nowrap')
```

考慮する列を明示的に指定することもできます。以下では、`name` と `purpose` という列に同じ値を持つ行のみが返されます。"amrish" の `dupe_count` が 3 になっていることに注目してください。これは、3 回の "接触者"との出会いを反映しています。  

<u>さらに行を表示するには左にスクロールします</u>  

```{r, eval=F}
# name と purpose の列に基づいて重複するもののみ
obs %>% 
  janitor::get_dupes(name, purpose)
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes(name, purpose) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 7, scrollX = T), class = 'white-space: nowrap')
```

[元のデータセット](#dedup_data)をご覧ください。  

詳細は `?get_dupes` をご覧ください。また、こちらの[オンラインリファレンス](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes) もご参照ください。  






<!-- ======================================================= -->
### ユニークな行のみを保持する  {.unnumbered}


データフレームのユニークな行のみを保持するには、**dplyr** の `distinct()` を使います（[データクリーニングと主要関数]のページで説明しています）。重複している行は削除され、そのような行の最初の行だけが保持されます。デフォルトでは、"最初"とは最も上位の `rownumber` （行の上から下への順序）を意味します。その結果、ユニークな行だけが残ります。  

以下の例では、`recordID` という列を考慮せず`distinct()` を実行して、**2つの重複した行を削除**しています。最初の行（"adam" の行）は100%重複しており、削除されます。また、3行目（"amrish" の行）は、`recordID` を*除く*すべての列で重複しており、削除されます。その結果、`obs` データセットの n は `nrow(obs)` ではなく、`nrow(obs) - 2` になります。  

<u>左にスクロールすると、データフレーム全体が表示されます。</u>  


```{r, eval=F}
# パイプの連なりに加える（データクリーニング）
obs %>% 
  distinct(across(-recordID), # データフレームをユニークな行だけにする（重複している最初の行は残す）
           .keep_all = TRUE) 

# パイプを使わない場合は、以下のように第一引数にデータを入れる 
# distinct(obs)
```

```{r message=FALSE, echo=F}
obs %>% 
  distinct(across(-recordID), # データフレームをユニークな行だけにする（重複している最初の行は残す）
           .keep_all = TRUE) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 6, scrollX = T), class = 'white-space: nowrap')
```

<span style="color: orange;">**_注意：_** グループ化されたデータに `distinct()` を使う場合は、各グループごとに適用されます。</span>


**特定の列に基づいて重複排除する**  

重複排除の基準となる列を指定することもできます。これにより、指定した列の中で重複している行にのみ重複排除が適用されます。また `.keep_all = TRUE` を設定しない限り、指定されていないすべての列が削除されます。  

以下の例では、`name` 列と `purpose` 列の値が同じ行にのみ重複排除が適用されます。したがって、"brian" は3行から2行になります。これは彼の<u>最初の</u>"接触者"との出会いと、彼の唯一の"感染者"との出会いです。brian の各目的の<u>最新</u>の出会いが保持されるように調整するには、「グループ内のスライス」のタブを参照してください。  

<u>左にスクロールすると、データフレーム全体が表示されます。</u>  

```{r, eval=F}
# パイプの連なりに加える（例：データクリーニング）
obs %>% 
  distinct(name, purpose, .keep_all = TRUE) %>%  # name と purpose によってユニーク行にし、すべての列を保持する
  arrange(name)                                  # 見やすさのために並び替える
```

```{r message=FALSE, echo=F}
obs %>% 
  distinct(name, purpose, .keep_all = TRUE) %>%  # name と purpose によってユニーク行にし、すべての列を保持する
  arrange(name) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 6, scrollX = T), class = 'white-space: nowrap')
```

[元のデータセット](#dedup_data)をご覧ください。  

<!-- ======================================================= -->
### ベクトル内の要素の重複排除 {.unnumbered}  


**base** R の関数 `duplicated()` は、ベクトル（列）を評価して、同じ長さの論理ベクトル（TRUE/FALSE）を返します。最初に値が現れたときはFALSE（重複していない）を返し、それ以降に値が現れたときはTRUEを返します。`NA` が他の値と同じように扱われることに注意してください。    

```{r}
x <- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)
duplicated(x)
```

重複した要素だけを返したい場合は、ブラケット[ ] を使って元のベクトルを抜き出すことができます： 

```{r}
x[duplicated(x)]
```

ユニークな要素だけを返すには、**base** Rの `unique()` を使います。`NA` を出力から取り除くには、`unique()` の中に `na.omit()` を入れます。  

```{r}
unique(x)           # 代わりに x[!duplicated(x)] を使うこともできる
unique(na.omit(x))  # NAを削除
```


<!-- ======================================================= -->
### **base** R を使う{.unnumbered}

**重複する行を返す**  

**base** R では、データフレーム `df` の中でどの行が 100% 重複しているかを、`duplicated(df)` というコマンドで確認できます（行の論理ベクトルを返します）。  

したがって、サブセット `[ ]` をデータフレームに使用して、`df[duplicated(df),]` (すべての列を見るという意味のコンマを忘れないでください！)で<u>重複</u>した行を見ることもできます。 

**ユニークな行を返す**  

上記のメモを参照してください。<u>ユニークな</u>行を見るには、`duplicated()` 関数の前に論理否定子`!`を加えます：  
`df[!duplicated(df),]`  


**特定の列だけが重複している行を返す**  

`duplicated()` の<u>括弧内</u>にある `df` を抜き出して、この関数が `df` の特定の列のみを操作するようにします。  

列を指定するには、コンマの後に列番号または名前を入力してください（これらはすべて、`duplicated()` 関数の<u>中で</u>行われます）。  

`duplicated()` の後には、必ずコンマ `,` を<u>外側</u>に置くようにしてください。 

例えば、2列目から5列目のみ重複の評価をする場合： `df[!duplicated(df[, 2:5]),]`  
`name` と `purpose` の列のみ重複の評価をする場合： `df[!duplicated(df[, c("name", "purpose")]),]`  





<!-- ======================================================= -->
## スライシング { }


データフレームを「スライス」して、行番号/位置による行のフィルタリングを適用できます。これは、グループごと（例えば、"person"ごと）に複数の行があり、そのうちの1つまたはいくつかだけを残したい場合に特に有効です。 

基本的な `slice()` 関数は、数値を受け取り、その位置にある行を返します。指定された数値が正の値であれば、その値のみが返されます。負の値の場合、それらの行は返されません。数値はすべて正またはすべて負でなければなりません。     

```{r}
obs %>% slice(4)  # 4 番目の行を返す
```

```{r}
obs %>% slice(c(2,4))  # 2、4 番目の行を返す
#obs %>% slice(c(2:4))  # 2～4 番目の行を返す
```


[元のデータセット](#dedup_data)をご覧ください。 

いくつかのバリエーションがあります。 これらは，返す列の数と行の数を `n = ` に入れる必要があります。  

* `slice_min()` と `slice_max()` は、指定した列の最小値や最大値を持つ行のみを保持します。これは，順序付き因子の "min"と "max"を返すのにも使えます。    
* `slice_head()` と `slice_tail()` は、*最初*または*最後*の行のみを保持します。  
* `slice_sample()` - 行をランダムにサンプリングします。  


```{r}
obs %>% slice_max(encounter, n = 1)  # 最大の encounter を持つ行を返す
```

保持する行の数または割合を指定するには、引数 `n = ` または `prop = ` を使用します。この関数をパイプの中で使用しない場合は、第一引数にデータを指定してください（例：`slice(data, n = 2)`）。詳細は `?slice` を参照してください。 

その他の引数：  

`.order_by = ` は slice_min() や slice_max() の中でスライスする前に順序付ける列を指定するのに使用されます。  
`with_ties = ` デフォルトはTRUEで、タイが保持されます。  
`.preserve = ` デフォルトはFALSEです。TRUEの場合、スライス後にグループの構造が再計算されます。  
`weight_by = ` オプションで、重み付けのための数値列を指定します（数字が大きいほどサンプリングされる可能性が高い）。 また、サンプリングが復元／非復元で行われるかを示す `replace = ` もあります。  

<span style="color: darkgreen;">**_ヒント：_** `slice_max()` や `slice_min()` を使用する際には，必ず `n = ` を指定し記述してください（例：`2` だけでなく、`n = 2`）。そうしないと、`Error: `...` is not empty.` というエラーが発生することがあります。 </span>

<span style="color: black;">**_注意：_** [top_n()`](https://dplyr.tidyverse.org/reference/top_n.html) という関数が出てくることがありますが、これは `slice` 関数に取って代わられました。</span>

 


<!-- ======================================================= -->
### グループごとのスライス  {.unnumbered}

`slice_*()` をグループ化されたデータフレームに適用すると、スライス操作が各グループに対して個別に実行されるので、非常に便利です。`group_by()` と `slice()` という**関数**を併用してデータをグループ化し、各グループからスライスを取得します。  

これは、人ごとに複数の行があり、そのうちの1つだけを残したい場合の重複排除に役立ちます。まず、人ごとに同じキーとなる列で `group_by()` を使用し、次に異なる列でスライス関数を使用します。  

以下の例では、<u>一人あたり</u>の<u>最新</u>の encounter のみを保持するために、`name` で行をグループ化し、`date` 列に `n = 1` で `slice_max()` を使用します。`slice_max()` のような関数を日付に適用するには、Dateクラス にするのに注意してください。   

デフォルトでは、「タイ」（このシナリオでは同じ日付など）が保持されるため、一部の人（adam など）については複数の行が表示されてしまいます。これを避けるために、`with_ties = FALSE` とします。これにより、1 人につき 1 つの行のみが返されます。  

<span style="color: orange;">**_注意：_** `arrange()`を使用する場合は、`.by_group = TRUE` を指定すると、各グループごとにデータが並び替えられます。</span>

<span style="color: red;">**_危険：_** `with_ties = FALSE`の 場合、タイの最初の行が保持されます。これはわかりづらいかもしれません。Mariah の場合、最新の日付 (1 月 6 日) に 2 つの出会いがあり、最初（最も早い）の出会いが保持されています。その日の後のほうの出会いを保持したいです。次の例では、これらのタイを「破る」方法を見てみます。 </span>  




```{r, eval=F}
obs %>% 
  group_by(name) %>%       # 行を name 列でグループ化
  slice_max(date,          # グループごとに最大の日付の値を持つ行を保持 
            n = 1,         # 最上位の行のみを残す 
            with_ties = F) # 日付がタイの場合、最初の列を取る
```

```{r message=FALSE, echo=F}
obs %>% 
  group_by(name) %>%       # 行を name 列でグループ化
  slice_max(date,          # グループごとに最大の日付の値を持つ行を保持 
            n = 1,         # 最上位の行のみを残す 
            with_ties = F) %>%  # 日付がタイの場合、最初の列を取る
  DT::datatable(rownames = FALSE, options = list(pageLength = 8, scrollX = T), class = 'white-space: nowrap')
```

上の例では、Amrish では 1 月 5 日の行だけ、また Brian では 1 月 7 日の行だけが保持されています。[元のデータセット](#dedup_data)をご覧ください。  


**"タイ"を破る**  

複数のスライス文を実行して、「タイを破る」ことができます。この場合、最新の<u>日付</u>に複数の encounter がある場合、最新の<u>時間</u>の encounter が保持されます（文字クラスの時間を並べ替えるために、`lubridate::hm()` で time クラスに変換しました）。  
"Mariah"の 1 月 6 日の 行は、07:25 の encounter 2 ではなく、08:32 の encounter 3 になっていることに注意してください。  

```{r, eval=F}
# "タイを破る"ための複数のスライスの例
obs %>%
  group_by(name) %>%
  
  # まず、最新の日付でスライスする
  slice_max(date, n = 1, with_ties = TRUE) %>% 
  
  # 次に、タイの場合は最新の時刻の行を選択する（タイは認められない）
  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)
```

```{r message=FALSE, echo=F}
# "タイを破る"ための複数のスライスの例
obs %>%
  group_by(name) %>%
  
  # まず、最新の日付でスライスする
  slice_max(date, n = 1, with_ties = TRUE) %>% 
  
  # 次に、タイの場合は最新の時刻の行を選択する（タイは認められない）
  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE) %>% 
  
  DT::datatable(rownames = FALSE, options = list(pageLength = 8, scrollX = T), class = 'white-space: nowrap')
```

<u>上の例では `encounter` の番号でスライスすることも可能ですが、例として `date` と `time` でスライスしています。</u>  

<span style="color: darkgreen;">**_ヒント：_** `slice_max()` や `slice_min()` を "character" の列に使用するには、それを <u>ordered</u> factor クラスに変換します！</span>

[元のデータセット](#dedup_data)をご覧ください。  


<!-- ======================================================= -->
### すべてを残すが、マークをつける  {.unnumbered}

すべての記録を残しつつ、一部の記録だけを分析対象としたい場合は、ユニークな recordID / encounter の番号を利用した 2 段階のアプローチを検討します。  

1) 元のデータフレームを、分析に必要な行だけにスライスし、データフレームを保存する。  
2) 元のデータフレームで、ユニークな識別子（ここでは recordID）が 1 のデータフレームに存在するかどうかに基づいて、`case_when()` で適切に行をマークする。  


```{r}
# 1. 分析のために保持する行のデータフレームを定義する
obs_keep <- obs %>%
  group_by(name) %>%
  slice_max(encounter, n = 1, with_ties = FALSE) # 一人一人の最新の encounter のみを残す


# 2. 元のデータフレームにマークをつける
obs_marked <- obs %>%

  # 新しい dup_record 列の作成
  mutate(dup_record = case_when(
    
    # レコードが obs_keep のデータフレームにある場合
    recordID %in% obs_keep$recordID ~ "For analysis", 
    
    # それ以外は、分析のために「無視」とマークする
    TRUE                            ~ "Ignore"))

# 出力
obs_marked
```


```{r, echo=F}
DT::datatable(obs_marked, rownames = FALSE, options = list(pageLength = 8, scrollX = T), class = 'white-space: nowrap')
```

[元のデータセット](#dedup_data)をご覧ください。  

<!-- ======================================================= -->
### 行の完全性の計算 {.unnumbered} 

行の完全性（非欠損性）の指標を含む列を作成します。これは、重複排除やスライスの際に、どの行を他の行よりも優先させるかを決定する際に役立ちます。  

この例では、完全性を測定したい「キー」となる列を、列名のベクトルに保存します。  

そして、`mutate()` で `key_completeness` という新しい列を作成します。各行の新しい値は、計算された割合として定義されます。つまり、その行のキーカラムのうち欠落していない値の数を、キーカラムの数で割ったものです。  

これには **base** R の `rowSums()` 関数が使われています。また、`.` も使われています。パイプの中では、その時点でのデータフレームを参照します（この場合は括弧 `[ ]` で囲まれたサブセット）。  

**右にスクロールすると、他の列が表示されます**  

```{r, eval=F}
# "キー変数の完全性"列の作成
# これは、"key_cols" として指定された列のうち、値が欠損していない<u>割合</u>です。

key_cols = c("personID", "name", "symptoms_ever")

obs %>% 
  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) 
```

```{r message=FALSE, echo=F}
key_cols = c("personID", "name", "symptoms_ever")

obs %>% 
  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX = T), class = 'white-space: nowrap')
```

[元のデータセット](#dedup_data)をご覧ください。  




<!-- ======================================================= -->
## ロールアップした値 {#str_rollup}


このセクションでは、以下を説明します。：  

1) 複数の行の値を1つの行に「ロールアップ」する（まとめる）方法（いくつかのバリエーションを含む）  
2) 値をロールアップした後、各セルの値を上書き／優先させる方法  

このタブでは、「準備」タブのサンプルデータセットを使用します。  



<!-- ======================================================= -->
### ロールアップした値を一列に並べる {.unnumbered}  

以下のコード例では、`group_by()` と `summarise()` を使って行を人ごとにグループ化し、グループ化された行の中のユニークな値をすべて貼り付けています。このようにして、1 人につき 1 つの要約行が得られます。ここでいくつかの注意点があります。  

* すべての新しい列に接尾辞が追加されます（ここでは "_roll"）。  
* セルごとにユニークな値だけを表示したい場合は、`na.omit()` を `unique()` で囲みます。  
* `na.omit()` は `NA` 値を削除しますが、これを望まない場合は `paste0(.x)` を削除します...  



```{r, eval=F}
# 値を「personID」ごとに1行にロールアップ 
cases_rolled <- obs %>% 
  
  # 名前でグループ化
  group_by(personID) %>% 
  
  # 各グループ内で行を並べ替え（例：日付順）
  arrange(date, .by_group = TRUE) %>% 
  
  # 各列で、グループ化された行のすべての値を"; "で区切って貼り付け
  summarise(
    across(everything(),                           # すべての列に適用
           ~paste0(na.omit(.x), collapse = "; "))) # 欠損値でない値を結合する関数
```

結果として、グループ（`ID`）ごとに1つの行が作成され、日付で並べ替えられた値が貼り合わされます。*左にスクロールすると、より多くの行が表示されます*。    

```{r message=FALSE, echo=F}
# 値を「personID」ごとに1行にロールアップ 
obs %>% 
  
  # 名前でグループ化
  group_by(personID) %>% 
  
  # 各グループ内で行を並べ替え（例：日付順）
  arrange(date, .by_group = TRUE) %>% 
  
  # 各列で、グループ化された行のすべての値を"; "で区切って貼り付け
  summarise(
    across(everything(),                                # すべての列に適用
           ~paste0(na.omit(.x), collapse = "; "))) %>%  # 欠損値でない値を結合する関数

  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX = T), class = 'white-space: nowrap')
```

[元のデータセット](#dedup_data)をご覧ください。  


**ここでは、ユニークな値のみを表示します。**  

```{r}
# バリエーション - ユニークな値のみを表示 
cases_rolled <- obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                                   # すべての列に適用
           ~paste0(unique(na.omit(.x)), collapse = "; "))) # 欠損値でない値を結合する関数
```

```{r message=FALSE, echo=F}
# バリエーション - ユニークな値のみを表示 
obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                                   # すべての列に適用
           ~paste0(unique(na.omit(.x)), collapse = "; "))) %>%  # 欠損値でない値を結合する関数

  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX = T), class = 'white-space: nowrap')
```


**ここでは、各列に接尾辞を付加します。**  
この場合は「_roll」で、ロールされたことを表します：  

```{r, eval=F}
# バリエーション - カラム名に接尾辞を追加 
cases_rolled <- obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                
           list(roll = ~paste0(na.omit(.x), collapse = "; ")))) # 列名に「_roll」を付加
```

```{r message=FALSE, echo=F}
# ラインリストのデータを表形式で表示
# バリエーション - カラム名に接尾辞を追加 
obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                
           list(roll = ~paste0(na.omit(.x), collapse = "; ")))) %>%  # 列名に「_roll」を付加
  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX = T), class = 'white-space: nowrap')
```


<!-- ======================================================= -->
### 値と階層の上書き {.unnumbered} 


ロールされた値をすべて評価して、特定の値（例えば、"best" や "maximum" の値）だけを残したい場合は、目的の列で `mutate()` を使用し、 **stringr** パッケージの `str_detect()` で文字列パターンを順に探し、セルの内容を上書きするように `case_when()` を使用します。  

```{r}
# クリーンなケース
#############
cases_clean <- cases_rolled %>% 
    
    # クリーンな Yes-No-Unknown 列: 文字列に存在する "highest" の値でテキストを置き換える
    mutate(across(c(contains("symptoms_ever")),                     # 指定された列を操作（Y/N/U）
             list(mod = ~case_when(                                 # 新しい列に接尾辞 "_mod" を追加し、case_when() を実装
               
               str_detect(.x, "Yes")       ~ "Yes",                 # "Yes"が検出された場合、セルの値が "Yes" に変換される
               str_detect(.x, "No")        ~ "No",                  # "No "が検出された場合、セルの値が "No" に変換される
               str_detect(.x, "Unknown")   ~ "Unknown",             # "Unknown" が検出された場合、セルの値が "Unknown" に変換される
               TRUE                        ~ as.character(.x)))),   # それ以外の場合はそのままの値とする
      .keep = "unused")                                             # 古い列は削除し、_mod 列のみを残す
```


これで、`symptoms_ever` という列に、その人が症状に対して「Yes」と答えたことがある場合、「Yes」だけが表示されていることがわかります。  

```{r message=FALSE, echo=F}
# ラインリストのデータを表形式で表示
DT::datatable(cases_clean, rownames = FALSE, options = list(pageLength = 10, scrollX = T), class = 'white-space: nowrap')
```


[元のデータセット](#dedup_data)をご覧ください。  


## 確率的重複排除  

名前、年齢、性別、生年月日などの複数の列における類似性（文字列の「距離」など）に基づいて、「重複している可能性が高い」ものを特定したい場合があります。重複している可能性が高いものを特定するために、確率的マッチングアルゴリズムを適用することができます。  

この方法についての説明は、[データの結合]のページを参照してください。確率的マッチングのページでは、これらのアルゴリズムを適用して、データフレームと*それ自身*を比較し、確率的な重複排除を行う例を紹介しています。  



<!-- ======================================================= -->
## リソース { }

このページに掲載されている情報の多くは、これらのリソースやオンライン上のビネットを参考にしています：

[datanovia](https://www.datanovia.com/en/lessons/identify-and-remove-duplicate-data-in-r/)

[dplyr tidyverse reference](https://dplyr.tidyverse.org/reference/slice.html)  

[cran janitor vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes)  

